{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Safeguards Documentation","text":"<p>Welcome to the Safeguards documentation. This library provides a comprehensive framework for implementing safety measures in multi-agent systems.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Core Concepts - Essential concepts and terminology</li> <li>Installation Guide - Detailed installation instructions</li> <li>Quick Start Guide - Get started with the framework</li> <li>Component Status - Current status of framework components</li> </ul>"},{"location":"#usage-guides","title":"Usage Guides","text":""},{"location":"#budget-management","title":"Budget Management","text":"<ul> <li>Budget Management - How to manage agent budgets</li> </ul>"},{"location":"#safety-features","title":"Safety Features","text":"<ul> <li>Safety Policies - Implementing and enforcing safety policies</li> <li>Safeguards - Safety features and guardrails</li> <li>Plugins - Plugin framework and custom safeguards</li> <li>Industry-Specific Safeguards - Pre-built and custom industry safeguards</li> </ul>"},{"location":"#monitoring-and-alerting","title":"Monitoring and Alerting","text":"<ul> <li>Monitoring - Metrics, visualization, and alerts</li> <li>Human-in-the-Loop - Human review and approval workflows</li> <li>Notification Channels - Configuring notification channels</li> </ul>"},{"location":"#coordination","title":"Coordination","text":"<ul> <li>Agent Coordination - Multi-agent coordination</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Core API - Core API reference</li> <li>Budget API - Budget management API</li> <li>Monitoring API - Monitoring API</li> <li>Notifications API - Notifications API</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Architecture Overview - System design</li> <li>Contributing - How to contribute to the project</li> <li>Publishing - How to publish new versions</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>The <code>examples/</code> directory contains several example scripts demonstrating different features:</p> <ul> <li><code>single_agent.py</code> - Basic example with a single agent</li> <li><code>budget_control_example.py</code> - Budget management example</li> <li><code>multi_agent.py</code> - Coordinating multiple agents</li> <li><code>notification_setup.py</code> - Setting up notifications</li> <li><code>guardrails_example.py</code> - Using guardrails</li> <li><code>budget_monitoring.py</code> - Monitoring agent budgets</li> <li><code>human_in_loop_example.py</code> - Human-in-the-loop approval workflows</li> </ul>"},{"location":"#faq-and-troubleshooting","title":"FAQ and Troubleshooting","text":"<ul> <li>Frequently Asked Questions - Common questions and answers</li> <li>Troubleshooting - Solutions to common problems</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide - How to install the framework</li> <li>Quick Start Guide - Get up and running quickly</li> <li>Core Concepts - Essential concepts and terminology</li> </ul>"},{"location":"#user-guides","title":"User Guides","text":"<ul> <li>Basic Usage - General usage patterns</li> <li>Budget Management - Managing agent budgets and resource allocation</li> <li>Safety Policies - Implementing and enforcing safety policies</li> <li>Agent Safety - Safety features, guardrails, and protection mechanisms</li> <li>Monitoring - Metrics collection, visualization, and alerting</li> <li>Agent Coordination - Managing multiple agents</li> <li>Notifications &amp; Alerts - Setting up and managing notifications</li> <li>Safety Guardrails - Implementing safety guardrails</li> </ul>"},{"location":"#api-reference_1","title":"API Reference","text":"<ul> <li>Core API - Core components and interfaces</li> <li>Budget API - Budget management APIs</li> <li>Monitoring API - Monitoring APIs</li> <li>Agent API - Agent management APIs</li> <li>Configuration API - Configuration APIs</li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Multi-agent Coordination - Advanced coordination techniques</li> <li>Dynamic Budget Allocation - Dynamic budget strategies</li> <li>Custom Safety Rules - Creating custom safety rules</li> <li>Performance Optimization - Optimizing framework performance</li> <li>Security Considerations - Security best practices</li> </ul>"},{"location":"#development_1","title":"Development","text":"<ul> <li>Architecture Overview - System architecture</li> <li>Contributing Guide - How to contribute to the project</li> <li>Code Style Guide - Coding conventions</li> <li>Testing Guide - How to test the framework</li> </ul>"},{"location":"#examples-tutorials","title":"Examples &amp; Tutorials","text":"<ul> <li>Basic Setup Tutorial - Setting up the framework</li> <li>Budget Management Tutorial - Tutorial on budget management</li> <li>Custom Agent Creation - Creating custom agents</li> <li>Integration Examples - Integrating with other systems</li> </ul>"},{"location":"#building-documentation-locally","title":"Building Documentation Locally","text":"<p>To build this documentation locally:</p> <pre><code># Install documentation dependencies\npip install -e \".[docs]\"\n\n# Navigate to the docs directory\ncd docs\n\n# Build the documentation\nmake html\n</code></pre> <p>The built documentation will be available in the <code>_build/html</code> directory.</p>"},{"location":"#documentation-standards","title":"Documentation Standards","text":"<ul> <li>All code examples should be tested and working</li> <li>Include type hints in all example code</li> <li>Use consistent terminology throughout the documentation</li> <li>Reference specific versions where functionality changes between versions</li> <li>Include troubleshooting sections for common issues</li> </ul>"},{"location":"#contributing-to-documentation","title":"Contributing to Documentation","text":"<p>We welcome contributions to the documentation! Please see our Contributing Guide for details on how to contribute.</p>"},{"location":"#license","title":"License","text":"<p>This documentation is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>This document explains the core concepts and terminology used throughout the Safeguards.</p>"},{"location":"concepts/#overview","title":"Overview","text":"<p>The Safeguards is built around several key concepts:</p> <ol> <li>Agents - The entities that perform tasks</li> <li>Budgets - Resource constraints for agent operations</li> <li>Pools - Shared resource containers</li> <li>Coordination - Management of resources across agents</li> <li>Monitoring - Observation of system metrics</li> <li>Guardrails - Safety mechanisms that prevent harmful actions</li> <li>Notifications - Alerts and messages about system status</li> </ol>"},{"location":"concepts/#agents","title":"Agents","text":"<p>An agent in this framework represents an autonomous entity that performs tasks and consumes resources. The <code>Agent</code> class is the base abstraction for all agent implementations.</p> <p>Key characteristics of agents:</p> <ul> <li>Identity: Each agent has a unique identifier</li> <li>Budget: Agents consume budget when performing actions</li> <li>Priority: Agents can have different priority levels (1-10)</li> <li>State: Agents maintain state between operations</li> </ul> <p>Agents are registered with the system and their resource usage is tracked throughout their lifecycle.</p>"},{"location":"concepts/#budgets","title":"Budgets","text":"<p>Budgets represent the resources available to agents. These are typically numerical values (e.g., tokens, API calls, compute time) that are consumed when agents perform actions.</p> <p>Key characteristics of budgets:</p> <ul> <li>Initial Allocation: Starting amount of resources</li> <li>Usage Tracking: System tracks consumption over time</li> <li>Limits: Configurable thresholds (hourly, daily, total)</li> <li>Warnings: Alerts when approaching limits</li> </ul>"},{"location":"concepts/#budget-pools","title":"Budget Pools","text":"<p>Budget pools are containers that hold shared resources that can be distributed among multiple agents. Pools allow for more efficient resource allocation and sharing.</p> <p>Key characteristics of pools:</p> <ul> <li>Total Budget: Overall resources available in the pool</li> <li>Allocated Budget: Resources currently assigned to agents</li> <li>Priority: Pools have priority levels for resource contention</li> <li>Minimum Balance: Required minimum resources to maintain</li> </ul>"},{"location":"concepts/#budget-coordination","title":"Budget Coordination","text":"<p>Budget coordination is the process of managing resource allocation, transfers, and rebalancing across agents and pools.</p> <p>Key capabilities:</p> <ul> <li>Registration: Adding agents and pools to the system</li> <li>Transfer: Moving resources between agents or pools</li> <li>Allocation: Distributing resources based on priorities</li> <li>Rebalancing: Dynamically adjusting allocations based on usage patterns</li> <li>Emergency Handling: Special procedures for critical operations</li> </ul>"},{"location":"concepts/#monitoring","title":"Monitoring","text":"<p>Monitoring involves tracking system metrics, agent behavior, and resource usage to ensure safe operation.</p> <p>Key monitoring aspects:</p> <ul> <li>Resource Metrics: CPU, memory, disk usage</li> <li>Agent Metrics: Budget usage, action counts, latency</li> <li>System Metrics: Overall usage, error rates, health status</li> <li>Historical Analysis: Trend detection and pattern recognition</li> </ul>"},{"location":"concepts/#safety-guardrails","title":"Safety Guardrails","text":"<p>Guardrails are protective mechanisms that prevent unsafe operations. They typically implement validation logic that runs before agent actions.</p> <p>Types of guardrails:</p> <ul> <li>Budget Guardrails: Prevent budget overruns</li> <li>Resource Guardrails: Prevent excessive resource consumption</li> <li>Permission Guardrails: Enforce access controls</li> <li>Content Guardrails: Validate inputs and outputs for safety</li> <li>Rate Guardrails: Prevent too many operations in a time window</li> </ul>"},{"location":"concepts/#notifications-alerts","title":"Notifications &amp; Alerts","text":"<p>The notification system provides visibility into system events, warnings, and errors.</p> <p>Key elements:</p> <ul> <li>Alert Levels: Different severity levels (INFO, WARNING, ERROR, CRITICAL)</li> <li>Channels: Different notification methods (console, email, webhook)</li> <li>Targeting: Specific notifications for specific components or agents</li> <li>Thresholds: Configurable thresholds for generating alerts</li> </ul>"},{"location":"concepts/#apis-contracts","title":"APIs &amp; Contracts","text":"<p>The framework uses API contracts to define consistent interfaces across different versions.</p> <p>Key API categories:</p> <ul> <li>Agent API: For agent management</li> <li>Budget API: For budget operations</li> <li>Metrics API: For monitoring and metrics</li> <li>Config API: For system configuration</li> <li>Notification API: For alerts and notifications</li> </ul>"},{"location":"concepts/#transactions","title":"Transactions","text":"<p>The framework uses a transaction system to ensure operations that span multiple resources remain consistent.</p> <p>Key aspects:</p> <ul> <li>Atomicity: Operations succeed completely or fail completely</li> <li>Consistency: System remains in a valid state</li> <li>Isolation: Concurrent operations don't interfere</li> <li>Durability: Completed operations persist</li> </ul>"},{"location":"concepts/#priority-levels","title":"Priority Levels","text":"<p>Priority determines the importance of agents, pools, and operations, influencing resource allocation.</p> <p>Priority levels range from 1-10:</p> <ul> <li>1-2: Low priority (background tasks)</li> <li>3-5: Normal priority (standard operations)</li> <li>6-8: High priority (important services)</li> <li>9-10: Critical priority (essential services)</li> </ul>"},{"location":"concepts/#violation-types","title":"Violation Types","text":"<p>When safety rules are broken, the system generates violation reports with specific types:</p> <ul> <li>Overspend: Budget exceeded allocated amount</li> <li>Rate Limit: Too many operations in a time window</li> <li>Resource Breach: Exceeded resource allocation</li> <li>Unauthorized: Attempted operation without permission</li> <li>Pool Breach: Pool resources depleted below minimum</li> </ul>"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts, you can explore: - Quick Start Guide to begin implementing the framework - Architecture Overview for a deeper technical understanding - API Reference for detailed interface documentation</p>"},{"location":"configuration/","title":"Safeguards Configuration Guide","text":""},{"location":"configuration/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Security Rules Configuration</li> <li>Pre-commit Hooks</li> <li>GitHub Actions Security Workflow</li> <li>Security Scanning Tools</li> <li>Troubleshooting</li> </ol>"},{"location":"configuration/#security-rules-configuration","title":"Security Rules Configuration","text":""},{"location":"configuration/#basic-rule-chain-setup","title":"Basic Rule Chain Setup","text":"<pre><code>from safeguards.rules.base import RuleChain\nfrom safeguards.rules.defaults import PermissionGuardrail, SecurityContextRule\n\nchain = RuleChain()\nchain.add_rule(rule1)\nchain.add_rule(rule2)\n</code></pre>"},{"location":"configuration/#default-rules","title":"Default Rules","text":""},{"location":"configuration/#1-permission-guardrail","title":"1. Permission Guardrail","text":"<pre><code>permission_rule = PermissionGuardrail(\n    required_permissions={\"read\", \"write\"},\n    role_permissions={\n        \"admin\": {\"read\", \"write\", \"delete\"},\n        \"editor\": {\"read\", \"write\"},\n        \"viewer\": {\"read\"},\n    }\n)\n</code></pre>"},{"location":"configuration/#2-security-context-rule","title":"2. Security Context Rule","text":"<pre><code>security_rule = SecurityContextRule(\n    required_security_level=\"medium\",  # Options: low, medium, high\n    allowed_environments={\"prod\", \"staging\", \"dev\"}\n)\n</code></pre>"},{"location":"configuration/#3-resource-limit-rule","title":"3. Resource Limit Rule","text":"<pre><code>resource_rule = ResourceLimitRule(\n    max_memory_mb=1024,\n    max_cpu_percent=80\n)\n</code></pre>"},{"location":"configuration/#4-rate-limit-rule","title":"4. Rate Limit Rule","text":"<pre><code>rate_rule = RateLimitRule(\n    max_requests=100,\n    time_window_seconds=60\n)\n</code></pre>"},{"location":"configuration/#rule-dependencies","title":"Rule Dependencies","text":"<p>Rules can specify dependencies that must be evaluated first: <pre><code>rule = CustomRule(\n    dependencies=[PermissionGuardrail, SecurityContextRule]\n)\n</code></pre></p>"},{"location":"configuration/#rule-priority-levels","title":"Rule Priority Levels","text":"<ul> <li><code>CRITICAL</code>: Must pass, blocks execution</li> <li><code>HIGH</code>: Should pass, may block based on config</li> <li><code>MEDIUM</code>: Warning if fails</li> <li><code>LOW</code>: Informational only</li> </ul>"},{"location":"configuration/#pre-commit-hooks","title":"Pre-commit Hooks","text":""},{"location":"configuration/#installation","title":"Installation","text":"<pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"configuration/#available-hooks","title":"Available Hooks","text":"<ol> <li> <p>GitLeaks: Secret detection    <pre><code>- repo: https://github.com/zricethezav/gitleaks\n  rev: v8.18.1\n  hooks:\n  - id: gitleaks\n</code></pre></p> </li> <li> <p>Bandit: Python security checks    <pre><code>- repo: https://github.com/PyCQA/bandit\n  rev: 1.7.6\n  hooks:\n  - id: bandit\n</code></pre></p> </li> <li> <p>Safety: Dependency scanning    <pre><code>- repo: https://github.com/Lucas-C/pre-commit-hooks-safety\n  rev: v1.3.3\n  hooks:\n  - id: python-safety-dependencies-check\n</code></pre></p> </li> </ol>"},{"location":"configuration/#custom-hook-configuration","title":"Custom Hook Configuration","text":"<p>See <code>.pre-commit-config.yaml</code> for full configuration options.</p>"},{"location":"configuration/#github-actions-security-workflow","title":"GitHub Actions Security Workflow","text":""},{"location":"configuration/#workflow-triggers","title":"Workflow Triggers","text":"<ul> <li>Push to main branch</li> <li>Pull requests</li> <li>Daily scheduled scan</li> </ul>"},{"location":"configuration/#available-scans","title":"Available Scans","text":"<ol> <li>GitLeaks for secret detection</li> <li>Safety Check for dependencies</li> <li>Bandit for code analysis</li> <li>Semgrep for pattern matching</li> <li>Dependency Review</li> <li>Snyk vulnerability scanning</li> </ol>"},{"location":"configuration/#required-secrets","title":"Required Secrets","text":"<ul> <li><code>GITHUB_TOKEN</code>: Automatically provided</li> <li><code>SNYK_TOKEN</code>: Required for Snyk integration</li> </ul>"},{"location":"configuration/#security-scanning-tools","title":"Security Scanning Tools","text":""},{"location":"configuration/#bandit-configuration","title":"Bandit Configuration","text":"<p>Configure in <code>.bandit.yml</code>: <pre><code>exclude_dirs: ['.git', 'tests', 'docs']\nskips: []\nlevel: LOW\nconfidence: LOW\n</code></pre></p>"},{"location":"configuration/#gitleaks-configuration","title":"GitLeaks Configuration","text":"<p>Configure in <code>.gitleaks.toml</code>: <pre><code>[allowlist]\npaths = [\n    '''.*test.*''',\n    '''.*example.*''',\n]\n\n[[rules]]\nid = \"custom-pattern\"\nregex = '''pattern'''\n</code></pre></p>"},{"location":"configuration/#semgrep-configuration","title":"Semgrep Configuration","text":"<p>Configured in workflow: <pre><code>- name: Run Semgrep\n  run: semgrep ci --config=auto\n</code></pre></p>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/#common-issues","title":"Common Issues","text":"<ol> <li>Pre-commit Hook Failures</li> <li>Check hook configuration in <code>.pre-commit-config.yaml</code></li> <li>Run <code>pre-commit run --all-files</code> for details</li> <li> <p>Update hooks: <code>pre-commit autoupdate</code></p> </li> <li> <p>GitHub Actions Failures</p> </li> <li>Check workflow run logs</li> <li>Verify required secrets are set</li> <li> <p>Check tool-specific configuration files</p> </li> <li> <p>Security Rule Violations</p> </li> <li>Review violation messages</li> <li>Check rule configuration</li> <li>Verify input data format</li> </ol>"},{"location":"configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Rule Chain Configuration</li> <li>Order rules by priority</li> <li>Consider dependencies</li> <li> <p>Use appropriate priority levels</p> </li> <li> <p>Security Scanning</p> </li> <li>Regular dependency updates</li> <li>Monitor scan results</li> <li> <p>Address high-priority issues first</p> </li> <li> <p>Custom Rules</p> </li> <li>Follow rule interface</li> <li>Include comprehensive tests</li> <li>Document requirements</li> </ol>"},{"location":"configuration/#getting-help","title":"Getting Help","text":"<ul> <li>Check GitHub issues</li> <li>Review documentation</li> <li>Contact maintainers</li> </ul>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Safeguards, make sure you have:</p> <ul> <li>Python 3.10 or newer</li> <li>pip package manager</li> </ul>"},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>Install the package using pip:</p> <pre><code>pip install agent-safeguards\n</code></pre> <p>This will install the core package with all required dependencies.</p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development work, install with additional development dependencies:</p> <pre><code>pip install agent-safeguards[dev]\n</code></pre> <p>This includes: - Testing tools (pytest, pytest-asyncio, pytest-cov) - Code formatting (black, isort) - Linting (flake8) - Type checking (mypy)</p>"},{"location":"installation/#documentation-installation","title":"Documentation Installation","text":"<p>To build documentation locally:</p> <pre><code>pip install agent-safeguards[docs]\n</code></pre> <p>This includes: - Sphinx documentation generator - Read the Docs theme - Type hints support</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>You can verify the installation by running:</p> <pre><code>from safeguards import BudgetManager, ResourceMonitor\nfrom safeguards.types import Agent\n\n# Should not raise any ImportError\n</code></pre>"},{"location":"installation/#system-dependencies","title":"System Dependencies","text":"<p>The package requires <code>psutil</code> for system resource monitoring. On some systems, you might need to install additional system packages:</p>"},{"location":"installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt-get update\nsudo apt-get install python3-dev\n</code></pre>"},{"location":"installation/#centosrhel","title":"CentOS/RHEL","text":"<pre><code>sudo yum install python3-devel\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":"<p>No additional system packages required.</p>"},{"location":"installation/#windows","title":"Windows","text":"<p>No additional system packages required.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":"<ol> <li> <p>ImportError: No module named 'psutil'    <pre><code>pip install --no-cache-dir psutil\n</code></pre></p> </li> <li> <p>Build failures on Windows    <pre><code>pip install --upgrade setuptools wheel\n</code></pre></p> </li> <li> <p>Permission errors during installation    <pre><code>pip install --user agent-safeguards\n</code></pre></p> </li> </ol> <p>For more issues, please check our GitHub Issues page.</p>"},{"location":"memory_management/","title":"Memory Management Guide","text":""},{"location":"memory_management/#overview","title":"Overview","text":"<p>The Safeguards includes comprehensive memory management and caching features to optimize resource usage and improve performance. This guide covers the key components and their usage.</p>"},{"location":"memory_management/#memory-manager","title":"Memory Manager","text":"<p>The <code>MemoryManager</code> class provides centralized memory optimization and resource tracking:</p> <pre><code>from safeguards.core.memory_manager import MemoryManager\n\n# Initialize memory manager\nmemory_manager = MemoryManager(gc_threshold=(700, 10, 10))\n\n# Create object pool\npool = memory_manager.create_pool(\n    name=\"request_pool\",\n    factory=lambda: Request(),\n    max_size=100\n)\n\n# Use pooled objects\nobj = pool.acquire()\ntry:\n    # Use object\n    process_request(obj)\nfinally:\n    pool.release(obj)\n\n# Track resources\nresource = create_resource()\nmemory_manager.track_resource(resource)\n\n# Cleanup\nmemory_manager.cleanup_resources()\n</code></pre>"},{"location":"memory_management/#features","title":"Features","text":"<ol> <li>Object Pooling</li> <li>Reuse objects to reduce allocation overhead</li> <li>Thread-safe pool operations</li> <li> <p>Configurable pool sizes</p> </li> <li> <p>Resource Tracking</p> </li> <li>Automatic cleanup of unused resources</li> <li>Weak reference tracking</li> <li> <p>Asynchronous cleanup</p> </li> <li> <p>Cache Management</p> </li> <li>Namespace-based caching</li> <li>Cache statistics tracking</li> <li>Selective cache clearing</li> </ol>"},{"location":"memory_management/#cache-manager","title":"Cache Manager","text":"<p>The <code>CacheManager</code> provides advanced caching strategies:</p> <pre><code>from safeguards.core.cache_manager import CacheManager\n\ncache_manager = CacheManager()\n\n# LRU Cache\ncache_manager.create_lru_cache(\"results\", capacity=1000)\ncache_manager.put_in_cache(\"lru\", \"results\", key, value)\nresult = cache_manager.get_from_cache(\"lru\", \"results\", key)\n\n# Timed Cache\ncache_manager.create_timed_cache(\"api_results\", ttl_seconds=300)\ncache_manager.put_in_cache(\"timed\", \"api_results\", key, value)\nresult = cache_manager.get_from_cache(\"timed\", \"api_results\", key)\n\n# Function Memoization\n@cache_manager.memoize(ttl_seconds=60)\ndef expensive_operation(x, y):\n    return x + y\n</code></pre>"},{"location":"memory_management/#caching-strategies","title":"Caching Strategies","text":"<ol> <li>LRU (Least Recently Used)</li> <li>Maintains most recently used items</li> <li>Fixed capacity</li> <li> <p>Thread-safe operations</p> </li> <li> <p>Timed Cache</p> </li> <li>Time-based expiration</li> <li>Automatic cleanup of expired entries</li> <li> <p>Configurable TTL</p> </li> <li> <p>Function Memoization</p> </li> <li>Automatic caching of function results</li> <li>Support for both LRU and timed caching</li> <li>Handles complex argument types</li> </ol>"},{"location":"memory_management/#best-practices","title":"Best Practices","text":"<ol> <li>Memory Management</li> <li>Use object pools for frequently allocated objects</li> <li>Track resources that need cleanup</li> <li> <p>Configure GC thresholds based on application needs</p> </li> <li> <p>Caching</p> </li> <li>Choose appropriate cache type (LRU vs Timed)</li> <li>Monitor cache statistics</li> <li>Set reasonable capacities and TTLs</li> <li> <p>Use memoization for expensive computations</p> </li> <li> <p>Resource Cleanup</p> </li> <li>Always release pooled objects</li> <li>Regularly call cleanup methods</li> <li>Monitor memory usage</li> </ol>"},{"location":"memory_management/#configuration","title":"Configuration","text":""},{"location":"memory_management/#memory-manager_1","title":"Memory Manager","text":"<pre><code>MemoryManager(\n    gc_threshold=(700, 10, 10)  # Optional GC thresholds\n)\n</code></pre>"},{"location":"memory_management/#cache-types","title":"Cache Types","text":"<ol> <li> <p>LRU Cache <pre><code>create_lru_cache(\n    name=\"cache_name\",\n    capacity=1000  # Maximum items\n)\n</code></pre></p> </li> <li> <p>Timed Cache <pre><code>create_timed_cache(\n    name=\"cache_name\",\n    ttl_seconds=300  # Time to live\n)\n</code></pre></p> </li> </ol>"},{"location":"memory_management/#monitoring","title":"Monitoring","text":""},{"location":"memory_management/#cache-statistics","title":"Cache Statistics","text":"<pre><code># Get cache stats\nstats = cache_manager.get_stats(\"cache_name\")\nprint(f\"Hits: {stats['hits']}, Misses: {stats['misses']}\")\n</code></pre>"},{"location":"memory_management/#memory-usage","title":"Memory Usage","text":"<ul> <li>Monitor object pool utilization</li> <li>Track cache sizes</li> <li>Watch for memory leaks</li> <li>Use system monitoring tools</li> </ul>"},{"location":"memory_management/#error-handling","title":"Error Handling","text":"<ul> <li>Handle pool exhaustion</li> <li>Manage cache misses</li> <li>Implement retry mechanisms</li> <li>Log memory issues</li> </ul>"},{"location":"memory_management/#examples","title":"Examples","text":"<p>See the examples directory for: - Object pool usage patterns - Caching strategies - Resource cleanup - Performance optimization</p>"},{"location":"openai_integration/","title":"Integrating with OpenAI Agent SDK","text":"<p>This guide demonstrates how to integrate the Safeguards with the OpenAI Agent SDK to implement budget controls and monitoring.</p>"},{"location":"openai_integration/#installation","title":"Installation","text":"<pre><code>pip install safeguards openai\n</code></pre>"},{"location":"openai_integration/#basic-usage","title":"Basic Usage","text":"<pre><code>from openai import OpenAI\nfrom safeguards import AgentSafety, ConfigManager\nfrom safeguards.monitoring import MetricsAnalyzer\n\n# Initialize configuration\nconfig_manager = ConfigManager()\nconfig = config_manager.load_config(\"config.yaml\")\n\n# Initialize Agent Safety\nsafeguards = AgentSafety(config)\n\n# Initialize OpenAI client with safety wrapper\nclient = OpenAI()\nsafe_client = safeguards.wrap_openai_client(client)\n\n# Create an agent with budget controls\nagent = safe_client.beta.agents.create(\n    name=\"research_assistant\",\n    description=\"A research assistant with budget controls\",\n    model=\"gpt-4\",\n    tools=[{\"type\": \"code_interpreter\"}]\n)\n\n# The agent will now be monitored and budget-controlled\nthread = safe_client.beta.threads.create()\n\n# Add a message to the thread\nmessage = safe_client.beta.threads.messages.create(\n    thread_id=thread.id,\n    role=\"user\",\n    content=\"Research the latest developments in AI safety\"\n)\n\n# Run the agent with safety controls\nrun = safe_client.beta.threads.runs.create(\n    thread_id=thread.id,\n    agent_id=agent.id\n)\n\n# Monitor the run\nmetrics = safeguards.get_metrics(agent.id)\nprint(f\"Current budget usage: {metrics.budget_usage}%\")\nprint(f\"CPU usage: {metrics.cpu_percent}%\")\n</code></pre>"},{"location":"openai_integration/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"openai_integration/#environment-variables","title":"Environment Variables","text":"<pre><code>export SAFEGUARDS_API_API_KEY=your_api_key\nexport SAFEGUARDS_BUDGET_DEFAULT_POOL_SIZE=2000.0\nexport SAFEGUARDS_MONITORING_ALERT_THRESHOLD_CPU=90.0\n</code></pre>"},{"location":"openai_integration/#yaml-configuration","title":"YAML Configuration","text":"<pre><code>agent:\n  name: research_assistant\n  model: gpt-4\n  max_budget: 1000.0\n  priority: 1\n\nmonitoring:\n  metrics_retention_days: 30\n  alert_threshold_cpu: 80.0\n  metrics_interval: 60\n</code></pre>"},{"location":"openai_integration/#budget-control-features","title":"Budget Control Features","text":""},{"location":"openai_integration/#pool-management","title":"Pool Management","text":"<pre><code># Create a new budget pool\npool = safeguards.create_budget_pool(\n    name=\"research_pool\",\n    initial_size=1000.0,\n    priority=1\n)\n\n# Assign agent to pool\nsafeguards.assign_agent_to_pool(agent.id, pool.id)\n\n# Monitor pool usage\npool_metrics = safeguards.get_pool_metrics(pool.id)\nprint(f\"Pool utilization: {pool_metrics.utilization}%\")\n</code></pre>"},{"location":"openai_integration/#dynamic-budget-allocation","title":"Dynamic Budget Allocation","text":"<pre><code># Enable auto-scaling for the pool\nsafeguards.enable_pool_auto_scaling(\n    pool_id=pool.id,\n    min_size=500.0,\n    max_size=2000.0,\n    scale_threshold=80.0\n)\n\n# Set up budget alerts\nsafeguards.set_budget_alert(\n    agent_id=agent.id,\n    threshold=90.0,\n    callback=lambda: print(\"Budget alert triggered!\")\n)\n</code></pre>"},{"location":"openai_integration/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"openai_integration/#real-time-monitoring","title":"Real-time Monitoring","text":"<pre><code># Get real-time metrics\nmetrics = safeguards.get_real_time_metrics(agent.id)\n\n# Set up monitoring dashboard\ndashboard_url = safeguards.get_dashboard_url()\nprint(f\"Monitor your agents at: {dashboard_url}\")\n</code></pre>"},{"location":"openai_integration/#trend-analysis","title":"Trend Analysis","text":"<pre><code># Analyze resource usage trends\nanalyzer = MetricsAnalyzer()\ntrends = analyzer.analyze_resource_trends(\n    metrics_history=safeguards.get_metrics_history(agent.id),\n    metric_name=\"cpu_percent\"\n)\n\nprint(f\"Trend direction: {trends.trend_direction}\")\nprint(f\"Forecast next hour: {trends.forecast_next_hour}%\")\n</code></pre>"},{"location":"openai_integration/#usage-patterns","title":"Usage Patterns","text":"<pre><code># Analyze usage patterns\npatterns = analyzer.analyze_usage_patterns(\n    metrics_history=safeguards.get_metrics_history(agent.id)\n)\n\nprint(\"Peak usage hours:\", patterns.peak_hours)\nprint(\"Weekly pattern:\", patterns.weekly_pattern)\n</code></pre>"},{"location":"openai_integration/#best-practices","title":"Best Practices","text":"<ol> <li>Always set budget limits: Define maximum budgets for agents to prevent runaway costs.</li> <li>Monitor resource usage: Regularly check resource metrics to optimize performance.</li> <li>Use auto-scaling: Enable dynamic budget allocation for efficient resource use.</li> <li>Set up alerts: Configure alerts for budget and resource thresholds.</li> <li>Analyze patterns: Use the metrics analyzer to understand usage patterns.</li> </ol>"},{"location":"openai_integration/#error-handling","title":"Error Handling","text":"<pre><code>from safeguards.exceptions import BudgetExceededError, ResourceLimitError\n\ntry:\n    # Run agent with safety controls\n    run = safe_client.beta.threads.runs.create(\n        thread_id=thread.id,\n        agent_id=agent.id\n    )\nexcept BudgetExceededError as e:\n    print(f\"Budget exceeded: {e}\")\n    # Handle budget exceeded case\nexcept ResourceLimitError as e:\n    print(f\"Resource limit reached: {e}\")\n    # Handle resource limit case\n</code></pre>"},{"location":"openai_integration/#dashboard-integration","title":"Dashboard Integration","text":"<p>The Safeguards provides a web dashboard for monitoring and controlling your agents. Access it at <code>http://localhost:8000</code> after starting the dashboard server:</p> <pre><code>from safeguards.dashboard import start_dashboard\n\n# Start the dashboard server\nstart_dashboard(host=\"localhost\", port=8000)\n</code></pre> <p>The dashboard provides: - Real-time metrics visualization - Budget pool management - Agent monitoring and control - Usage pattern analysis - Alert configuration</p>"},{"location":"openai_integration/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details.</p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with the Safeguards, covering installation, basic setup, and common use cases.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following:</p> <ul> <li>Python 3.10 or higher</li> <li>pip package manager</li> </ul>"},{"location":"quickstart/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install agent-safeguards\n</code></pre>"},{"location":"quickstart/#install-from-source","title":"Install from Source","text":"<pre><code>git clone https://github.com/cirbuk/agent-safeguards.git\ncd agent-safeguards\npip install -e .\n</code></pre>"},{"location":"quickstart/#core-components-setup","title":"Core Components Setup","text":"<p>The Safeguards consists of several components working together:</p> <pre><code>from decimal import Decimal\nfrom safeguards.core.budget_coordination import BudgetCoordinator\nfrom safeguards.core.notification_manager import NotificationManager\nfrom safeguards.core.violation_reporter import ViolationReporter\nfrom safeguards.api import APIFactory, APIVersion\n\n# Initialize core components\nnotification_manager = NotificationManager()\nviolation_reporter = ViolationReporter(notification_manager)\nbudget_coordinator = BudgetCoordinator(notification_manager)\n\n# Create API factory\napi_factory = APIFactory()\n\n# Create APIs with specific versions\nbudget_api = api_factory.create_budget_api(APIVersion.V1, budget_coordinator)\nagent_api = api_factory.create_agent_api(APIVersion.V1, budget_coordinator)\nmetrics_api = api_factory.create_metrics_api(APIVersion.V1, budget_coordinator)\n</code></pre>"},{"location":"quickstart/#budget-management","title":"Budget Management","text":""},{"location":"quickstart/#create-budget-pools","title":"Create Budget Pools","text":"<p>Budget pools are used to group and manage resources:</p> <pre><code># Create a high-priority pool for critical operations\ncritical_pool = budget_api.create_budget_pool(\n    name=\"critical_operations\",\n    initial_budget=Decimal(\"500.0\"),\n    priority=8\n)\n\n# Create a medium-priority pool for regular operations\nregular_pool = budget_api.create_budget_pool(\n    name=\"regular_operations\",\n    initial_budget=Decimal(\"1000.0\"),\n    priority=5\n)\n\n# Create a low-priority pool for background tasks\nbackground_pool = budget_api.create_budget_pool(\n    name=\"background_tasks\",\n    initial_budget=Decimal(\"300.0\"),\n    priority=2\n)\n</code></pre>"},{"location":"quickstart/#create-agents","title":"Create Agents","text":"<p>Agents are registered with the framework and assigned initial budgets:</p> <pre><code># Create agents with different priorities\nassistant_agent = agent_api.create_agent(\n    name=\"assistant_agent\",\n    initial_budget=Decimal(\"100.0\"),\n    priority=7\n)\n\nresearch_agent = agent_api.create_agent(\n    name=\"research_agent\",\n    initial_budget=Decimal(\"150.0\"),\n    priority=5\n)\n\nsummarization_agent = agent_api.create_agent(\n    name=\"summarization_agent\",\n    initial_budget=Decimal(\"50.0\"),\n    priority=3\n)\n</code></pre>"},{"location":"quickstart/#check-and-update-budgets","title":"Check and Update Budgets","text":"<p>Monitor and modify agent budgets as needed:</p> <pre><code># Check current budget\nassistant_budget = budget_api.get_budget(assistant_agent.id)\nprint(f\"Assistant agent budget: {assistant_budget}\")\n\n# Update budget after usage\nbudget_api.update_budget(\n    assistant_agent.id,\n    assistant_budget - Decimal(\"10.0\")\n)\n\n# Get updated budget\nnew_budget = budget_api.get_budget(assistant_agent.id)\nprint(f\"Updated assistant agent budget: {new_budget}\")\n</code></pre>"},{"location":"quickstart/#creating-custom-agents","title":"Creating Custom Agents","text":"<p>Implement your own agent by extending the base <code>Agent</code> class:</p> <pre><code>from typing import Dict, Any\nfrom decimal import Decimal\nfrom safeguards.types.agent import Agent\n\nclass CustomAssistantAgent(Agent):\n    def __init__(self, name: str, model: str = \"gpt-4\"):\n        super().__init__(name)\n        self.model = model\n        self.cost_per_token = Decimal(\"0.0001\")\n        self.history = []\n\n    def run(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"Implement agent logic with resource tracking.\"\"\"\n        # Get input from kwargs\n        user_input = kwargs.get(\"input\", \"\")\n\n        # Track conversation history\n        self.history.append(f\"User: {user_input}\")\n\n        # Simulate processing with your own logic here\n        response = f\"Response to: {user_input}\"\n        self.history.append(f\"Assistant: {response}\")\n\n        # Calculate token usage (simplified example)\n        input_tokens = len(user_input.split())\n        output_tokens = len(response.split())\n        total_tokens = input_tokens + output_tokens\n        cost = self.cost_per_token * Decimal(total_tokens)\n\n        return {\n            \"response\": response,\n            \"token_count\": total_tokens,\n            \"cost\": cost\n        }\n</code></pre>"},{"location":"quickstart/#using-your-custom-agent","title":"Using Your Custom Agent","text":"<p>Register and use your custom agent with the framework:</p> <pre><code># Create your custom agent\nmy_agent = CustomAssistantAgent(\"my_assistant\", model=\"gpt-4\")\n\n# Register with the framework\nregistered_agent = agent_api.create_agent(\n    name=my_agent.name,\n    initial_budget=Decimal(\"50.0\"),\n    priority=6\n)\n\n# Use your agent and update its budget\nfor question in [\"What is the weather?\", \"Tell me a joke\", \"Explain quantum physics\"]:\n    # Run the agent\n    result = my_agent.run(input=question)\n\n    # Get the current budget\n    current_budget = budget_api.get_budget(registered_agent.id)\n\n    # Update the budget\n    new_budget = current_budget - result[\"cost\"]\n    budget_api.update_budget(registered_agent.id, new_budget)\n\n    print(f\"Response: {result['response']}\")\n    print(f\"Cost: {result['cost']}\")\n    print(f\"Remaining budget: {new_budget}\")\n</code></pre>"},{"location":"quickstart/#multi-agent-coordination","title":"Multi-Agent Coordination","text":"<p>Coordinate multiple agents working together:</p> <pre><code>from safeguards.types.enums import AgentPriority\n\ndef run_pipeline(input_text):\n    \"\"\"Run a multi-agent pipeline with budget awareness.\"\"\"\n    results = {}\n\n    # Check if all agents have sufficient budget\n    for agent_id in [research_agent.id, summarization_agent.id]:\n        budget = budget_api.get_budget(agent_id)\n        if budget &lt; Decimal(\"5.0\"):\n            print(f\"Agent {agent_id} has insufficient budget: {budget}\")\n            # Optional: request emergency budget allocation\n            budget_api.request_emergency_allocation(agent_id, Decimal(\"10.0\"))\n\n    # Step 1: Research agent processes the input\n    research_result = research_agent.run(input=input_text)\n    research_cost = research_result.get(\"cost\", Decimal(\"0\"))\n    budget_api.update_budget(\n        research_agent.id,\n        budget_api.get_budget(research_agent.id) - research_cost\n    )\n    results[\"research\"] = research_result\n\n    # Step 2: Summarization agent processes research output\n    summary_result = summarization_agent.run(\n        input=research_result.get(\"response\", \"\")\n    )\n    summary_cost = summary_result.get(\"cost\", Decimal(\"0\"))\n    budget_api.update_budget(\n        summarization_agent.id,\n        budget_api.get_budget(summarization_agent.id) - summary_cost\n    )\n    results[\"summary\"] = summary_result\n\n    return results\n</code></pre>"},{"location":"quickstart/#metrics-and-monitoring","title":"Metrics and Monitoring","text":"<p>Access metrics for analysis and monitoring:</p> <pre><code># Get metrics for a specific agent\nagent_metrics = metrics_api.get_agent_metrics(assistant_agent.id)\nprint(f\"Agent metrics: {agent_metrics}\")\n\n# Get metrics for a budget pool\npool_metrics = metrics_api.get_pool_metrics(critical_pool.id)\nprint(f\"Pool metrics: {pool_metrics}\")\n\n# Get all agent metrics for analysis\nall_agent_metrics = metrics_api.get_all_agent_metrics()\nfor agent_id, metrics in all_agent_metrics.items():\n    print(f\"Agent {agent_id}: {metrics}\")\n\n# Get budget usage history for an agent\nusage_history = metrics_api.get_agent_usage_history(\n    assistant_agent.id,\n    start_time=\"2023-01-01T00:00:00Z\",\n    end_time=\"2023-01-02T00:00:00Z\"\n)\n</code></pre>"},{"location":"quickstart/#handling-violations-and-notifications","title":"Handling Violations and Notifications","text":"<p>Set up violation handling and notifications:</p> <pre><code>from safeguards.types.enums import AlertSeverity, ViolationType\n\n# Setup notification callbacks\ndef budget_alert_callback(agent_id, alert_type, severity, message):\n    print(f\"ALERT: {severity} - {message} for agent {agent_id}\")\n    # Implement your handling logic here\n\n# Register the callback with the notification manager\nnotification_manager.register_callback(\n    \"budget_alerts\",\n    budget_alert_callback\n)\n\n# Report a violation\nviolation_reporter.report_violation(\n    agent_id=assistant_agent.id,\n    violation_type=ViolationType.BUDGET_EXCEEDED,\n    severity=AlertSeverity.HIGH,\n    message=\"Agent has exceeded its allocated budget\",\n    details={\n        \"current_budget\": Decimal(\"-10.0\"),\n        \"initial_budget\": Decimal(\"100.0\"),\n        \"overage\": Decimal(\"10.0\")\n    }\n)\n</code></pre>"},{"location":"quickstart/#advanced-configuration","title":"Advanced Configuration","text":"<p>Configure the framework for your specific needs:</p> <pre><code>from safeguards.config import SafetyConfig\n\n# Create a custom configuration\nconfig = SafetyConfig(\n    enable_emergency_allocation=True,\n    default_agent_priority=5,\n    low_budget_threshold_percentage=10,\n    enable_auto_rebalancing=True,\n    rebalance_interval_seconds=3600,  # 1 hour\n    default_notification_severity=AlertSeverity.MEDIUM\n)\n\n# Apply configuration\nbudget_coordinator.apply_config(config)\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've learned the basics, explore:</p> <ul> <li>Budget Management Guide for advanced budget techniques</li> <li>API Reference for detailed API documentation</li> <li>Agent Coordination for complex multi-agent scenarios</li> <li>Safety Rules System for implementing guardrails</li> </ul> <p>For complete examples, check the examples directory in the source code.</p>"},{"location":"advanced/dynamic_budget/","title":"Dynamic Budget Allocation","text":"<p>This guide covers advanced techniques for dynamic budget allocation in the Safeguards, enabling more adaptive and efficient resource management for your agent systems.</p>"},{"location":"advanced/dynamic_budget/#introduction-to-dynamic-allocation","title":"Introduction to Dynamic Allocation","text":"<p>Dynamic budget allocation allows your system to:</p> <ul> <li>Adapt to changing workloads and priorities</li> <li>Optimize resource utilization</li> <li>Implement complex allocation policies</li> <li>Respond to emergent patterns in agent behavior</li> <li>Create self-tuning budget management</li> </ul>"},{"location":"advanced/dynamic_budget/#advanced-budget-pool-strategies","title":"Advanced Budget Pool Strategies","text":""},{"location":"advanced/dynamic_budget/#adaptive-pool-sizing","title":"Adaptive Pool Sizing","text":"<p>Automatically size budget pools based on usage patterns:</p> <pre><code>from decimal import Decimal\nfrom safeguards.core.budget_coordination import BudgetCoordinator\nfrom safeguards.core.dynamic_budget import AdaptivePoolSizer\nfrom safeguards.types.enums import AgentPriority\n\n# Create core components\nnotification_manager = NotificationManager()\nbudget_coordinator = BudgetCoordinator(notification_manager)\n\n# Create an adaptive pool sizer\npool_sizer = AdaptivePoolSizer(\n    budget_coordinator=budget_coordinator,\n    adjustment_interval_seconds=3600,  # Check every hour\n    min_pool_budget=Decimal(\"100.0\"),\n    max_pool_budget=Decimal(\"10000.0\")\n)\n\n# Register a budget pool for adaptive sizing\npool_id = budget_coordinator.create_budget_pool(\n    name=\"adaptive_pool\",\n    initial_budget=Decimal(\"1000.0\"),\n    priority=7\n)\n\n# Configure adaptive sizing rules\npool_sizer.configure_pool(\n    pool_id=pool_id,\n    utilization_target=0.7,  # Target 70% utilization\n    growth_rate=0.2,  # Grow by 20% when needed\n    shrink_rate=0.1,  # Shrink by 10% when underutilized\n    min_agents_for_adjustment=3  # Require at least 3 agents for statistical significance\n)\n\n# Start the adaptive sizer\npool_sizer.start()\n</code></pre>"},{"location":"advanced/dynamic_budget/#priority-based-reallocation","title":"Priority-Based Reallocation","text":"<p>Dynamically reallocate budgets based on agent priorities:</p> <pre><code>from safeguards.core.dynamic_budget import PriorityBasedReallocator\nfrom safeguards.types.enums import AgentPriority\nfrom decimal import Decimal\n\n# Create a priority-based reallocator\nreallocator = PriorityBasedReallocator(\n    budget_coordinator=budget_coordinator,\n    reallocation_interval_seconds=1800,  # Check every 30 minutes\n    emergency_threshold=Decimal(\"5.0\")  # Emergency when budget below 5.0\n)\n\n# Register agents with different priorities\nagent_ids = []\npriorities = [\n    AgentPriority.CRITICAL,\n    AgentPriority.HIGH,\n    AgentPriority.MEDIUM,\n    AgentPriority.LOW\n]\n\nfor i, priority in enumerate(priorities):\n    agent_id = budget_coordinator.register_agent(\n        agent_id=f\"agent_{i}\",\n        pool_id=pool_id,\n        priority=priority.value,\n        initial_budget=Decimal(\"50.0\")\n    )\n    agent_ids.append(agent_id)\n\n# Configure reallocation rules\nreallocator.configure(\n    min_budget_percentage=0.1,  # Ensure all agents have at least 10% of their initial budget\n    reserve_percentage=0.2,  # Keep 20% in reserve for emergency allocations\n    priority_weights={\n        AgentPriority.CRITICAL.value: 4.0,\n        AgentPriority.HIGH.value: 2.0,\n        AgentPriority.MEDIUM.value: 1.0,\n        AgentPriority.LOW.value: 0.5\n    }\n)\n\n# Start the reallocator\nreallocator.start()\n</code></pre>"},{"location":"advanced/dynamic_budget/#time-based-budget-control","title":"Time-Based Budget Control","text":""},{"location":"advanced/dynamic_budget/#budget-rate-limiting","title":"Budget Rate Limiting","text":"<p>Implement rate limits for budget consumption:</p> <pre><code>from safeguards.budget.rate_limiter import BudgetRateLimiter\nfrom datetime import timedelta\nfrom decimal import Decimal\n\n# Create a budget rate limiter\nrate_limiter = BudgetRateLimiter(budget_coordinator)\n\n# Configure rate limits for different agents\nrate_limiter.set_rate_limit(\n    agent_id=\"agent_0\",  # Critical agent\n    max_budget=Decimal(\"100.0\"),\n    time_window=timedelta(hours=1)\n)\n\nrate_limiter.set_rate_limit(\n    agent_id=\"agent_1\",  # High priority agent\n    max_budget=Decimal(\"50.0\"),\n    time_window=timedelta(hours=1)\n)\n\nrate_limiter.set_rate_limit(\n    agent_id=\"agent_2\",  # Medium priority agent\n    max_budget=Decimal(\"25.0\"),\n    time_window=timedelta(hours=1)\n)\n\nrate_limiter.set_rate_limit(\n    agent_id=\"agent_3\",  # Low priority agent\n    max_budget=Decimal(\"10.0\"),\n    time_window=timedelta(hours=1)\n)\n\n# Check if an operation is within rate limits\ndef execute_agent_operation(agent_id, operation_cost):\n    \"\"\"Execute an agent operation with rate limiting.\"\"\"\n    if rate_limiter.check_rate_limit(agent_id, operation_cost):\n        # Perform operation\n        rate_limiter.record_usage(agent_id, operation_cost)\n        return {\"status\": \"success\", \"cost\": operation_cost}\n    else:\n        # Rate limit exceeded\n        return {\n            \"status\": \"error\",\n            \"message\": \"Rate limit exceeded\",\n            \"retry_after_seconds\": rate_limiter.get_retry_after(agent_id)\n        }\n</code></pre>"},{"location":"advanced/dynamic_budget/#time-of-day-budgeting","title":"Time-of-Day Budgeting","text":"<p>Adjust budgets based on time of day:</p> <pre><code>from safeguards.budget.time_scheduler import BudgetTimeScheduler\nfrom datetime import time, datetime, timedelta\nfrom decimal import Decimal\n\n# Create a time-based budget scheduler\nscheduler = BudgetTimeScheduler(budget_coordinator)\n\n# Configure time-based budget profiles for a pool\nscheduler.add_time_profile(\n    pool_id=pool_id,\n    schedule={\n        # Business hours (9 AM - 5 PM): High budget\n        \"business_hours\": {\n            \"budget\": Decimal(\"5000.0\"),\n            \"start_time\": time(9, 0),  # 9:00 AM\n            \"end_time\": time(17, 0),   # 5:00 PM\n            \"days\": [0, 1, 2, 3, 4]    # Monday to Friday\n        },\n        # Evening hours (5 PM - 10 PM): Medium budget\n        \"evening_hours\": {\n            \"budget\": Decimal(\"2000.0\"),\n            \"start_time\": time(17, 0),  # 5:00 PM\n            \"end_time\": time(22, 0),    # 10:00 PM\n            \"days\": [0, 1, 2, 3, 4]     # Monday to Friday\n        },\n        # Night hours (10 PM - 9 AM): Low budget\n        \"night_hours\": {\n            \"budget\": Decimal(\"500.0\"),\n            \"start_time\": time(22, 0),  # 10:00 PM\n            \"end_time\": time(9, 0),     # 9:00 AM\n            \"days\": [0, 1, 2, 3, 4]     # Monday to Friday\n        },\n        # Weekend: Medium budget all day\n        \"weekend\": {\n            \"budget\": Decimal(\"1000.0\"),\n            \"start_time\": time(0, 0),   # 12:00 AM\n            \"end_time\": time(23, 59),   # 11:59 PM\n            \"days\": [5, 6]              # Saturday and Sunday\n        }\n    }\n)\n\n# Apply the current time-based profile\nscheduler.apply_current_profile(pool_id)\n\n# Start the scheduler\nscheduler.start()\n</code></pre>"},{"location":"advanced/dynamic_budget/#budget-learning-optimization","title":"Budget Learning &amp; Optimization","text":""},{"location":"advanced/dynamic_budget/#usage-pattern-learning","title":"Usage Pattern Learning","text":"<p>Learn from agent usage patterns to optimize budgets:</p> <pre><code>from safeguards.budget.pattern_learner import BudgetPatternLearner\nfrom datetime import datetime, timedelta\nimport numpy as np\n\n# Create a budget pattern learner\nlearner = BudgetPatternLearner(\n    budget_coordinator=budget_coordinator,\n    learning_period_days=14,  # Learn from 2 weeks of data\n    prediction_confidence=0.8,  # Require 80% confidence for predictions\n    min_data_points=100  # Require at least 100 data points\n)\n\n# Start collecting usage data\nlearner.start_collection()\n\n# After collecting data, analyze patterns\npatterns = learner.analyze_patterns(\n    agent_id=\"agent_0\",\n    time_bucket_minutes=60  # Analyze in 1-hour buckets\n)\n\n# Predict future budget needs\nprediction = learner.predict_budget_needs(\n    agent_id=\"agent_0\",\n    future_time=datetime.now() + timedelta(hours=24),  # Predict for tomorrow\n    prediction_window_hours=24  # Predict for 24 hours\n)\n\n# Apply optimized budgets based on predictions\ndef apply_optimized_budgets():\n    \"\"\"Apply optimized budgets based on learned patterns.\"\"\"\n    for agent_id in agent_ids:\n        next_day_prediction = learner.predict_budget_needs(\n            agent_id=agent_id,\n            future_time=datetime.now() + timedelta(hours=24),\n            prediction_window_hours=24\n        )\n\n        if next_day_prediction and next_day_prediction.confidence &gt;= 0.8:\n            # Apply prediction with a 20% safety margin\n            optimized_budget = next_day_prediction.predicted_budget * Decimal(\"1.2\")\n\n            # Update agent budget\n            budget_coordinator.update_budget(\n                agent_id=agent_id,\n                budget=optimized_budget\n            )\n\n            print(f\"Applied optimized budget of {optimized_budget} to {agent_id}\")\n</code></pre>"},{"location":"advanced/dynamic_budget/#reinforcement-learning-for-budget-allocation","title":"Reinforcement Learning for Budget Allocation","text":"<p>Use reinforcement learning to optimize budget allocation:</p> <pre><code>from safeguards.budget.rl_optimizer import BudgetRLOptimizer\nfrom safeguards.types.metrics import BudgetMetrics\n\n# Create a reinforcement learning budget optimizer\nrl_optimizer = BudgetRLOptimizer(\n    budget_coordinator=budget_coordinator,\n    learning_rate=0.01,\n    discount_factor=0.9,\n    exploration_rate=0.1,\n    state_features=[\n        \"time_of_day\",\n        \"day_of_week\",\n        \"agent_priority\",\n        \"recent_usage\",\n        \"remaining_budget_percentage\"\n    ]\n)\n\n# Define reward function\ndef reward_function(state, action, next_state):\n    \"\"\"Calculate reward for budget allocation actions.\"\"\"\n    # Reward for high utilization without exhaustion\n    utilization = next_state.get(\"utilization\", 0)\n\n    # Penalize budget exhaustion\n    exhaustion_penalty = -100 if next_state.get(\"exhausted\", False) else 0\n\n    # Reward for completing tasks\n    task_reward = next_state.get(\"completed_tasks\", 0) * 10\n\n    # Penalize large budget changes\n    stability_penalty = -abs(action.get(\"budget_change\", 0)) * 0.1\n\n    return utilization * 50 + exhaustion_penalty + task_reward + stability_penalty\n\n# Configure the optimizer\nrl_optimizer.configure(\n    reward_function=reward_function,\n    training_episodes=1000,\n    max_budget_change_percentage=0.3,  # Limit changes to 30%\n    update_interval_minutes=60  # Update every hour\n)\n\n# Start the optimizer\nrl_optimizer.start()\n\n# Get budget allocation policy\nallocation_policy = rl_optimizer.get_policy()\nprint(f\"Learned allocation policy: {allocation_policy}\")\n</code></pre>"},{"location":"advanced/dynamic_budget/#multi-dimensional-budgeting","title":"Multi-Dimensional Budgeting","text":""},{"location":"advanced/dynamic_budget/#resource-type-budgeting","title":"Resource Type Budgeting","text":"<p>Manage multiple resource types independently:</p> <pre><code>from safeguards.budget.multi_resource import MultiResourceBudget\nfrom decimal import Decimal\n\n# Create a multi-resource budget manager\nmulti_resource = MultiResourceBudget(budget_coordinator)\n\n# Define resource types\nresource_types = [\n    \"api_calls\",\n    \"compute_seconds\",\n    \"storage_gb\",\n    \"bandwidth_gb\"\n]\n\n# Initialize multi-resource budgets for an agent\nagent_id = \"agent_0\"\nmulti_resource.initialize_budgets(\n    agent_id=agent_id,\n    budgets={\n        \"api_calls\": Decimal(\"1000\"),\n        \"compute_seconds\": Decimal(\"3600\"),  # 1 hour\n        \"storage_gb\": Decimal(\"10\"),\n        \"bandwidth_gb\": Decimal(\"20\")\n    }\n)\n\n# Check if operation is within budget\ndef check_multi_resource_budget(agent_id, resources_needed):\n    \"\"\"Check if an operation is within multi-resource budget limits.\"\"\"\n    for resource_type, amount in resources_needed.items():\n        if not multi_resource.has_sufficient_budget(\n            agent_id=agent_id,\n            resource_type=resource_type,\n            amount=amount\n        ):\n            return False, f\"Insufficient {resource_type} budget\"\n\n    return True, \"Operation within budget\"\n\n# Update multiple resource budgets after an operation\ndef update_multi_resource_budget(agent_id, resources_used):\n    \"\"\"Update multiple resource budgets after an operation.\"\"\"\n    for resource_type, amount in resources_used.items():\n        current = multi_resource.get_budget(agent_id, resource_type)\n        multi_resource.update_budget(\n            agent_id=agent_id,\n            resource_type=resource_type,\n            budget=current - amount\n        )\n\n    # Get updated budgets\n    updated_budgets = {\n        rt: multi_resource.get_budget(agent_id, rt)\n        for rt in resource_types\n    }\n\n    return updated_budgets\n</code></pre>"},{"location":"advanced/dynamic_budget/#cost-benefit-budgeting","title":"Cost-Benefit Budgeting","text":"<p>Allocate budgets based on expected return on investment:</p> <pre><code>from safeguards.budget.cost_benefit import CostBenefitAllocator\nfrom decimal import Decimal\n\n# Create a cost-benefit allocator\ncb_allocator = CostBenefitAllocator(budget_coordinator)\n\n# Register benefit metrics for different agent operations\ncb_allocator.register_operation(\n    agent_id=\"agent_0\",\n    operation_type=\"data_processing\",\n    average_cost=Decimal(\"5.0\"),\n    average_benefit=Decimal(\"15.0\"),  # 3x ROI\n    benefit_variability=0.2  # 20% variability\n)\n\ncb_allocator.register_operation(\n    agent_id=\"agent_0\",\n    operation_type=\"content_generation\",\n    average_cost=Decimal(\"10.0\"),\n    average_benefit=Decimal(\"25.0\"),  # 2.5x ROI\n    benefit_variability=0.4  # 40% variability\n)\n\ncb_allocator.register_operation(\n    agent_id=\"agent_1\",\n    operation_type=\"data_analysis\",\n    average_cost=Decimal(\"20.0\"),\n    average_benefit=Decimal(\"50.0\"),  # 2.5x ROI\n    benefit_variability=0.3  # 30% variability\n)\n\n# Optimize budget allocation to maximize benefit\noptimized_allocation = cb_allocator.optimize_allocation(\n    total_budget=Decimal(\"1000.0\"),\n    min_allocation_percentage=0.1,  # At least 10% for each agent\n    risk_tolerance=0.5  # Balanced risk approach\n)\n\n# Apply optimized allocation\nfor agent_id, allocation in optimized_allocation.items():\n    budget_coordinator.update_budget(\n        agent_id=agent_id,\n        budget=allocation\n    )\n    print(f\"Allocated {allocation} to {agent_id} based on cost-benefit analysis\")\n\n# Evaluate allocation effectiveness\neffectiveness = cb_allocator.evaluate_effectiveness(\n    lookback_days=7,  # Evaluate last week's performance\n    metric=\"roi\"  # Return on investment\n)\n\nprint(f\"Allocation effectiveness: {effectiveness}\")\n</code></pre>"},{"location":"advanced/dynamic_budget/#budget-federation-across-systems","title":"Budget Federation Across Systems","text":""},{"location":"advanced/dynamic_budget/#cross-system-budget-coordination","title":"Cross-System Budget Coordination","text":"<p>Coordinate budgets across multiple systems:</p> <pre><code>from safeguards.budget.federation import BudgetFederation\nimport requests\nfrom decimal import Decimal\n\n# Create a budget federation coordinator\nfederation = BudgetFederation(\n    local_system_id=\"system_a\",\n    local_coordinator=budget_coordinator\n)\n\n# Register remote systems\nfederation.register_remote_system(\n    system_id=\"system_b\",\n    api_base_url=\"https://system-b.example.com/api/\",\n    api_key=\"system_b_api_key\",\n    trust_level=0.8  # High trust level\n)\n\nfederation.register_remote_system(\n    system_id=\"system_c\",\n    api_base_url=\"https://system-c.example.com/api/\",\n    api_key=\"system_c_api_key\",\n    trust_level=0.6  # Medium trust level\n)\n\n# Create a federated budget pool\nfederated_pool_id = federation.create_federated_pool(\n    name=\"cross_system_pool\",\n    local_budget=Decimal(\"5000.0\"),\n    remote_allocations={\n        \"system_b\": Decimal(\"2000.0\"),\n        \"system_c\": Decimal(\"1000.0\")\n    }\n)\n\n# Request budget from remote system\ndef request_remote_budget(agent_id, amount, remote_system_id):\n    \"\"\"Request budget from a remote system.\"\"\"\n    success, details = federation.request_remote_budget(\n        agent_id=agent_id,\n        remote_system_id=remote_system_id,\n        amount=amount,\n        request_metadata={\n            \"purpose\": \"critical_operation\",\n            \"expected_duration_minutes\": 30\n        }\n    )\n\n    if success:\n        print(f\"Received {amount} from {remote_system_id} for {agent_id}\")\n        print(f\"Transaction ID: {details.get('transaction_id')}\")\n        return True\n    else:\n        print(f\"Failed to get budget from {remote_system_id}: {details.get('error')}\")\n        return False\n\n# Synchronize budgets across systems\ndef synchronize_federation():\n    \"\"\"Synchronize budget information across federated systems.\"\"\"\n    sync_results = federation.synchronize()\n\n    for system_id, result in sync_results.items():\n        if result[\"success\"]:\n            print(f\"Synchronized with {system_id}, last update: {result['last_sync']}\")\n        else:\n            print(f\"Failed to sync with {system_id}: {result['error']}\")\n</code></pre>"},{"location":"advanced/dynamic_budget/#best-practices","title":"Best Practices","text":""},{"location":"advanced/dynamic_budget/#design-principles","title":"Design Principles","text":"<ol> <li>Start Conservative: Begin with static allocations before implementing dynamic strategies</li> <li>Monitor Before Optimizing: Collect usage data before implementing automatic adjustments</li> <li>Implement Safety Guardrails: Add safeguards to prevent extreme budget changes</li> <li>Consider Time Horizons: Balance short-term optimization with long-term sustainability</li> <li>Test Extreme Scenarios: Verify behavior during unexpected spikes or drops in usage</li> </ol>"},{"location":"advanced/dynamic_budget/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Gradual Changes: Make small, incremental budget adjustments rather than large swings</li> <li>Feedback Loops: Collect performance metrics to evaluate allocation effectiveness</li> <li>Human Oversight: Allow manual intervention for unexpected situations</li> <li>Transparency: Make the reasoning behind budget decisions explainable</li> <li>Fallback Mechanisms: Implement simple fallback rules if advanced strategies fail</li> </ol>"},{"location":"advanced/dynamic_budget/#conclusion","title":"Conclusion","text":"<p>Dynamic budget allocation enables your agent system to adapt to changing conditions, optimize resource usage, and make intelligent decisions about resource allocation. By implementing these advanced strategies, you can create self-tuning systems that maximize value while maintaining safety constraints.</p> <p>For more information, see: - Budget Management Basics - Agent Coordination - Monitoring Guide</p>"},{"location":"advanced/multi_agent/","title":"Advanced Multi-Agent Coordination","text":"<p>This document covers advanced techniques for coordinating multiple agents within the Safeguards, focusing on complex coordination patterns, dynamic task allocation, and conflict resolution.</p>"},{"location":"advanced/multi_agent/#advanced-coordination-patterns","title":"Advanced Coordination Patterns","text":""},{"location":"advanced/multi_agent/#hierarchical-agent-organization","title":"Hierarchical Agent Organization","text":"<p>Implement a hierarchical agent structure for complex tasks:</p> <pre><code>from safeguards.types.agent import Agent\nfrom typing import Dict, Any, List\nfrom decimal import Decimal\n\nclass ManagerAgent(Agent):\n    \"\"\"Manager agent that coordinates worker agents.\"\"\"\n    def __init__(self, name: str, worker_agents: List[Agent] = None):\n        super().__init__(name)\n        self.worker_agents = worker_agents or []\n        self.task_assignments = {}\n\n    def add_worker(self, worker: Agent) -&gt; None:\n        \"\"\"Add a worker agent to be managed.\"\"\"\n        self.worker_agents.append(worker)\n\n    def assign_tasks(self, tasks: List[Dict[str, Any]]) -&gt; Dict[str, List[str]]:\n        \"\"\"Assign tasks to worker agents based on capabilities.\"\"\"\n        assignments = {}\n\n        # Example task assignment logic - customize based on your needs\n        for i, task in enumerate(tasks):\n            if i &lt; len(self.worker_agents):\n                worker = self.worker_agents[i]\n                if worker.id not in assignments:\n                    assignments[worker.id] = []\n                assignments[worker.id].append(task[\"task_id\"])\n                self.task_assignments[task[\"task_id\"]] = worker.id\n\n        return assignments\n\n    def run(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"Coordinate worker agents to complete a complex task.\"\"\"\n        tasks = kwargs.get(\"tasks\", [])\n        context = kwargs.get(\"context\", {})\n\n        # Step 1: Assign tasks to workers\n        assignments = self.assign_tasks(tasks)\n\n        # Step 2: Execute tasks and collect results\n        results = {}\n        for worker in self.worker_agents:\n            worker_tasks = assignments.get(worker.id, [])\n            if worker_tasks:\n                # Get the full task definitions for this worker\n                worker_task_defs = [t for t in tasks if t[\"task_id\"] in worker_tasks]\n\n                # Execute worker tasks\n                worker_result = worker.run(\n                    tasks=worker_task_defs,\n                    context={**context, \"manager_id\": self.id}\n                )\n\n                # Store results\n                results[worker.id] = worker_result\n\n        # Step 3: Aggregate and process results\n        aggregated_result = self._aggregate_results(results)\n\n        return {\n            \"status\": \"completed\",\n            \"worker_results\": results,\n            \"aggregated_result\": aggregated_result,\n            \"task_count\": len(tasks)\n        }\n\n    def _aggregate_results(self, results: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Aggregate results from worker agents.\"\"\"\n        # Implement your specific aggregation logic\n        combined_output = {}\n        for worker_id, result in results.items():\n            for key, value in result.items():\n                if key not in combined_output:\n                    combined_output[key] = []\n                if isinstance(value, list):\n                    combined_output[key].extend(value)\n                else:\n                    combined_output[key].append(value)\n\n        return combined_output\n</code></pre>"},{"location":"advanced/multi_agent/#federated-decision-making","title":"Federated Decision Making","text":"<p>Implement consensus-based decision making across agents:</p> <pre><code>from typing import List, Dict, Any, Callable\nfrom enum import Enum\n\nclass ConsensusMethod(Enum):\n    MAJORITY_VOTE = \"majority_vote\"\n    WEIGHTED_VOTE = \"weighted_vote\"\n    UNANIMOUS = \"unanimous\"\n\nclass FederatedDecisionSystem:\n    \"\"\"Manages decision making across multiple agents.\"\"\"\n\n    def __init__(self, consensus_method: ConsensusMethod = ConsensusMethod.MAJORITY_VOTE):\n        self.consensus_method = consensus_method\n        self.agents = {}  # agent_id -&gt; agent object\n        self.weights = {}  # agent_id -&gt; weight (for weighted voting)\n\n    def register_agent(self, agent_id: str, agent: Any, weight: float = 1.0) -&gt; None:\n        \"\"\"Register an agent with the federated system.\"\"\"\n        self.agents[agent_id] = agent\n        self.weights[agent_id] = weight\n\n    def make_decision(self, question: str, options: List[Any],\n                      decision_fn: Callable = None) -&gt; Dict[str, Any]:\n        \"\"\"Make a decision across all registered agents.\"\"\"\n        # Collect votes from each agent\n        votes = {}\n        for agent_id, agent in self.agents.items():\n            if decision_fn:\n                # Use custom decision function\n                vote = decision_fn(agent, question, options)\n            else:\n                # Default: let agent run with question and options\n                result = agent.run(\n                    question=question,\n                    options=options\n                )\n                vote = result.get(\"selected_option\")\n\n            votes[agent_id] = vote\n\n        # Apply consensus method\n        if self.consensus_method == ConsensusMethod.MAJORITY_VOTE:\n            decision = self._apply_majority_vote(votes, options)\n        elif self.consensus_method == ConsensusMethod.WEIGHTED_VOTE:\n            decision = self._apply_weighted_vote(votes, options)\n        elif self.consensus_method == ConsensusMethod.UNANIMOUS:\n            decision = self._apply_unanimous(votes, options)\n        else:\n            raise ValueError(f\"Unknown consensus method: {self.consensus_method}\")\n\n        return {\n            \"decision\": decision,\n            \"votes\": votes,\n            \"consensus_method\": self.consensus_method.value,\n            \"question\": question\n        }\n\n    def _apply_majority_vote(self, votes: Dict[str, Any], options: List[Any]) -&gt; Any:\n        \"\"\"Apply simple majority voting.\"\"\"\n        # Count votes for each option\n        vote_counts = {option: 0 for option in options}\n        for vote in votes.values():\n            if vote in vote_counts:\n                vote_counts[vote] += 1\n\n        # Find option with most votes\n        return max(vote_counts.items(), key=lambda x: x[1])[0]\n\n    def _apply_weighted_vote(self, votes: Dict[str, Any], options: List[Any]) -&gt; Any:\n        \"\"\"Apply weighted voting.\"\"\"\n        # Count weighted votes for each option\n        weighted_votes = {option: 0 for option in options}\n        for agent_id, vote in votes.items():\n            if vote in weighted_votes:\n                weight = self.weights.get(agent_id, 1.0)\n                weighted_votes[vote] += weight\n\n        # Find option with highest weighted votes\n        return max(weighted_votes.items(), key=lambda x: x[1])[0]\n\n    def _apply_unanimous(self, votes: Dict[str, Any], options: List[Any]) -&gt; Any:\n        \"\"\"Check for unanimous agreement.\"\"\"\n        # Get unique votes\n        unique_votes = set(votes.values())\n\n        # If all agents voted for the same option, return it\n        if len(unique_votes) == 1:\n            return next(iter(unique_votes))\n\n        # Otherwise, no consensus\n        return None\n</code></pre>"},{"location":"advanced/multi_agent/#dynamic-task-allocation","title":"Dynamic Task Allocation","text":""},{"location":"advanced/multi_agent/#workload-based-allocation","title":"Workload-Based Allocation","text":"<p>Dynamically allocate tasks based on agent workload:</p> <pre><code>from typing import Dict, List, Any\nfrom decimal import Decimal\nimport heapq\n\nclass WorkloadBalancer:\n    \"\"\"Balances workload across multiple agents.\"\"\"\n\n    def __init__(self):\n        self.agent_workloads = {}  # agent_id -&gt; current workload\n        self.agent_capacities = {}  # agent_id -&gt; maximum capacity\n        self.task_assignments = {}  # task_id -&gt; agent_id\n\n    def register_agent(self, agent_id: str, max_capacity: float) -&gt; None:\n        \"\"\"Register an agent with the workload balancer.\"\"\"\n        self.agent_workloads[agent_id] = 0\n        self.agent_capacities[agent_id] = max_capacity\n\n    def assign_task(self, task_id: str, estimated_load: float) -&gt; str:\n        \"\"\"Assign a task to the agent with the lowest workload.\"\"\"\n        if not self.agent_workloads:\n            raise ValueError(\"No agents registered with the workload balancer\")\n\n        # Find agent with lowest workload percentage\n        best_agent_id = None\n        lowest_workload_pct = float('inf')\n\n        for agent_id, current_load in self.agent_workloads.items():\n            capacity = self.agent_capacities[agent_id]\n            workload_pct = current_load / capacity if capacity &gt; 0 else float('inf')\n\n            if workload_pct &lt; lowest_workload_pct:\n                lowest_workload_pct = workload_pct\n                best_agent_id = agent_id\n\n        # Update workload and store assignment\n        if best_agent_id:\n            self.agent_workloads[best_agent_id] += estimated_load\n            self.task_assignments[task_id] = best_agent_id\n\n        return best_agent_id\n\n    def complete_task(self, task_id: str, actual_load: float = None) -&gt; None:\n        \"\"\"Mark a task as completed and update workload.\"\"\"\n        agent_id = self.task_assignments.get(task_id)\n        if agent_id:\n            # If actual load not provided, use the estimated load (workload difference)\n            if actual_load is None:\n                # Find how much this task contributed\n                task_load = 0\n                for tid, aid in self.task_assignments.items():\n                    if tid == task_id and aid == agent_id:\n                        task_load = self.agent_workloads[agent_id] / len(\n                            [t for t, a in self.task_assignments.items() if a == agent_id]\n                        )\n                        break\n                actual_load = task_load\n\n            # Update workload\n            self.agent_workloads[agent_id] = max(0, self.agent_workloads[agent_id] - actual_load)\n            # Remove assignment\n            self.task_assignments.pop(task_id, None)\n\n    def get_agent_utilization(self) -&gt; Dict[str, float]:\n        \"\"\"Get current utilization percentage for each agent.\"\"\"\n        utilization = {}\n        for agent_id, load in self.agent_workloads.items():\n            capacity = self.agent_capacities[agent_id]\n            utilization[agent_id] = (load / capacity * 100) if capacity &gt; 0 else 0\n        return utilization\n\n    def rebalance(self) -&gt; Dict[str, str]:\n        \"\"\"Rebalance tasks across agents.\"\"\"\n        # Get all current tasks\n        tasks = list(self.task_assignments.items())\n\n        # Reset workloads\n        for agent_id in self.agent_workloads:\n            self.agent_workloads[agent_id] = 0\n\n        # Clear assignments\n        self.task_assignments = {}\n\n        # Reassign tasks\n        new_assignments = {}\n        for task_id, _ in tasks:\n            # Assign based on current workload\n            new_agent = self.assign_task(task_id, 1.0)  # Simplified load of 1.0 for rebalancing\n            new_assignments[task_id] = new_agent\n\n        return new_assignments\n</code></pre>"},{"location":"advanced/multi_agent/#skill-based-routing","title":"Skill-Based Routing","text":"<p>Route tasks to agents based on their capabilities:</p> <pre><code>from typing import Dict, List, Set, Any\n\nclass AgentSkillRouter:\n    \"\"\"Routes tasks to agents based on their skills.\"\"\"\n\n    def __init__(self):\n        self.agent_skills = {}  # agent_id -&gt; set of skills\n        self.skill_agents = {}  # skill -&gt; list of agent_ids\n\n    def register_agent(self, agent_id: str, skills: List[str]) -&gt; None:\n        \"\"\"Register an agent with specified skills.\"\"\"\n        skill_set = set(skills)\n        self.agent_skills[agent_id] = skill_set\n\n        # Update skill -&gt; agents mapping\n        for skill in skill_set:\n            if skill not in self.skill_agents:\n                self.skill_agents[skill] = []\n            self.skill_agents[skill].append(agent_id)\n\n    def find_agents_with_skill(self, skill: str) -&gt; List[str]:\n        \"\"\"Find all agents with a specific skill.\"\"\"\n        return self.skill_agents.get(skill, [])\n\n    def find_agents_with_all_skills(self, required_skills: List[str]) -&gt; List[str]:\n        \"\"\"Find agents that have all the required skills.\"\"\"\n        if not required_skills:\n            return list(self.agent_skills.keys())\n\n        skill_set = set(required_skills)\n        qualified_agents = []\n\n        for agent_id, agent_skill_set in self.agent_skills.items():\n            if skill_set.issubset(agent_skill_set):\n                qualified_agents.append(agent_id)\n\n        return qualified_agents\n\n    def route_task(self, task_id: str, required_skills: List[str],\n                   load_balancer = None) -&gt; str:\n        \"\"\"Route a task to the best agent based on skills and optionally load.\"\"\"\n        qualified_agents = self.find_agents_with_all_skills(required_skills)\n\n        if not qualified_agents:\n            return None\n\n        if load_balancer:\n            # Use load balancer to pick among qualified agents\n            best_agent = None\n            lowest_load = float('inf')\n\n            for agent_id in qualified_agents:\n                agent_load = load_balancer.agent_workloads.get(agent_id, 0)\n                if agent_load &lt; lowest_load:\n                    lowest_load = agent_load\n                    best_agent = agent_id\n\n            if best_agent:\n                # Update load balancer\n                load_balancer.assign_task(task_id, 1.0)  # Simplified load of 1.0\n                return best_agent\n\n        # No load balancing - just return first qualified agent\n        return qualified_agents[0]\n</code></pre>"},{"location":"advanced/multi_agent/#conflict-resolution","title":"Conflict Resolution","text":""},{"location":"advanced/multi_agent/#resource-contention","title":"Resource Contention","text":"<p>Resolve conflicts when multiple agents need the same resources:</p> <pre><code>from enum import Enum\nfrom typing import Dict, List, Any\nimport time\nfrom threading import Lock\n\nclass ResourceType(Enum):\n    COMPUTE = \"compute\"\n    MEMORY = \"memory\"\n    STORAGE = \"storage\"\n    API_CALL = \"api_call\"\n    DATA = \"data\"\n\nclass ResourceContention:\n    \"\"\"Manages and resolves resource contentions between agents.\"\"\"\n\n    def __init__(self):\n        self.resources = {}  # resource_id -&gt; ResourceInfo\n        self.locks = {}  # resource_id -&gt; Lock\n        self.reservations = {}  # resource_id -&gt; {agent_id: priority}\n\n    def register_resource(self, resource_id: str, resource_type: ResourceType,\n                          capacity: float) -&gt; None:\n        \"\"\"Register a resource with the contention manager.\"\"\"\n        self.resources[resource_id] = {\n            \"type\": resource_type,\n            \"capacity\": capacity,\n            \"allocated\": 0.0,\n            \"allocations\": {}  # agent_id -&gt; amount\n        }\n        self.locks[resource_id] = Lock()\n\n    def request_allocation(self, agent_id: str, resource_id: str,\n                          amount: float, priority: int = 5) -&gt; bool:\n        \"\"\"Request allocation of a resource amount to an agent.\"\"\"\n        if resource_id not in self.resources:\n            raise ValueError(f\"Unknown resource: {resource_id}\")\n\n        resource = self.resources[resource_id]\n\n        with self.locks[resource_id]:\n            # Check if there's enough capacity\n            if resource[\"allocated\"] + amount &lt;= resource[\"capacity\"]:\n                # Allocate resource\n                if agent_id not in resource[\"allocations\"]:\n                    resource[\"allocations\"][agent_id] = 0\n\n                resource[\"allocations\"][agent_id] += amount\n                resource[\"allocated\"] += amount\n                return True\n\n            # Not enough capacity, add to reservations for future allocation\n            if resource_id not in self.reservations:\n                self.reservations[resource_id] = {}\n\n            self.reservations[resource_id][agent_id] = priority\n            return False\n\n    def release_allocation(self, agent_id: str, resource_id: str,\n                          amount: float = None) -&gt; float:\n        \"\"\"Release allocated resources from an agent.\"\"\"\n        if resource_id not in self.resources:\n            raise ValueError(f\"Unknown resource: {resource_id}\")\n\n        resource = self.resources[resource_id]\n\n        with self.locks[resource_id]:\n            if agent_id not in resource[\"allocations\"]:\n                return 0.0\n\n            # Determine how much to release\n            current_allocation = resource[\"allocations\"][agent_id]\n            release_amount = amount if amount is not None else current_allocation\n            release_amount = min(release_amount, current_allocation)\n\n            # Update allocations\n            resource[\"allocations\"][agent_id] -= release_amount\n            resource[\"allocated\"] -= release_amount\n\n            # Clean up if allocation is zero\n            if resource[\"allocations\"][agent_id] &lt;= 0:\n                resource[\"allocations\"].pop(agent_id)\n\n            # Process waiting reservations\n            self._process_reservations(resource_id)\n\n            return release_amount\n\n    def _process_reservations(self, resource_id: str) -&gt; None:\n        \"\"\"Process waiting reservations based on priority.\"\"\"\n        if resource_id not in self.reservations:\n            return\n\n        resource = self.resources[resource_id]\n        reservations = self.reservations[resource_id]\n\n        # Sort agents by priority (highest first)\n        sorted_agents = sorted(\n            reservations.items(),\n            key=lambda x: x[1],\n            reverse=True\n        )\n\n        # Try to allocate to each agent in priority order\n        remaining_capacity = resource[\"capacity\"] - resource[\"allocated\"]\n        updated_reservations = {}\n\n        for agent_id, priority in sorted_agents:\n            # Assume each reservation is for 1.0 unit (simplified)\n            if remaining_capacity &gt;= 1.0:\n                # Allocate resource\n                if agent_id not in resource[\"allocations\"]:\n                    resource[\"allocations\"][agent_id] = 0\n\n                resource[\"allocations\"][agent_id] += 1.0\n                resource[\"allocated\"] += 1.0\n                remaining_capacity -= 1.0\n            else:\n                # Keep in reservations\n                updated_reservations[agent_id] = priority\n\n        # Update reservations\n        if updated_reservations:\n            self.reservations[resource_id] = updated_reservations\n        else:\n            # No more reservations\n            self.reservations.pop(resource_id, None)\n</code></pre>"},{"location":"advanced/multi_agent/#task-priority-arbitration","title":"Task Priority Arbitration","text":"<p>Resolve conflicts between tasks with competing priorities:</p> <pre><code>from enum import Enum\nfrom typing import Dict, List, Any, Tuple\nimport time\nimport heapq\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    PAUSED = \"paused\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\nclass TaskArbitrator:\n    \"\"\"Arbitrates between competing tasks based on priority.\"\"\"\n\n    def __init__(self, max_concurrent_tasks: int = 5):\n        self.tasks = {}  # task_id -&gt; task info\n        self.running_tasks = set()  # set of running task_ids\n        self.max_concurrent_tasks = max_concurrent_tasks\n\n    def register_task(self, task_id: str, agent_id: str, priority: int,\n                     estimated_duration: float = None) -&gt; None:\n        \"\"\"Register a task with the arbitrator.\"\"\"\n        self.tasks[task_id] = {\n            \"agent_id\": agent_id,\n            \"priority\": priority,\n            \"status\": TaskStatus.PENDING,\n            \"created_at\": time.time(),\n            \"started_at\": None,\n            \"completed_at\": None,\n            \"estimated_duration\": estimated_duration,\n            \"dependencies\": []\n        }\n\n    def add_dependency(self, task_id: str, depends_on: str) -&gt; None:\n        \"\"\"Add a dependency between tasks.\"\"\"\n        if task_id not in self.tasks or depends_on not in self.tasks:\n            raise ValueError(f\"Unknown task: {task_id} or {depends_on}\")\n\n        self.tasks[task_id][\"dependencies\"].append(depends_on)\n\n    def start_task(self, task_id: str) -&gt; bool:\n        \"\"\"Try to start a task, respecting priority and concurrency limits.\"\"\"\n        if task_id not in self.tasks:\n            raise ValueError(f\"Unknown task: {task_id}\")\n\n        task = self.tasks[task_id]\n\n        # Check if already running\n        if task[\"status\"] == TaskStatus.RUNNING:\n            return True\n\n        # Check if task can be started\n        if not self._can_start_task(task_id):\n            return False\n\n        # Check concurrency limit\n        if len(self.running_tasks) &gt;= self.max_concurrent_tasks:\n            # Need to decide if we should preempt a running task\n            lowest_priority_task = self._find_lowest_priority_running_task()\n\n            if lowest_priority_task and self.tasks[lowest_priority_task][\"priority\"] &lt; task[\"priority\"]:\n                # Preempt the lowest priority task\n                self.pause_task(lowest_priority_task)\n            else:\n                # Can't start new task now\n                return False\n\n        # Start the task\n        task[\"status\"] = TaskStatus.RUNNING\n        task[\"started_at\"] = time.time()\n        self.running_tasks.add(task_id)\n        return True\n\n    def pause_task(self, task_id: str) -&gt; bool:\n        \"\"\"Pause a running task.\"\"\"\n        if task_id not in self.tasks:\n            raise ValueError(f\"Unknown task: {task_id}\")\n\n        task = self.tasks[task_id]\n\n        if task[\"status\"] != TaskStatus.RUNNING:\n            return False\n\n        task[\"status\"] = TaskStatus.PAUSED\n        self.running_tasks.remove(task_id)\n        return True\n\n    def complete_task(self, task_id: str, success: bool = True) -&gt; None:\n        \"\"\"Mark a task as completed or failed.\"\"\"\n        if task_id not in self.tasks:\n            raise ValueError(f\"Unknown task: {task_id}\")\n\n        task = self.tasks[task_id]\n        task[\"completed_at\"] = time.time()\n\n        if success:\n            task[\"status\"] = TaskStatus.COMPLETED\n        else:\n            task[\"status\"] = TaskStatus.FAILED\n\n        if task_id in self.running_tasks:\n            self.running_tasks.remove(task_id)\n\n        # Check if we can start any pending tasks\n        self._start_pending_tasks()\n\n    def _can_start_task(self, task_id: str) -&gt; bool:\n        \"\"\"Check if a task's dependencies are satisfied.\"\"\"\n        task = self.tasks[task_id]\n\n        # Check if task is already completed or failed\n        if task[\"status\"] in [TaskStatus.COMPLETED, TaskStatus.FAILED]:\n            return False\n\n        # Check dependencies\n        for dep_id in task[\"dependencies\"]:\n            if dep_id not in self.tasks:\n                return False\n\n            dep_status = self.tasks[dep_id][\"status\"]\n            if dep_status != TaskStatus.COMPLETED:\n                return False\n\n        return True\n\n    def _find_lowest_priority_running_task(self) -&gt; str:\n        \"\"\"Find the running task with lowest priority.\"\"\"\n        if not self.running_tasks:\n            return None\n\n        lowest_priority = float('inf')\n        lowest_task_id = None\n\n        for task_id in self.running_tasks:\n            task = self.tasks[task_id]\n            if task[\"priority\"] &lt; lowest_priority:\n                lowest_priority = task[\"priority\"]\n                lowest_task_id = task_id\n\n        return lowest_task_id\n\n    def _start_pending_tasks(self) -&gt; None:\n        \"\"\"Try to start pending tasks based on priority.\"\"\"\n        if len(self.running_tasks) &gt;= self.max_concurrent_tasks:\n            return\n\n        # Create a priority queue of pending tasks\n        pending_tasks = []\n        for task_id, task in self.tasks.items():\n            if task[\"status\"] == TaskStatus.PENDING and self._can_start_task(task_id):\n                # Higher priority first, then older tasks\n                # Negate priority for max-heap behavior\n                heapq.heappush(pending_tasks, (-task[\"priority\"], task[\"created_at\"], task_id))\n\n        # Start tasks in priority order until we hit the concurrency limit\n        while pending_tasks and len(self.running_tasks) &lt; self.max_concurrent_tasks:\n            _, _, task_id = heapq.heappop(pending_tasks)\n            self.start_task(task_id)\n</code></pre>"},{"location":"advanced/multi_agent/#best-practices","title":"Best Practices","text":""},{"location":"advanced/multi_agent/#fault-tolerance","title":"Fault Tolerance","text":"<ol> <li>Design for Partial Failure: Assume any agent might fail and design your system to handle it</li> <li>Implement Timeouts: Never wait indefinitely for an agent to respond</li> <li>Use Circuit Breakers: Stop calling unreliable agents after repeated failures</li> <li>Maintain State Backups: Keep snapshots of important coordination state</li> <li>Implement Fallback Strategies: Define what happens when an agent is unavailable</li> </ol>"},{"location":"advanced/multi_agent/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Batch Related Tasks: Group tasks that access similar data or resources</li> <li>Minimize Communication Overhead: Use efficient message formats</li> <li>Implement Caching: Cache frequently needed data across agents</li> <li>Use Asynchronous Processing: Don't block when waiting for slow operations</li> <li>Profile and Optimize Hotspots: Identify bottlenecks in your agent communication</li> </ol>"},{"location":"advanced/multi_agent/#coordination-patterns","title":"Coordination Patterns","text":"<ol> <li>Start Simple: Begin with basic coordination before implementing advanced patterns</li> <li>Use Consistent Interfaces: Make agent APIs compatible for easier coordination</li> <li>Design Clear Protocols: Define how agents should communicate and share data</li> <li>Implement Robust Logging: Track coordination events for troubleshooting</li> <li>Test Coordination Scenarios: Verify your coordination works under stress</li> </ol>"},{"location":"advanced/multi_agent/#conclusion","title":"Conclusion","text":"<p>Advanced multi-agent coordination enables powerful, resilient systems by leveraging the strengths of specialized agents working together. By implementing hierarchical organization, federated decision making, dynamic task allocation, and conflict resolution strategies, you can build agent systems that efficiently handle complex tasks while maintaining safety constraints.</p> <p>For more information, see: - Budget Management - Safety Guardrails - Agent Coordination Basics</p>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This document provides detailed information about the core API components of the Safeguards.</p>"},{"location":"api/core/#agent","title":"Agent","text":"<p>The <code>Agent</code> class is the base abstraction for all agent implementations.</p>"},{"location":"api/core/#agent-base-class","title":"Agent Base Class","text":"<pre><code>from safeguards.types.agent import Agent\n</code></pre>"},{"location":"api/core/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"Initialize an agent.\n\n    Args:\n        name: Agent name\n    \"\"\"\n</code></pre>"},{"location":"api/core/#properties","title":"Properties","text":"<pre><code>@property\ndef id(self) -&gt; str:\n    \"\"\"Get agent ID.\n\n    Returns:\n        Unique ID for this agent\n    \"\"\"\n</code></pre>"},{"location":"api/core/#methods","title":"Methods","text":"<pre><code>@abstractmethod\ndef run(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Execute agent functionality.\n\n    Args:\n        **kwargs: Arbitrary keyword arguments for agent execution\n\n    Returns:\n        Dictionary containing execution results\n    \"\"\"\n</code></pre>"},{"location":"api/core/#implementation-example","title":"Implementation Example","text":"<pre><code>from decimal import Decimal\nfrom typing import Dict, Any\nfrom safeguards.types.agent import Agent\n\nclass MyAgent(Agent):\n    def __init__(self, name: str, cost_per_action: Decimal = Decimal(\"0.1\")):\n        super().__init__(name)\n        self.cost_per_action = cost_per_action\n        self.action_count = 0\n\n    def run(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"Execute a task and track cost.\"\"\"\n        self.action_count += 1\n\n        # Perform your agent logic here\n        result = {\"status\": \"success\", \"message\": \"Task completed\"}\n\n        # Return result with cost information\n        return {\n            \"result\": result,\n            \"action_count\": self.action_count,\n            \"cost\": self.cost_per_action,\n        }\n</code></pre>"},{"location":"api/core/#budgetcoordinator","title":"BudgetCoordinator","text":"<p>The <code>BudgetCoordinator</code> class manages resource allocation and budget tracking.</p> <pre><code>from safeguards.core.budget_coordination import BudgetCoordinator\n</code></pre>"},{"location":"api/core/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    notification_manager=None,\n    initial_pool_budget: Decimal = Decimal(\"0\")\n) -&gt; None:\n    \"\"\"Initialize the budget coordinator.\n\n    Args:\n        notification_manager: For sending coordination-related alerts\n        initial_pool_budget: Initial budget in the pool\n    \"\"\"\n</code></pre>"},{"location":"api/core/#agent-management-methods","title":"Agent Management Methods","text":"<pre><code>def register_agent(\n    self,\n    name: str,\n    initial_budget: Decimal,\n    priority: int = 0,\n    agent: Optional[Agent] = None,\n) -&gt; Agent:\n    \"\"\"Register a new agent.\n\n    Args:\n        name: Agent name\n        initial_budget: Initial budget allocation\n        priority: Agent priority level (1-10)\n        agent: Optional existing agent instance to register\n\n    Returns:\n        Registered agent\n\n    Raises:\n        ValueError: If validation fails\n    \"\"\"\n\ndef create_agent(\n    self,\n    name: str,\n    initial_budget: Decimal,\n    priority: int = 0\n) -&gt; Agent:\n    \"\"\"Create and register a new agent.\n\n    Args:\n        name: Name of the agent\n        initial_budget: Initial budget allocation\n        priority: Priority level (default 0)\n\n    Returns:\n        Newly created agent\n\n    Raises:\n        ValueError: If validation fails\n    \"\"\"\n\ndef get_agent(self, agent_id: str) -&gt; Agent:\n    \"\"\"Get an agent.\n\n    Args:\n        agent_id: ID of agent to get\n\n    Returns:\n        Agent instance\n    \"\"\"\n\ndef unregister_agent(self, agent_id: str) -&gt; None:\n    \"\"\"Unregister an agent.\n\n    Args:\n        agent_id: ID of agent to unregister\n\n    Raises:\n        AgentSafetyError: If agent not found\n    \"\"\"\n</code></pre>"},{"location":"api/core/#budget-management-methods","title":"Budget Management Methods","text":"<pre><code>def get_agent_budget(self, agent_id: str) -&gt; Decimal:\n    \"\"\"Get current budget for an agent.\n\n    Args:\n        agent_id: Agent to get budget for\n\n    Returns:\n        Current budget amount\n    \"\"\"\n\ndef update_agent_budget(self, agent_id: str, new_budget: Decimal) -&gt; None:\n    \"\"\"Update budget for an agent.\n\n    Args:\n        agent_id: Agent to update budget for\n        new_budget: New budget amount\n\n    Raises:\n        BudgetError: If update fails\n    \"\"\"\n\ndef get_agent_metrics(self, agent_id: str) -&gt; Dict:\n    \"\"\"Get budget metrics for a specific agent.\n\n    Args:\n        agent_id: The ID of the agent to get metrics for\n\n    Returns:\n        Dict containing budget metrics including:\n        - initial_budget: Initial budget allocated\n        - used_budget: Amount of budget used\n        - remaining_budget: Current remaining budget\n        - last_update: Timestamp of last budget update\n    \"\"\"\n</code></pre>"},{"location":"api/core/#pool-management-methods","title":"Pool Management Methods","text":"<pre><code>def create_pool(\n    self,\n    pool_id: str,\n    total_budget: Decimal,\n    priority: int = 0,\n) -&gt; BudgetPool:\n    \"\"\"Create a new budget pool.\n\n    Args:\n        pool_id: Unique identifier for the pool\n        total_budget: Total budget allocation for the pool\n        priority: Pool priority level\n\n    Returns:\n        Created budget pool\n\n    Raises:\n        ValueError: If pool ID already exists\n    \"\"\"\n\ndef get_pool(self, pool_id: str) -&gt; BudgetPool:\n    \"\"\"Get a budget pool.\n\n    Args:\n        pool_id: ID of pool to get\n\n    Returns:\n        Budget pool\n    \"\"\"\n\ndef get_agent_pool(self, agent_id: str) -&gt; BudgetPool:\n    \"\"\"Get pool for an agent.\n\n    Args:\n        agent_id: Agent to get pool for\n\n    Returns:\n        Agent's budget pool\n    \"\"\"\n\ndef get_pools(self) -&gt; List[BudgetPool]:\n    \"\"\"Get all budget pools.\n\n    Returns:\n        List of all budget pools\n    \"\"\"\n</code></pre>"},{"location":"api/core/#transfer-methods","title":"Transfer Methods","text":"<pre><code>def request_transfer(\n    self,\n    source_id: str,\n    target_id: str,\n    amount: Decimal,\n    transfer_type: TransferType,\n    justification: str,\n    requester: str,\n    priority: AgentPriority = AgentPriority.MEDIUM,\n    metadata: Optional[Dict] = None,\n) -&gt; UUID:\n    \"\"\"Request a budget transfer.\n\n    Args:\n        source_id: Source agent/pool ID\n        target_id: Target agent/pool ID\n        amount: Amount to transfer\n        transfer_type: Type of transfer\n        justification: Reason for transfer\n        requester: Identity of requester\n        priority: Transfer priority\n        metadata: Additional transfer metadata\n\n    Returns:\n        Transfer request ID\n\n    Raises:\n        ValueError: If invalid source/target or insufficient funds\n    \"\"\"\n\ndef approve_transfer(\n    self,\n    request_id: UUID,\n    approver: str,\n    execute: bool = True,\n) -&gt; None:\n    \"\"\"Approve a budget transfer request.\n\n    Args:\n        request_id: Transfer to approve\n        approver: Identity of approver\n        execute: Whether to execute transfer immediately\n\n    Raises:\n        ValueError: If request not found or invalid status\n    \"\"\"\n\ndef execute_transfer(self, request_id: UUID) -&gt; None:\n    \"\"\"Execute an approved transfer.\n\n    Args:\n        request_id: Transfer to execute\n\n    Raises:\n        ValueError: If request not found or not approved\n    \"\"\"\n\ndef reject_transfer(self, request_id: UUID, rejector: str, reason: str) -&gt; None:\n    \"\"\"Reject a transfer request.\n\n    Args:\n        request_id: Transfer to reject\n        rejector: Identity of rejector\n        reason: Reason for rejection\n\n    Raises:\n        ValueError: If request not found or invalid status\n    \"\"\"\n</code></pre>"},{"location":"api/core/#advanced-methods","title":"Advanced Methods","text":"<pre><code>def select_optimal_pool(self, agent_id: str, required_budget: Decimal) -&gt; str:\n    \"\"\"Select the optimal pool for an agent based on budget requirements and priority.\n\n    Args:\n        agent_id: Agent needing allocation\n        required_budget: Minimum budget needed\n\n    Returns:\n        ID of the selected pool\n\n    Raises:\n        ValueError: If no suitable pool is found\n    \"\"\"\n\ndef optimize_pool_allocations(self) -&gt; None:\n    \"\"\"Optimize budget allocations across all pools based on priorities and usage.\"\"\"\n\ndef handle_emergency_allocation(\n    self, agent_id: str, required_budget: Decimal\n) -&gt; None:\n    \"\"\"Handle emergency budget allocation for critical operations.\n\n    Args:\n        agent_id: Agent requiring emergency allocation\n        required_budget: Budget amount needed\n\n    Raises:\n        ValueError: If emergency allocation cannot be satisfied\n    \"\"\"\n\ndef auto_scale_pools(self) -&gt; None:\n    \"\"\"Automatically scale pools based on utilization and demand.\"\"\"\n</code></pre>"},{"location":"api/core/#notificationmanager","title":"NotificationManager","text":"<p>The <code>NotificationManager</code> manages notifications and alerts.</p> <pre><code>from safeguards.core.notification_manager import NotificationManager\n</code></pre>"},{"location":"api/core/#constructor_2","title":"Constructor","text":"<pre><code>def __init__(self):\n    \"\"\"Initialize the notification manager.\"\"\"\n</code></pre>"},{"location":"api/core/#methods_1","title":"Methods","text":"<pre><code>def send_alert(self, alert: Alert) -&gt; None:\n    \"\"\"Send an alert.\n\n    Args:\n        alert: Alert to send\n    \"\"\"\n\ndef send_notification(\n    self, agent_id: str, message: str, severity: str = \"INFO\"\n) -&gt; None:\n    \"\"\"Send a notification.\n\n    Args:\n        agent_id: ID of agent notification is for\n        message: Notification message\n        severity: Notification severity level\n    \"\"\"\n\ndef add_handler(self, handler: Callable[[Any], None]) -&gt; None:\n    \"\"\"Add a notification handler.\n\n    Args:\n        handler: Handler function to call for notifications\n    \"\"\"\n\ndef remove_handler(self, handler: Callable[[Any], None]) -&gt; None:\n    \"\"\"Remove a notification handler.\n\n    Args:\n        handler: Handler to remove\n    \"\"\"\n</code></pre>"},{"location":"api/core/#violationreporter","title":"ViolationReporter","text":"<p>The <code>ViolationReporter</code> reports and tracks safety violations.</p> <pre><code>from safeguards.monitoring.violation_reporter import ViolationReporter\n</code></pre>"},{"location":"api/core/#constructor_3","title":"Constructor","text":"<pre><code>def __init__(self, notification_manager: NotificationManager = None):\n    \"\"\"Initialize the violation reporter.\n\n    Args:\n        notification_manager: For sending violation notifications\n    \"\"\"\n</code></pre>"},{"location":"api/core/#methods_2","title":"Methods","text":"<pre><code>def report_violation(\n    self,\n    violation_type: ViolationType,\n    severity: ViolationSeverity,\n    context: ViolationContext,\n    description: str,\n    agent_id: Optional[str] = None,\n    pool_id: Optional[str] = None,\n) -&gt; UUID:\n    \"\"\"Report a violation.\n\n    Args:\n        violation_type: Type of violation\n        severity: Severity level\n        context: Context information\n        description: Detailed description\n        agent_id: Optional agent ID\n        pool_id: Optional pool ID\n\n    Returns:\n        Violation report ID\n    \"\"\"\n\ndef get_violation(self, violation_id: UUID) -&gt; Optional[ViolationReport]:\n    \"\"\"Get a violation report.\n\n    Args:\n        violation_id: ID of violation to get\n\n    Returns:\n        Violation report if found, None otherwise\n    \"\"\"\n\ndef get_violations_by_agent(self, agent_id: str) -&gt; List[ViolationReport]:\n    \"\"\"Get violations for an agent.\n\n    Args:\n        agent_id: Agent to get violations for\n\n    Returns:\n        List of violation reports\n    \"\"\"\n\ndef get_violations_by_pool(self, pool_id: str) -&gt; List[ViolationReport]:\n    \"\"\"Get violations for a pool.\n\n    Args:\n        pool_id: Pool to get violations for\n\n    Returns:\n        List of violation reports\n    \"\"\"\n</code></pre>"},{"location":"api/core/#transactionmanager","title":"TransactionManager","text":"<p>The <code>TransactionManager</code> ensures atomic operations.</p> <pre><code>from safeguards.core.transaction import TransactionManager\n</code></pre>"},{"location":"api/core/#methods_3","title":"Methods","text":"<pre><code>def begin_transaction(self) -&gt; None:\n    \"\"\"Begin a new transaction.\"\"\"\n\ndef commit(self) -&gt; None:\n    \"\"\"Commit the current transaction.\"\"\"\n\ndef rollback(self) -&gt; None:\n    \"\"\"Roll back the current transaction.\"\"\"\n\ndef get_state(self) -&gt; Optional[T]:\n    \"\"\"Get the current transaction state.\n\n    Returns:\n        Current state or None if no transaction is active\n    \"\"\"\n\ndef set_state(self, state: T) -&gt; None:\n    \"\"\"Set the current transaction state.\n\n    Args:\n        state: New state to set\n    \"\"\"\n</code></pre>"},{"location":"api/core/#budgetpool","title":"BudgetPool","text":"<p>The <code>BudgetPool</code> class represents a container for shared resources.</p> <pre><code>from safeguards.core.dynamic_budget import BudgetPool\n</code></pre>"},{"location":"api/core/#constructor_4","title":"Constructor","text":"<pre><code>@dataclass\nclass BudgetPool:\n    \"\"\"Shared budget pool for multiple agents.\"\"\"\n\n    pool_id: str\n    total_budget: Decimal\n    priority: int = 0\n    allocated_budget: Decimal = field(default=Decimal(\"0\"))\n    reserved_budget: Decimal = field(default=Decimal(\"0\"))\n    agent_allocations: Dict[str, Decimal] = field(default_factory=dict)\n    agents: Set[str] = field(default_factory=set)\n    priority_weights: Dict[AgentPriority, float] = field(...)\n    used_budget: Decimal = field(default=Decimal(\"0\"))\n    last_update: datetime = field(default_factory=datetime.now)\n</code></pre>"},{"location":"api/core/#properties_1","title":"Properties","text":"<pre><code>@property\ndef name(self) -&gt; str:\n    \"\"\"Get pool name (alias for pool_id for compatibility).\"\"\"\n\n@property\ndef id(self) -&gt; str:\n    \"\"\"Get pool ID (alias for pool_id for compatibility).\"\"\"\n\n@property\ndef remaining_budget(self) -&gt; Decimal:\n    \"\"\"Get remaining budget in pool.\"\"\"\n\n@property\ndef initial_budget(self) -&gt; Decimal:\n    \"\"\"For backward compatibility - Return total budget.\"\"\"\n</code></pre>"},{"location":"api/core/#alert-types","title":"Alert Types","text":"<pre><code>from safeguards.core.alert_types import Alert, AlertSeverity\n</code></pre>"},{"location":"api/core/#alert-class","title":"Alert Class","text":"<pre><code>@dataclass\nclass Alert:\n    \"\"\"Alert notification.\"\"\"\n\n    title: str\n    description: str\n    severity: AlertSeverity\n    metadata: Dict = field(default_factory=dict)\n    timestamp: datetime = field(default_factory=datetime.now)\n</code></pre>"},{"location":"api/core/#alertseverity-enum","title":"AlertSeverity Enum","text":"<pre><code>class AlertSeverity(Enum):\n    \"\"\"Alert severity levels.\"\"\"\n\n    INFO = auto()\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n    CRITICAL = auto()\n</code></pre>"},{"location":"api/core/#violation-types","title":"Violation Types","text":"<pre><code>from safeguards.monitoring.violation_reporter import ViolationType, ViolationSeverity\n</code></pre>"},{"location":"api/core/#violationtype-enum","title":"ViolationType Enum","text":"<pre><code>class ViolationType(Enum):\n    \"\"\"Types of budget violations.\"\"\"\n\n    OVERSPEND = auto()        # Spent more than allocated\n    UNAUTHORIZED = auto()     # Unauthorized budget operation\n    RATE_LIMIT = auto()       # Too many operations in time window\n    RESOURCE_BREACH = auto()  # Exceeded resource allocation\n    POOL_BREACH = auto()      # Pool depleted below minimum\n    POOL_HEALTH = auto()      # Pool health issues detected\n</code></pre>"},{"location":"api/core/#violationseverity-enum","title":"ViolationSeverity Enum","text":"<pre><code>class ViolationSeverity(Enum):\n    \"\"\"Severity levels for violations.\"\"\"\n\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n    CRITICAL = auto()\n</code></pre>"},{"location":"api/core/#transfertype-enum","title":"TransferType Enum","text":"<pre><code>from safeguards.core.budget_coordination import TransferType\n</code></pre> <pre><code>class TransferType(Enum):\n    \"\"\"Types of budget transfers.\"\"\"\n\n    DIRECT = auto()       # Direct transfer between agents\n    POOL_DEPOSIT = auto() # Agent depositing to shared pool\n    POOL_WITHDRAW = auto() # Agent withdrawing from shared pool\n    ALLOCATION = auto()   # Initial allocation from pool\n    REALLOCATION = auto() # Moving budget between agents\n    RETURN = auto()       # Return unused budget to pool\n</code></pre>"},{"location":"api/core/#agentpriority-enum","title":"AgentPriority Enum","text":"<pre><code>from safeguards.core.dynamic_budget import AgentPriority\n</code></pre> <pre><code>class AgentPriority(Enum):\n    \"\"\"Priority levels for agents.\"\"\"\n\n    CRITICAL = auto()  # Mission-critical agents (e.g., core monitoring)\n    HIGH = auto()      # High-priority business functions\n    MEDIUM = auto()    # Standard operations\n    LOW = auto()       # Non-critical background tasks\n    MINIMAL = auto()   # Debug/testing agents\n</code></pre>"},{"location":"api/core/#exceptions","title":"Exceptions","text":"<pre><code>from safeguards.exceptions import (\n    AgentSafetyError,\n    BudgetError,\n    ResourceError,\n    ErrorContext,\n)\n</code></pre>"},{"location":"api/core/#base-exception","title":"Base Exception","text":"<pre><code>class AgentSafetyError(Exception):\n    \"\"\"Base exception for Agent Safety errors.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        code: Optional[str] = None,\n        context: Optional[ErrorContext] = None\n    ):\n        \"\"\"Initialize the exception.\n\n        Args:\n            message: Error message\n            code: Error code\n            context: Error context\n        \"\"\"\n        super().__init__(message)\n        self.message = message\n        self.code = code\n        self.context = context or ErrorContext()\n</code></pre>"},{"location":"api/core/#specific-exceptions","title":"Specific Exceptions","text":"<pre><code>class BudgetError(AgentSafetyError):\n    \"\"\"Exception for budget-related errors.\"\"\"\n\nclass ResourceError(AgentSafetyError):\n    \"\"\"Exception for resource-related errors.\"\"\"\n</code></pre>"},{"location":"api/core/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Budget API Reference for budget-specific APIs</li> <li>Check the Agent API Reference for agent-specific APIs</li> <li>Review the Monitoring API Reference for monitoring capabilities</li> </ul>"},{"location":"api/monitoring/","title":"Monitoring API Reference","text":"<p>This document provides a detailed reference for the monitoring APIs in the Safeguards.</p>"},{"location":"api/monitoring/#metricscollector","title":"MetricsCollector","text":"<p><code>MetricsCollector</code> is the core class for gathering and storing metrics about agent performance and resource usage.</p> <pre><code>from safeguards.monitoring.metrics_collector import MetricsCollector\n\n# Create a metrics collector\nmetrics_collector = MetricsCollector()\n</code></pre>"},{"location":"api/monitoring/#methods","title":"Methods","text":""},{"location":"api/monitoring/#register_agent","title":"<code>register_agent</code>","text":"<pre><code>def register_agent(self, agent_id: str) -&gt; None:\n    \"\"\"\n    Register an agent for metrics collection.\n\n    Args:\n        agent_id: Unique identifier for the agent\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#record_metric","title":"<code>record_metric</code>","text":"<pre><code>def record_metric(\n    self,\n    agent_id: str,\n    metric_name: str,\n    value: Union[int, float, Decimal],\n    unit: Optional[str] = None,\n    context: Optional[Dict[str, Any]] = None\n) -&gt; None:\n    \"\"\"\n    Record a metric value for an agent.\n\n    Args:\n        agent_id: Agent identifier\n        metric_name: Name of the metric\n        value: Numerical value of the metric\n        unit: Optional unit of measurement\n        context: Optional contextual information\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#get_agent_metrics","title":"<code>get_agent_metrics</code>","text":"<pre><code>def get_agent_metrics(\n    self,\n    agent_id: str,\n    start_time: Optional[str] = None,\n    end_time: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get all metrics for an agent within the specified time range.\n\n    Args:\n        agent_id: Agent identifier\n        start_time: ISO-format start time (e.g., \"2023-01-01T00:00:00Z\")\n        end_time: ISO-format end time (e.g., \"2023-01-02T00:00:00Z\")\n\n    Returns:\n        Dictionary containing the agent's metrics\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#get_agent_metrics_by_type","title":"<code>get_agent_metrics_by_type</code>","text":"<pre><code>def get_agent_metrics_by_type(\n    self,\n    agent_id: str,\n    metric_type: str,\n    start_time: Optional[str] = None,\n    end_time: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get metrics of a specific type for an agent.\n\n    Args:\n        agent_id: Agent identifier\n        metric_type: Type of metrics to retrieve (e.g., \"performance\", \"budget\")\n        start_time: ISO-format start time\n        end_time: ISO-format end time\n\n    Returns:\n        Dictionary containing the requested metrics\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#get_pool_metrics","title":"<code>get_pool_metrics</code>","text":"<pre><code>def get_pool_metrics(\n    self,\n    pool_id: str,\n    start_time: Optional[str] = None,\n    end_time: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get metrics for a budget pool.\n\n    Args:\n        pool_id: Pool identifier\n        start_time: ISO-format start time\n        end_time: ISO-format end time\n\n    Returns:\n        Dictionary containing the pool's metrics\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#violationreporter","title":"ViolationReporter","text":"<p><code>ViolationReporter</code> is responsible for detecting and reporting safety violations.</p> <pre><code>from safeguards.monitoring.violation_reporter import ViolationReporter\nfrom safeguards.core.notification_manager import NotificationManager\n\n# Create a violation reporter\nnotification_manager = NotificationManager()\nviolation_reporter = ViolationReporter(notification_manager)\n</code></pre>"},{"location":"api/monitoring/#methods_1","title":"Methods","text":""},{"location":"api/monitoring/#report_violation","title":"<code>report_violation</code>","text":"<pre><code>def report_violation(\n    self,\n    agent_id: Optional[str] = None,\n    violation_type: ViolationType = ViolationType.UNKNOWN,\n    severity: AlertSeverity = AlertSeverity.MEDIUM,\n    message: str = \"\",\n    details: Optional[Dict[str, Any]] = None\n) -&gt; str:\n    \"\"\"\n    Report a safety violation.\n\n    Args:\n        agent_id: Optional identifier of the agent involved\n        violation_type: Type of violation from ViolationType enum\n        severity: Severity level from AlertSeverity enum\n        message: Human-readable description of the violation\n        details: Additional details about the violation\n\n    Returns:\n        Unique identifier for the violation report\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#get_violations","title":"<code>get_violations</code>","text":"<pre><code>def get_violations(\n    self,\n    agent_id: Optional[str] = None,\n    start_time: Optional[str] = None,\n    end_time: Optional[str] = None,\n    violation_type: Optional[ViolationType] = None,\n    min_severity: Optional[AlertSeverity] = None\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Retrieve violation reports matching the specified criteria.\n\n    Args:\n        agent_id: Optional agent identifier to filter by\n        start_time: ISO-format start time\n        end_time: ISO-format end time\n        violation_type: Optional violation type to filter by\n        min_severity: Optional minimum severity level\n\n    Returns:\n        List of violation reports matching the criteria\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#runtimemonitor","title":"RuntimeMonitor","text":"<p><code>RuntimeMonitor</code> provides real-time monitoring of agent activities.</p> <pre><code>from safeguards.monitoring.runtime_monitor import RuntimeMonitor\n\n# Create a runtime monitor\nruntime_monitor = RuntimeMonitor(metrics_collector)\n</code></pre>"},{"location":"api/monitoring/#methods_2","title":"Methods","text":""},{"location":"api/monitoring/#register_agent_1","title":"<code>register_agent</code>","text":"<pre><code>def register_agent(self, agent_id: str) -&gt; None:\n    \"\"\"\n    Register an agent for runtime monitoring.\n\n    Args:\n        agent_id: Agent identifier\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#register_monitor","title":"<code>register_monitor</code>","text":"<pre><code>def register_monitor(self, monitor: AgentMonitor) -&gt; None:\n    \"\"\"\n    Register a custom monitor.\n\n    Args:\n        monitor: An AgentMonitor instance to register\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#configure","title":"<code>configure</code>","text":"<pre><code>def configure(\n    self,\n    check_interval: int = 60,\n    metrics_rollup_interval: int = 300,\n    alert_threshold_check_interval: int = 60\n) -&gt; None:\n    \"\"\"\n    Configure monitoring intervals.\n\n    Args:\n        check_interval: Seconds between agent checks\n        metrics_rollup_interval: Seconds between metrics aggregation\n        alert_threshold_check_interval: Seconds between alert threshold checks\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#start","title":"<code>start</code>","text":"<pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the runtime monitoring process.\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#stop","title":"<code>stop</code>","text":"<pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the runtime monitoring process.\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#agentmonitor","title":"AgentMonitor","text":"<p><code>AgentMonitor</code> is the base class for implementing custom monitoring logic.</p> <pre><code>from safeguards.monitoring.agent_monitor import AgentMonitor\n\nclass CustomMonitor(AgentMonitor):\n    def check(self, agent_id: str, metrics: Dict[str, Any]) -&gt; Optional[Dict[str, Any]]:\n        # Custom monitoring logic\n        # Return an alert dict if an issue is detected, None otherwise\n        pass\n</code></pre>"},{"location":"api/monitoring/#abstract-methods","title":"Abstract Methods","text":""},{"location":"api/monitoring/#check","title":"<code>check</code>","text":"<pre><code>@abstractmethod\ndef check(self, agent_id: str, metrics: Dict[str, Any]) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Check agent metrics for issues.\n\n    Args:\n        agent_id: Agent identifier\n        metrics: Current metrics for the agent\n\n    Returns:\n        Alert dict if an issue is detected, None otherwise\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#metricsapi","title":"MetricsAPI","text":"<p><code>MetricsAPI</code> provides a unified interface for metrics operations.</p> <pre><code>from safeguards.api import APIFactory, APIVersion\n\n# Create a metrics API\napi_factory = APIFactory()\nmetrics_api = api_factory.create_metrics_api(\n    version=APIVersion.V1,\n    metrics_collector=metrics_collector\n)\n</code></pre>"},{"location":"api/monitoring/#methods_3","title":"Methods","text":""},{"location":"api/monitoring/#register_agent_2","title":"<code>register_agent</code>","text":"<pre><code>def register_agent(self, agent_id: str) -&gt; None:\n    \"\"\"\n    Register an agent for metrics collection.\n\n    Args:\n        agent_id: Agent identifier\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#record_metric_1","title":"<code>record_metric</code>","text":"<pre><code>def record_metric(\n    self,\n    agent_id: str,\n    metric_name: str,\n    value: Union[int, float, Decimal],\n    unit: Optional[str] = None,\n    context: Optional[Dict[str, Any]] = None\n) -&gt; None:\n    \"\"\"\n    Record a metric value for an agent.\n\n    Args:\n        agent_id: Agent identifier\n        metric_name: Name of the metric\n        value: Numerical value of the metric\n        unit: Optional unit of measurement\n        context: Optional contextual information\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#get_agent_metrics_1","title":"<code>get_agent_metrics</code>","text":"<pre><code>def get_agent_metrics(\n    self,\n    agent_id: str,\n    start_time: Optional[str] = None,\n    end_time: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get all metrics for an agent.\n\n    Args:\n        agent_id: Agent identifier\n        start_time: ISO-format start time\n        end_time: ISO-format end time\n\n    Returns:\n        Dictionary containing the agent's metrics\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#get_agent_usage_history","title":"<code>get_agent_usage_history</code>","text":"<pre><code>def get_agent_usage_history(\n    self,\n    agent_id: str,\n    start_time: Optional[str] = None,\n    end_time: Optional[str] = None\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get usage history for an agent.\n\n    Args:\n        agent_id: Agent identifier\n        start_time: ISO-format start time\n        end_time: ISO-format end time\n\n    Returns:\n        List of usage records\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#get_violations_1","title":"<code>get_violations</code>","text":"<pre><code>def get_violations(\n    self,\n    agent_id: Optional[str] = None,\n    start_time: Optional[str] = None,\n    end_time: Optional[str] = None,\n    violation_type: Optional[ViolationType] = None,\n    min_severity: Optional[AlertSeverity] = None\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get violation reports.\n\n    Args:\n        agent_id: Optional agent identifier to filter by\n        start_time: ISO-format start time\n        end_time: ISO-format end time\n        violation_type: Optional violation type to filter by\n        min_severity: Optional minimum severity level\n\n    Returns:\n        List of violation reports matching the criteria\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#dashboardgenerator","title":"DashboardGenerator","text":"<p><code>DashboardGenerator</code> assists with creating monitoring dashboards.</p> <pre><code>from safeguards.monitoring.visualization import DashboardGenerator\n\n# Create a dashboard generator\ndashboard = DashboardGenerator()\n</code></pre>"},{"location":"api/monitoring/#methods_4","title":"Methods","text":""},{"location":"api/monitoring/#add_metric_panel","title":"<code>add_metric_panel</code>","text":"<pre><code>def add_metric_panel(\n    self,\n    title: str,\n    metric_names: List[str],\n    display_type: str = \"line\",\n    timeframe: str = \"last_6h\",\n    agent_ids: Optional[List[str]] = None\n) -&gt; None:\n    \"\"\"\n    Add a metrics panel to the dashboard.\n\n    Args:\n        title: Panel title\n        metric_names: List of metrics to display\n        display_type: Visualization type (line, gauge, bar, etc.)\n        timeframe: Time range to display\n        agent_ids: Optional list of agent IDs to include\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#add_alert_panel","title":"<code>add_alert_panel</code>","text":"<pre><code>def add_alert_panel(\n    self,\n    title: str,\n    alert_types: Optional[List[str]] = None,\n    display_type: str = \"list\",\n    max_items: int = 10\n) -&gt; None:\n    \"\"\"\n    Add an alerts panel to the dashboard.\n\n    Args:\n        title: Panel title\n        alert_types: Optional list of alert types to display\n        display_type: Visualization type (list, table, etc.)\n        max_items: Maximum number of items to display\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#generate_config","title":"<code>generate_config</code>","text":"<pre><code>def generate_config(\n    self,\n    dashboard_title: str,\n    refresh_interval: int = 60\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate dashboard configuration.\n\n    Args:\n        dashboard_title: Title of the dashboard\n        refresh_interval: Refresh interval in seconds\n\n    Returns:\n        Dashboard configuration dictionary\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#alertmanager","title":"AlertManager","text":"<p><code>AlertManager</code> manages alert rules and triggers notifications.</p> <pre><code>from safeguards.monitoring.alert_manager import AlertManager\n\n# Create an alert manager\nalert_manager = AlertManager(notification_manager)\n</code></pre>"},{"location":"api/monitoring/#methods_5","title":"Methods","text":""},{"location":"api/monitoring/#add_alert_rule","title":"<code>add_alert_rule</code>","text":"<pre><code>def add_alert_rule(\n    self,\n    name: str,\n    condition: Callable[[Dict[str, Any]], bool],\n    message: str,\n    severity: AlertSeverity = AlertSeverity.MEDIUM,\n    throttle_duration: int = 300\n) -&gt; None:\n    \"\"\"\n    Add an alert rule.\n\n    Args:\n        name: Rule name\n        condition: Function that takes metrics dict and returns True if alert should trigger\n        message: Alert message template\n        severity: Alert severity level\n        throttle_duration: Minimum seconds between repeated alerts\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#check_metrics","title":"<code>check_metrics</code>","text":"<pre><code>def check_metrics(\n    self,\n    agent_id: str,\n    metrics: Dict[str, Any]\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Check metrics against alert rules.\n\n    Args:\n        agent_id: Agent identifier\n        metrics: Current metrics\n\n    Returns:\n        List of triggered alerts\n    \"\"\"\n</code></pre>"},{"location":"api/monitoring/#examples","title":"Examples","text":""},{"location":"api/monitoring/#basic-metrics-collection","title":"Basic Metrics Collection","text":"<pre><code>from safeguards.api import APIFactory, APIVersion\nfrom safeguards.monitoring.metrics_collector import MetricsCollector\nfrom decimal import Decimal\n\n# Setup\nmetrics_collector = MetricsCollector()\napi_factory = APIFactory()\nmetrics_api = api_factory.create_metrics_api(\n    version=APIVersion.V1,\n    metrics_collector=metrics_collector\n)\n\n# Register agent\nagent_id = \"agent123\"\nmetrics_api.register_agent(agent_id)\n\n# Record various metrics\nmetrics_api.record_metric(\n    agent_id=agent_id,\n    metric_name=\"task_completion_time\",\n    value=2.3,\n    unit=\"seconds\",\n    context={\"task_id\": \"task456\", \"task_type\": \"text_processing\"}\n)\n\nmetrics_api.record_metric(\n    agent_id=agent_id,\n    metric_name=\"token_usage\",\n    value=1250,\n    unit=\"tokens\"\n)\n\nmetrics_api.record_metric(\n    agent_id=agent_id,\n    metric_name=\"api_cost\",\n    value=Decimal(\"0.025\"),\n    unit=\"USD\"\n)\n\n# Retrieve metrics\nagent_metrics = metrics_api.get_agent_metrics(agent_id)\nprint(f\"Metrics for agent {agent_id}:\")\nprint(f\"Task completion time: {agent_metrics.get('task_completion_time', 'N/A')}\")\nprint(f\"Token usage: {agent_metrics.get('token_usage', 'N/A')}\")\nprint(f\"API cost: {agent_metrics.get('api_cost', 'N/A')}\")\n</code></pre>"},{"location":"api/monitoring/#custom-monitoring","title":"Custom Monitoring","text":"<pre><code>from safeguards.monitoring.agent_monitor import AgentMonitor\nfrom safeguards.monitoring.runtime_monitor import RuntimeMonitor\nfrom safeguards.types.enums import AlertSeverity\nfrom typing import Dict, Any, Optional\n\n# Create a custom monitor\nclass ResourceMonitor(AgentMonitor):\n    def __init__(self, token_limit: int = 10000, cost_limit: Decimal = Decimal(\"1.0\")):\n        self.token_limit = token_limit\n        self.cost_limit = cost_limit\n\n    def check(self, agent_id: str, metrics: Dict[str, Any]) -&gt; Optional[Dict[str, Any]]:\n        # Check token usage\n        token_usage = metrics.get(\"token_usage\", 0)\n        if token_usage &gt; self.token_limit:\n            return {\n                \"severity\": AlertSeverity.HIGH,\n                \"message\": f\"Token usage exceeded for agent {agent_id}\",\n                \"details\": {\n                    \"usage\": token_usage,\n                    \"limit\": self.token_limit,\n                    \"overage\": token_usage - self.token_limit\n                }\n            }\n\n        # Check cost\n        api_cost = metrics.get(\"api_cost\", Decimal(\"0\"))\n        if api_cost &gt; self.cost_limit:\n            return {\n                \"severity\": AlertSeverity.HIGH,\n                \"message\": f\"Cost limit exceeded for agent {agent_id}\",\n                \"details\": {\n                    \"cost\": str(api_cost),\n                    \"limit\": str(self.cost_limit),\n                    \"overage\": str(api_cost - self.cost_limit)\n                }\n            }\n\n        return None  # No issues detected\n\n# Set up runtime monitoring\nmetrics_collector = MetricsCollector()\nruntime_monitor = RuntimeMonitor(metrics_collector)\n\n# Register the custom monitor\nresource_monitor = ResourceMonitor(token_limit=5000, cost_limit=Decimal(\"0.5\"))\nruntime_monitor.register_monitor(resource_monitor)\n\n# Register agent and start monitoring\nruntime_monitor.register_agent(\"agent123\")\nruntime_monitor.configure(check_interval=30)  # Check every 30 seconds\nruntime_monitor.start()\n</code></pre>"},{"location":"api/monitoring/#violation-reporting","title":"Violation Reporting","text":"<pre><code>from safeguards.monitoring.violation_reporter import ViolationReporter\nfrom safeguards.core.notification_manager import NotificationManager\nfrom safeguards.types.enums import ViolationType, AlertSeverity\n\n# Setup\nnotification_manager = NotificationManager()\nviolation_reporter = ViolationReporter(notification_manager)\n\n# Report a violation\nviolation_id = violation_reporter.report_violation(\n    agent_id=\"agent123\",\n    violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n    severity=AlertSeverity.HIGH,\n    message=\"Agent exceeded token limit\",\n    details={\n        \"limit\": 1000,\n        \"actual_usage\": 1500,\n        \"resource_type\": \"tokens\"\n    }\n)\n\nprint(f\"Violation reported with ID: {violation_id}\")\n\n# Retrieve violations\nviolations = violation_reporter.get_violations(\n    agent_id=\"agent123\",\n    min_severity=AlertSeverity.MEDIUM\n)\n\nprint(f\"Found {len(violations)} violations\")\nfor violation in violations:\n    print(f\"- {violation['timestamp']}: {violation['message']} ({violation['severity']})\")\n</code></pre> <p>For more information about monitoring in the Safeguards, see: - Monitoring Guide - Budget Management Guide - Agent Safety Guide</p>"},{"location":"development/architecture/","title":"Architecture Overview","text":"<p>This document provides a detailed overview of the Safeguards architecture, its components, and how they interact.</p>"},{"location":"development/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>The Safeguards is structured as a layered architecture with several key components:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Client Code                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   API Layer                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 Agent API \u2502  \u2502 Budget API\u2502  \u2502 Config API\u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Core Layer                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  BudgetCoordinator \u2502  \u2502 TransactionManager\u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Notification System\u2502  \u2502 SafetyController  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Monitoring Layer                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 MetricsAnalyzer\u2502  \u2502   ViolationReporter  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502ResourceMonitor\u2502  \u2502    PoolHealthMonitor  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#component-descriptions","title":"Component Descriptions","text":""},{"location":"development/architecture/#api-layer","title":"API Layer","text":"<p>The API layer provides contract-based interfaces for client code to interact with the framework.</p>"},{"location":"development/architecture/#agent-api","title":"Agent API","text":"<p>Manages agent creation, registration, and lifecycle operations.</p> <p>Key interfaces: - <code>AgentAPIContract</code>: Base contract for agent operations - <code>AgentAPIV1</code>: Concrete V1 implementation</p>"},{"location":"development/architecture/#budget-api","title":"Budget API","text":"<p>Manages budget operations, pools, and resource allocation.</p> <p>Key interfaces: - <code>BudgetAPIContract</code>: Base contract for budget operations - <code>BudgetAPIV1</code>: Concrete V1 implementation</p>"},{"location":"development/architecture/#config-api","title":"Config API","text":"<p>Manages system configuration and settings.</p> <p>Key interfaces: - <code>ConfigAPIContract</code>: Base contract for configuration operations - <code>ConfigAPIV1</code>: Concrete V1 implementation</p>"},{"location":"development/architecture/#metrics-api","title":"Metrics API","text":"<p>Provides access to system and agent metrics.</p> <p>Key interfaces: - <code>MetricsAPIContract</code>: Base contract for metrics operations - <code>MetricsAPIV1</code>: Concrete V1 implementation</p>"},{"location":"development/architecture/#core-layer","title":"Core Layer","text":"<p>The core layer contains the central components that manage resources, agents, and safety controls.</p>"},{"location":"development/architecture/#budgetcoordinator","title":"BudgetCoordinator","text":"<p>Manages resource allocation, transfers, and budget tracking.</p> <p>Key responsibilities: - Agent registration - Budget pool management - Resource transfers - Budget allocation - Usage tracking</p>"},{"location":"development/architecture/#transactionmanager","title":"TransactionManager","text":"<p>Ensures atomic operations across multiple resources.</p> <p>Key responsibilities: - Transaction boundaries - Rollback on failure - State consistency - Concurrency control</p>"},{"location":"development/architecture/#notificationmanager","title":"NotificationManager","text":"<p>Manages alerts and notifications across the system.</p> <p>Key responsibilities: - Alert generation - Notification routing - Handler management - Alert levels</p>"},{"location":"development/architecture/#safetycontroller","title":"SafetyController","text":"<p>Coordinates safety operations across the system.</p> <p>Key responsibilities: - Safety rule enforcement - Guardrail coordination - Emergency handling - Safety policy application</p>"},{"location":"development/architecture/#monitoring-layer","title":"Monitoring Layer","text":"<p>The monitoring layer observes system operations and collects metrics.</p>"},{"location":"development/architecture/#metricsanalyzer","title":"MetricsAnalyzer","text":"<p>Analyzes metrics to detect patterns and anomalies.</p> <p>Key responsibilities: - Trend analysis - Pattern detection - Budget efficiency tracking - Usage profiling</p>"},{"location":"development/architecture/#violationreporter","title":"ViolationReporter","text":"<p>Reports and tracks safety violations.</p> <p>Key responsibilities: - Violation detection - Severity assessment - Reporting - Remediation suggestions</p>"},{"location":"development/architecture/#resourcemonitor","title":"ResourceMonitor","text":"<p>Monitors system resource usage.</p> <p>Key responsibilities: - CPU usage tracking - Memory usage tracking - Disk usage tracking - Network monitoring</p>"},{"location":"development/architecture/#poolhealthmonitor","title":"PoolHealthMonitor","text":"<p>Monitors the health of budget pools.</p> <p>Key responsibilities: - Pool utilization tracking - Health assessment - Recommendations - Alert generation</p>"},{"location":"development/architecture/#data-flow","title":"Data Flow","text":""},{"location":"development/architecture/#agent-registration-flow","title":"Agent Registration Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Client   \u2502      \u2502Agent API \u2502      \u2502BudgetCoordinator\u2502      \u2502Budget   \u2502\n\u2502         \u2502      \u2502          \u2502      \u2502                 \u2502      \u2502Pool     \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n     \u2502                \u2502                      \u2502                    \u2502\n     \u2502 create_agent() \u2502                      \u2502                    \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                      \u2502                    \u2502\n     \u2502                \u2502                      \u2502                    \u2502\n     \u2502                \u2502 register_agent()     \u2502                    \u2502\n     \u2502                \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502\n     \u2502                \u2502                      \u2502                    \u2502\n     \u2502                \u2502                      \u2502 allocate_budget()  \u2502\n     \u2502                \u2502                      \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                \u2502                      \u2502                    \u2502\n     \u2502                \u2502                      \u2502   pool_updated     \u2502\n     \u2502                \u2502                      \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                \u2502                      \u2502                    \u2502\n     \u2502                \u2502 agent_created        \u2502                    \u2502\n     \u2502                \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                    \u2502\n     \u2502                \u2502                      \u2502                    \u2502\n     \u2502 return agent   \u2502                      \u2502                    \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                      \u2502                    \u2502\n     \u2502                \u2502                      \u2502                    \u2502\n</code></pre>"},{"location":"development/architecture/#budget-update-flow","title":"Budget Update Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Client   \u2502      \u2502Budget API\u2502      \u2502BudgetCoordinator\u2502      \u2502NotificationMgr\u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502                \u2502                      \u2502                       \u2502\n     \u2502 update_budget()\u2502                      \u2502                       \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                      \u2502                       \u2502\n     \u2502                \u2502                      \u2502                       \u2502\n     \u2502                \u2502update_agent_budget() \u2502                       \u2502\n     \u2502                \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                       \u2502\n     \u2502                \u2502                      \u2502                       \u2502\n     \u2502                \u2502                      \u2502  check_thresholds()   \u2502\n     \u2502                \u2502                      \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n     \u2502                \u2502                      \u2502                       \u2502\n     \u2502                \u2502                      \u2502                       \u2502\n     \u2502                \u2502                      \u2502   alert_if_needed()   \u2502\n     \u2502                \u2502                      \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                \u2502                      \u2502                       \u2502\n     \u2502                \u2502 update_complete      \u2502                       \u2502\n     \u2502                \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                       \u2502\n     \u2502                \u2502                      \u2502                       \u2502\n     \u2502 return success \u2502                      \u2502                       \u2502\n     \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                      \u2502                       \u2502\n     \u2502                \u2502                      \u2502                       \u2502\n</code></pre>"},{"location":"development/architecture/#violation-reporting-flow","title":"Violation Reporting Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502BudgetCoord  \u2502    \u2502ViolationRptr\u2502    \u2502NotificationMgr\u2502    \u2502Handlers   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                  \u2502                    \u2502                 \u2502\n       \u2502 detect_violation \u2502                    \u2502                 \u2502\n       \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                    \u2502                 \u2502\n       \u2502                  \u2502                    \u2502                 \u2502\n       \u2502                  \u2502 report_violation() \u2502                 \u2502\n       \u2502                  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                 \u2502\n       \u2502                  \u2502                    \u2502                 \u2502\n       \u2502                  \u2502                    \u2502 notify_handlers()\n       \u2502                  \u2502                    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n       \u2502                  \u2502                    \u2502                 \u2502\n       \u2502                  \u2502                    \u2502 handler_actions()\n       \u2502                  \u2502                    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n       \u2502                  \u2502                    \u2502                 \u2502\n       \u2502                  \u2502 violation_recorded \u2502                 \u2502\n       \u2502                  \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                 \u2502\n       \u2502                  \u2502                    \u2502                 \u2502\n       \u2502 return status    \u2502                    \u2502                 \u2502\n       \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                    \u2502                 \u2502\n       \u2502                  \u2502                    \u2502                 \u2502\n</code></pre>"},{"location":"development/architecture/#key-design-patterns","title":"Key Design Patterns","text":"<p>The framework utilizes several design patterns:</p>"},{"location":"development/architecture/#factory-pattern","title":"Factory Pattern","text":"<p>Used in the <code>APIFactory</code> class to create concrete API implementations based on version.</p> <pre><code>class APIFactory:\n    def create_budget_api(self, version: APIVersion, coordinator: BudgetCoordinator) -&gt; BudgetAPIContract:\n        if version == APIVersion.V1:\n            return BudgetAPIV1(coordinator)\n        # More versions...\n</code></pre>"},{"location":"development/architecture/#strategy-pattern","title":"Strategy Pattern","text":"<p>Used for different budget allocation strategies.</p> <pre><code>class AllocationStrategy(ABC):\n    @abstractmethod\n    def allocate(self, resources, agents) -&gt; Dict[str, Decimal]:\n        pass\n\nclass PriorityBasedAllocation(AllocationStrategy):\n    def allocate(self, resources, agents) -&gt; Dict[str, Decimal]:\n        # Priority-based implementation\n</code></pre>"},{"location":"development/architecture/#observer-pattern","title":"Observer Pattern","text":"<p>Used in the notification system.</p> <pre><code>class NotificationManager:\n    def __init__(self):\n        self._handlers = []\n\n    def add_handler(self, handler):\n        self._handlers.append(handler)\n\n    def notify(self, notification):\n        for handler in self._handlers:\n            handler(notification)\n</code></pre>"},{"location":"development/architecture/#command-pattern","title":"Command Pattern","text":"<p>Used for budget operations.</p> <pre><code>class TransferRequest:\n    def __init__(self, source_id, target_id, amount, transfer_type, justification):\n        self.source_id = source_id\n        self.target_id = target_id\n        self.amount = amount\n        self.transfer_type = transfer_type\n        self.justification = justification\n</code></pre>"},{"location":"development/architecture/#module-dependencies","title":"Module Dependencies","text":"<p>The framework has the following key module dependencies:</p> <pre><code>safeguards.api\n\u251c\u2500\u2500 safeguards.core.budget_coordination\n\u2514\u2500\u2500 safeguards.monitoring.metrics\n\nsafeguards.core.budget_coordination\n\u251c\u2500\u2500 safeguards.core.transaction\n\u251c\u2500\u2500 safeguards.core.notification_manager\n\u2514\u2500\u2500 safeguards.monitoring.violation_reporter\n\nsafeguards.monitoring.violation_reporter\n\u2514\u2500\u2500 safeguards.core.notification_manager\n\nsafeguards.core.pool_health\n\u251c\u2500\u2500 safeguards.core.notification_manager\n\u2514\u2500\u2500 safeguards.monitoring.violation_reporter\n</code></pre>"},{"location":"development/architecture/#thread-safety","title":"Thread Safety","text":"<p>The framework is designed to be thread-safe in the following ways:</p> <ol> <li>Transaction Manager uses locks to ensure atomic operations</li> <li>Budget Coordinator uses transaction boundaries for consistency</li> <li>Notification Manager is designed for concurrent notification delivery</li> <li>Pool operations use appropriate synchronization mechanisms</li> </ol>"},{"location":"development/architecture/#extension-points","title":"Extension Points","text":"<p>The framework provides several extension points:</p> <ol> <li>Custom Agent Implementations - Extend the <code>Agent</code> base class</li> <li>Custom Safety Rules - Implement the <code>SafetyRule</code> interface</li> <li>Custom Notification Handlers - Register handlers with <code>NotificationManager</code></li> <li>Custom Budget Allocation Strategies - Implement <code>AllocationStrategy</code></li> <li>API Versioning - Implement new API versions while maintaining backward compatibility</li> </ol>"},{"location":"development/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Review the API Reference for detailed interface documentation</li> <li>Explore the Contributing Guide for development guidelines</li> <li>Check the Testing Guide for information on testing components</li> </ul>"},{"location":"guides/","title":"Safeguards Guides","text":"<p>This directory contains comprehensive guides for using the Safeguards. Each guide focuses on a specific aspect of the framework and provides detailed explanations, code examples, and best practices.</p>"},{"location":"guides/#available-guides","title":"Available Guides","text":""},{"location":"guides/#budget-management","title":"Budget Management","text":"<p>This guide covers how to effectively manage agent budgets, including: - Creating and configuring budget pools - Allocating resources based on priorities - Implementing dynamic budget allocation - Monitoring and controlling budget usage - Setting up alerts for budget-related events</p>"},{"location":"guides/#safeguards","title":"Safeguards","text":"<p>This guide explains safety features and protection mechanisms, including: - Setting up core safety components - Implementing safety guardrails and action filters - Monitoring agent-generated content - Handling violations and exceptions - Creating safe agents with built-in protections - Emergency response procedures</p>"},{"location":"guides/#monitoring","title":"Monitoring","text":"<p>This guide covers metrics collection, visualization, and alerting, including: - Setting up metrics collection - Creating real-time monitoring systems - Implementing custom monitors and alerts - Visualizing metrics with dashboards - Log analysis and anomaly detection</p>"},{"location":"guides/#agent-coordination","title":"Agent Coordination","text":"<p>This guide explains how to coordinate multiple agents, including: - Multi-agent communication patterns - Priority-based task allocation - Resource sharing between agents - Managing agent dependencies - Implementing agent pipelines</p>"},{"location":"guides/#notifications-alerts","title":"Notifications &amp; Alerts","text":"<p>This guide covers setting up and customizing notification systems, including: - Configuring notification channels - Creating custom alert handlers - Setting up escalation policies - Implementing throttling and filtering - Integrating with external notification systems</p>"},{"location":"guides/#getting-started","title":"Getting Started","text":"<p>If you're new to the Safeguards, we recommend starting with:</p> <ol> <li>The Quick Start Guide for a basic introduction</li> <li>The Budget Management Guide to understand core concepts</li> <li>The Safeguards Guide to learn about protection mechanisms</li> <li>The Monitoring Guide to set up proper observability</li> </ol>"},{"location":"guides/#additional-resources","title":"Additional Resources","text":"<p>For more detailed information, refer to: - API Reference for detailed API documentation - Examples for practical usage examples - Advanced Topics for advanced usage scenarios</p>"},{"location":"guides/agent_coordination/","title":"Agent Coordination Guide","text":"<p>This guide explains how to coordinate multiple agents within the Safeguards, covering communication patterns, resource sharing, and task allocation.</p>"},{"location":"guides/agent_coordination/#introduction-to-agent-coordination","title":"Introduction to Agent Coordination","text":"<p>In multi-agent systems, coordination is essential for: - Efficiently allocating resources among agents - Managing dependencies between agent tasks - Preventing conflicts and contention - Enabling specialized agents to collaborate effectively - Supporting graceful degradation when resources are constrained</p> <p>The Safeguards provides several mechanisms to facilitate agent coordination.</p>"},{"location":"guides/agent_coordination/#basic-multi-agent-setup","title":"Basic Multi-Agent Setup","text":""},{"location":"guides/agent_coordination/#creating-multiple-agents","title":"Creating Multiple Agents","text":"<p>Start by creating different agents with appropriate priorities:</p> <pre><code>from decimal import Decimal\nfrom safeguards.core.budget_coordination import BudgetCoordinator\nfrom safeguards.core.notification_manager import NotificationManager\nfrom safeguards.api import APIFactory, APIVersion\n\n# Setup core components\nnotification_manager = NotificationManager()\nbudget_coordinator = BudgetCoordinator(notification_manager)\napi_factory = APIFactory()\n\n# Create APIs\nbudget_api = api_factory.create_budget_api(APIVersion.V1, budget_coordinator)\nagent_api = api_factory.create_agent_api(APIVersion.V1, budget_coordinator)\n\n# Create agents with different roles and priorities\nresearch_agent = agent_api.create_agent(\n    name=\"research_agent\",\n    initial_budget=Decimal(\"100.0\"),\n    priority=7\n)\n\nanalysis_agent = agent_api.create_agent(\n    name=\"analysis_agent\",\n    initial_budget=Decimal(\"80.0\"),\n    priority=5\n)\n\nsummarization_agent = agent_api.create_agent(\n    name=\"summarization_agent\",\n    initial_budget=Decimal(\"50.0\"),\n    priority=3\n)\n</code></pre>"},{"location":"guides/agent_coordination/#creating-shared-budget-pools","title":"Creating Shared Budget Pools","text":"<p>For resource sharing, create budget pools that agents can draw from:</p> <pre><code># Create shared pools for different agent groups\nhigh_priority_pool = budget_api.create_budget_pool(\n    name=\"high_priority_tasks\",\n    initial_budget=Decimal(\"500.0\"),\n    priority=8\n)\n\ngeneral_pool = budget_api.create_budget_pool(\n    name=\"general_tasks\",\n    initial_budget=Decimal(\"1000.0\"),\n    priority=5\n)\n</code></pre>"},{"location":"guides/agent_coordination/#communication-patterns","title":"Communication Patterns","text":""},{"location":"guides/agent_coordination/#event-based-communication","title":"Event-Based Communication","text":"<p>Implement communication between agents using the notification system:</p> <pre><code>from safeguards.types import AlertSeverity\n\ndef agent_communication_handler(notification):\n    \"\"\"Handle inter-agent communication.\"\"\"\n    if notification.agent_id and notification.metadata.get(\"message_type\") == \"agent_communication\":\n        target_agent_id = notification.metadata.get(\"target_agent_id\")\n        message = notification.metadata.get(\"message\")\n\n        print(f\"Message from {notification.agent_id} to {target_agent_id}: {message}\")\n\n        # Process the message and take action\n        # ...\n\n        return True\n    return False\n\n# Register the handler\nnotification_manager.add_handler(agent_communication_handler)\n\n# Send a message from one agent to another\nnotification_manager.send_alert(\n    agent_id=research_agent.id,\n    severity=AlertSeverity.INFORMATIONAL,\n    message=\"Research results ready for analysis\",\n    metadata={\n        \"message_type\": \"agent_communication\",\n        \"target_agent_id\": analysis_agent.id,\n        \"message\": \"Research complete. Analysis required on data at path /tmp/research_data.json.\"\n    }\n)\n</code></pre>"},{"location":"guides/agent_coordination/#shared-state","title":"Shared State","text":"<p>For more direct coordination, implement a shared state service:</p> <pre><code>from safeguards.coordination.shared_state import SharedStateManager\n\n# Create a shared state manager\nstate_manager = SharedStateManager()\n\n# Agent 1 updates state\nstate_manager.update_state(\n    owner_id=research_agent.id,\n    key=\"research_data\",\n    value={\n        \"status\": \"complete\",\n        \"timestamp\": \"2023-07-26T15:30:00Z\",\n        \"location\": \"/tmp/research_data.json\"\n    }\n)\n\n# Agent 2 reads state\nresearch_data = state_manager.get_state(\n    reader_id=analysis_agent.id,\n    key=\"research_data\"\n)\n\nif research_data and research_data.get(\"status\") == \"complete\":\n    print(f\"Analysis agent processing data from {research_data.get('location')}\")\n    # Process the data\n</code></pre>"},{"location":"guides/agent_coordination/#task-allocation-patterns","title":"Task Allocation Patterns","text":""},{"location":"guides/agent_coordination/#pipeline-pattern","title":"Pipeline Pattern","text":"<p>Implement a sequential processing pipeline where agents perform tasks in order:</p> <pre><code>def run_analysis_pipeline(input_data):\n    \"\"\"Execute a multi-stage pipeline of agent tasks.\"\"\"\n    results = {}\n\n    # Stage 1: Research agent gathers information\n    research_result = research_agent.run(input=input_data)\n    research_cost = research_result.get(\"cost\", Decimal(\"0\"))\n\n    # Update budget\n    budget_api.update_budget(\n        research_agent.id,\n        budget_api.get_budget(research_agent.id) - research_cost\n    )\n    results[\"research\"] = research_result\n\n    # Stage 2: Analysis agent processes research data\n    analysis_result = analysis_agent.run(\n        input=research_result.get(\"output\", \"\")\n    )\n    analysis_cost = analysis_result.get(\"cost\", Decimal(\"0\"))\n\n    # Update budget\n    budget_api.update_budget(\n        analysis_agent.id,\n        budget_api.get_budget(analysis_agent.id) - analysis_cost\n    )\n    results[\"analysis\"] = analysis_result\n\n    # Stage 3: Summarization agent creates final summary\n    summary_result = summarization_agent.run(\n        input=analysis_result.get(\"output\", \"\")\n    )\n    summary_cost = summary_result.get(\"cost\", Decimal(\"0\"))\n\n    # Update budget\n    budget_api.update_budget(\n        summarization_agent.id,\n        budget_api.get_budget(summarization_agent.id) - summary_cost\n    )\n    results[\"summary\"] = summary_result\n\n    return results\n</code></pre>"},{"location":"guides/agent_coordination/#fan-out-pattern","title":"Fan-Out Pattern","text":"<p>Implement parallel processing for independent tasks:</p> <pre><code>import concurrent.futures\nfrom typing import List, Dict, Any\n\ndef run_parallel_tasks(task_inputs: List[str]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Execute multiple independent tasks in parallel.\"\"\"\n    results = []\n\n    # Use a thread pool for concurrent execution\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        # Map tasks to agents\n        futures = [\n            executor.submit(research_agent.run, input=task)\n            for task in task_inputs\n        ]\n\n        # Collect results\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                result = future.result()\n                results.append(result)\n\n                # Update budget after task completion\n                budget_api.update_budget(\n                    research_agent.id,\n                    budget_api.get_budget(research_agent.id) - result.get(\"cost\", Decimal(\"0\"))\n                )\n            except Exception as e:\n                print(f\"Task execution failed: {str(e)}\")\n\n    return results\n</code></pre>"},{"location":"guides/agent_coordination/#resource-sharing","title":"Resource Sharing","text":""},{"location":"guides/agent_coordination/#priority-based-allocation","title":"Priority-Based Allocation","text":"<p>Implement resource allocation based on agent priorities:</p> <pre><code>def allocate_resources_by_priority(agents, available_budget):\n    \"\"\"Allocate resources based on agent priorities.\"\"\"\n    # Sort agents by priority (highest first)\n    sorted_agents = sorted(agents, key=lambda a:\n        budget_coordinator.get_agent_priority(a.id), reverse=True)\n\n    total_priority = sum(budget_coordinator.get_agent_priority(a.id) for a in sorted_agents)\n\n    # Calculate proportional allocation\n    allocations = {}\n    for agent in sorted_agents:\n        priority = budget_coordinator.get_agent_priority(agent.id)\n        proportion = Decimal(priority) / Decimal(total_priority)\n        allocation = available_budget * proportion\n        allocations[agent.id] = allocation\n\n        # Update agent budget\n        budget_api.update_budget(agent.id, allocation)\n\n    return allocations\n</code></pre>"},{"location":"guides/agent_coordination/#dynamic-load-balancing","title":"Dynamic Load Balancing","text":"<p>Implement dynamic reallocation based on agent needs:</p> <pre><code>def balance_agent_resources(pool_id):\n    \"\"\"Balance resources among agents based on current workload.\"\"\"\n    # Get all agents in the pool\n    agents = budget_coordinator.get_pool_agents(pool_id)\n\n    # Calculate workload metrics\n    agent_workloads = {}\n    for agent_id in agents:\n        metrics = metrics_api.get_agent_metrics(agent_id)\n        recent_tasks = metrics.get(\"recent_task_count\", 0)\n        pending_tasks = metrics.get(\"pending_task_count\", 0)\n\n        # Higher value means higher workload\n        workload_score = recent_tasks * 0.3 + pending_tasks * 0.7\n        agent_workloads[agent_id] = workload_score\n\n    # Get total pool budget\n    pool_metrics = metrics_api.get_pool_metrics(pool_id)\n    available_budget = pool_metrics[\"remaining_budget\"]\n\n    # Calculate new allocations\n    total_workload = sum(agent_workloads.values()) or 1  # Avoid division by zero\n    allocations = {}\n\n    for agent_id, workload in agent_workloads.items():\n        # Higher workload gets proportionally more budget\n        proportion = Decimal(workload) / Decimal(total_workload)\n        new_allocation = available_budget * proportion\n\n        # Ensure minimum budget\n        min_budget = Decimal(\"10.0\")\n        allocations[agent_id] = max(new_allocation, min_budget)\n\n        # Apply new budget\n        budget_api.update_budget(agent_id, allocations[agent_id])\n\n    return allocations\n</code></pre>"},{"location":"guides/agent_coordination/#dependency-management","title":"Dependency Management","text":""},{"location":"guides/agent_coordination/#task-dependencies","title":"Task Dependencies","text":"<p>Manage dependencies between agent tasks:</p> <pre><code>from safeguards.coordination.dependency_manager import DependencyManager\n\n# Create a dependency manager\ndependency_manager = DependencyManager()\n\n# Define task dependencies\ndependency_manager.add_dependency(\n    task_id=\"analyze_data\",\n    depends_on=\"gather_data\",\n    agent_id=analysis_agent.id,\n    required_resources=[\"data_file\"]\n)\n\n# Check if dependencies are met\ncan_execute = dependency_manager.check_dependencies(\n    task_id=\"analyze_data\",\n    available_resources=[\"data_file\", \"config\"]\n)\n\nif can_execute:\n    # Execute the task\n    result = analysis_agent.run(task=\"analyze_data\")\nelse:\n    # Handle missing dependencies\n    missing = dependency_manager.get_missing_dependencies(\"analyze_data\")\n    print(f\"Cannot execute task due to missing dependencies: {missing}\")\n</code></pre>"},{"location":"guides/agent_coordination/#agent-coordination-patterns","title":"Agent Coordination Patterns","text":""},{"location":"guides/agent_coordination/#supervisor-pattern","title":"Supervisor Pattern","text":"<p>Implement a supervisor agent that coordinates other agents:</p> <pre><code>from safeguards.types.agent import Agent\nfrom typing import Dict, Any, List\n\nclass SupervisorAgent(Agent):\n    def __init__(self, name, worker_agents=None):\n        super().__init__(name)\n        self.worker_agents = worker_agents or []\n\n    def run(self, **kwargs) -&gt; Dict[str, Any]:\n        \"\"\"Coordinate multiple worker agents.\"\"\"\n        task = kwargs.get(\"task\", \"\")\n\n        # Step 1: Decompose the task\n        subtasks = self._decompose_task(task)\n\n        # Step 2: Assign subtasks to workers\n        assignments = self._assign_subtasks(subtasks)\n\n        # Step 3: Monitor and collect results\n        results = {}\n        for agent_id, subtask in assignments.items():\n            # Find the agent\n            agent = next((a for a in self.worker_agents if a.id == agent_id), None)\n            if agent:\n                result = agent.run(task=subtask)\n                results[agent_id] = result\n\n                # Update budget\n                current_budget = budget_api.get_budget(agent.id)\n                cost = result.get(\"cost\", Decimal(\"0\"))\n                budget_api.update_budget(agent.id, current_budget - cost)\n\n        # Step 4: Combine results\n        final_result = self._combine_results(results)\n\n        return {\n            \"result\": final_result,\n            \"subtask_count\": len(subtasks),\n            \"worker_count\": len(self.worker_agents)\n        }\n\n    def _decompose_task(self, task) -&gt; List[str]:\n        \"\"\"Break a task into subtasks.\"\"\"\n        # Implementation depends on task type\n        return [f\"{task} - part {i}\" for i in range(3)]\n\n    def _assign_subtasks(self, subtasks) -&gt; Dict[str, str]:\n        \"\"\"Assign subtasks to worker agents.\"\"\"\n        assignments = {}\n        for i, subtask in enumerate(subtasks):\n            if i &lt; len(self.worker_agents):\n                agent = self.worker_agents[i]\n                assignments[agent.id] = subtask\n        return assignments\n\n    def _combine_results(self, results) -&gt; Any:\n        \"\"\"Combine results from multiple agents.\"\"\"\n        # Implementation depends on result type\n        combined = \"\"\n        for agent_id, result in results.items():\n            combined += f\"{result.get('output', '')}\\n\"\n        return combined\n</code></pre>"},{"location":"guides/agent_coordination/#reactive-coordination","title":"Reactive Coordination","text":"<p>Implement event-driven coordination between agents:</p> <pre><code># Setup event subscriptions\nagent_events = {\n    \"data_available\": [],\n    \"analysis_complete\": [],\n    \"error_reported\": []\n}\n\ndef subscribe_to_event(agent_id, event_type, callback):\n    \"\"\"Subscribe an agent to an event type.\"\"\"\n    if event_type in agent_events:\n        agent_events[event_type].append({\n            \"agent_id\": agent_id,\n            \"callback\": callback\n        })\n\ndef publish_event(source_agent_id, event_type, data):\n    \"\"\"Publish an event to all subscribers.\"\"\"\n    if event_type in agent_events:\n        for subscriber in agent_events[event_type]:\n            try:\n                subscriber[\"callback\"](source_agent_id, data)\n            except Exception as e:\n                print(f\"Error in event handler: {str(e)}\")\n\n# Example event handler\ndef handle_data_available(source_agent_id, data):\n    \"\"\"Handle data availability events.\"\"\"\n    print(f\"Data available from agent {source_agent_id}\")\n\n    # Trigger analysis agent\n    analysis_result = analysis_agent.run(input=data)\n\n    # Update budget\n    current_budget = budget_api.get_budget(analysis_agent.id)\n    cost = analysis_result.get(\"cost\", Decimal(\"0\"))\n    budget_api.update_budget(analysis_agent.id, current_budget - cost)\n\n    # Publish completion event\n    publish_event(\n        analysis_agent.id,\n        \"analysis_complete\",\n        analysis_result.get(\"output\", \"\")\n    )\n\n# Subscribe analysis agent to data events\nsubscribe_to_event(\n    analysis_agent.id,\n    \"data_available\",\n    handle_data_available\n)\n\n# Research agent publishes event when data is ready\npublish_event(\n    research_agent.id,\n    \"data_available\",\n    {\"data\": \"Sample research data\", \"format\": \"json\"}\n)\n</code></pre>"},{"location":"guides/agent_coordination/#best-practices","title":"Best Practices","text":""},{"location":"guides/agent_coordination/#resource-efficiency","title":"Resource Efficiency","text":"<ul> <li>Prioritize Critical Agents: Ensure critical agents have higher priority</li> <li>Use Shared Pools: Group related agents under shared budget pools</li> <li>Monitor Resource Usage: Track resource consumption across agents</li> <li>Implement Graceful Degradation: Plan for reduced functionality under resource constraints</li> </ul>"},{"location":"guides/agent_coordination/#communication-efficiency","title":"Communication Efficiency","text":"<ul> <li>Minimize Message Size: Keep coordination messages concise</li> <li>Use Appropriate Patterns: Choose the right coordination pattern for your use case</li> <li>Cache Common Data: Avoid redundant data transfers between agents</li> <li>Implement Timeouts: Don't let agents wait indefinitely for responses</li> </ul>"},{"location":"guides/agent_coordination/#error-handling","title":"Error Handling","text":"<ul> <li>Propagate Failures Appropriately: Ensure errors in one agent don't silently break others</li> <li>Implement Circuit Breakers: Stop calling failing agents after repeated errors</li> <li>Plan for Recovery: Design agents to recover from coordination failures</li> <li>Log Coordination Events: Maintain logs for debugging multi-agent interactions</li> </ul>"},{"location":"guides/agent_coordination/#advanced-coordination","title":"Advanced Coordination","text":""},{"location":"guides/agent_coordination/#agent-teams","title":"Agent Teams","text":"<p>Create agent teams for specialized tasks:</p> <pre><code>from safeguards.coordination.team import AgentTeam\n\n# Create a research team\nresearch_team = AgentTeam(\n    name=\"research_team\",\n    agents=[research_agent, analysis_agent, summarization_agent],\n    budget_pool_id=high_priority_pool.id\n)\n\n# Assign team task\nteam_result = research_team.execute_task(\n    task=\"research quantum computing\",\n    coordination_strategy=\"pipeline\"\n)\n</code></pre>"},{"location":"guides/agent_coordination/#dynamic-agent-discovery","title":"Dynamic Agent Discovery","text":"<p>Implement dynamic discovery of available agents:</p> <pre><code>from safeguards.coordination.discovery import AgentDiscoveryService\n\n# Create discovery service\ndiscovery_service = AgentDiscoveryService(budget_coordinator)\n\n# Register agent capabilities\ndiscovery_service.register_capability(\n    agent_id=research_agent.id,\n    capability=\"data_retrieval\",\n    metadata={\"formats\": [\"json\", \"xml\"], \"sources\": [\"web\", \"database\"]}\n)\n\ndiscovery_service.register_capability(\n    agent_id=analysis_agent.id,\n    capability=\"data_analysis\",\n    metadata={\"algorithms\": [\"regression\", \"classification\"], \"formats\": [\"json\"]}\n)\n\n# Find agents with specific capabilities\nanalysis_agents = discovery_service.find_agents_by_capability(\n    capability=\"data_analysis\",\n    required_metadata={\"algorithms\": [\"regression\"]}\n)\n\nif analysis_agents:\n    # Use the first available agent\n    agent_id = analysis_agents[0]\n    print(f\"Using agent {agent_id} for regression analysis\")\n</code></pre>"},{"location":"guides/agent_coordination/#conclusion","title":"Conclusion","text":"<p>Effective agent coordination is essential for building robust multi-agent systems. By implementing appropriate coordination patterns, managing resource sharing, and handling dependencies correctly, you can create systems where agents collaborate effectively while respecting resource constraints.</p> <p>For more information, see: - Budget Management Guide - Safeguards Guide - Monitoring Guide - API Reference</p>"},{"location":"guides/alert_configuration/","title":"Alert Configuration Guide","text":"<p>This guide explains how to set up and configure the alerting system in Safeguards, allowing you to receive notifications for important events, monitor agent activity, and respond to potential issues.</p>"},{"location":"guides/alert_configuration/#alert-system-overview","title":"Alert System Overview","text":"<p>The alerting system in Safeguards provides:</p> <ul> <li>Real-time notifications for important events</li> <li>Multiple severity levels to categorize alerts</li> <li>Configurable notification channels (email, Slack, webhooks)</li> <li>Alert throttling to prevent notification fatigue</li> <li>Customizable alert templates</li> </ul>"},{"location":"guides/alert_configuration/#alert-severity-levels","title":"Alert Severity Levels","text":"<p>Safeguards uses four severity levels for alerts:</p> Severity Description Use Cases <code>INFO</code> Informational messages Task completion, status updates, normal operations <code>WARNING</code> Potential issues that need attention Budget approaching limits, resource usage growing <code>ERROR</code> Problems that require action Failed operations, budget exceeded, resource limits reached <code>CRITICAL</code> Severe issues that need immediate attention System instability, security breaches, severe resource exhaustion"},{"location":"guides/alert_configuration/#basic-alert-setup","title":"Basic Alert Setup","text":""},{"location":"guides/alert_configuration/#creating-the-notification-manager","title":"Creating the Notification Manager","text":"<p>Start by creating a notification manager, which is the central component of the alerting system:</p> <pre><code>from safeguards.notifications.manager import NotificationManager\nfrom safeguards.types import NotificationChannel\n\n# Create notification manager with console logging enabled by default\nnotification_manager = NotificationManager(\n    enabled_channels={NotificationChannel.CONSOLE},\n    cooldown_period=300  # 5 minutes between similar alerts\n)\n</code></pre>"},{"location":"guides/alert_configuration/#sending-basic-alerts","title":"Sending Basic Alerts","text":"<p>Send alerts using the <code>send_alert</code> method:</p> <pre><code>from safeguards.core.alert_types import Alert, AlertSeverity\nfrom datetime import datetime\n\n# Create and send a basic alert\nnotification_manager.send_alert(\n    Alert(\n        title=\"Agent Task Completed\",\n        description=\"Agent has successfully completed its assigned task\",\n        severity=AlertSeverity.INFO,\n        timestamp=datetime.now(),\n        metadata={\"agent_id\": \"agent-123\", \"task_id\": \"task-456\"}\n    )\n)\n\n# Create and send a warning alert\nnotification_manager.send_alert(\n    Alert(\n        title=\"Budget Usage High\",\n        description=\"Agent is approaching its budget limit\",\n        severity=AlertSeverity.WARNING,\n        metadata={\n            \"agent_id\": \"agent-123\",\n            \"budget_used\": 75.5,\n            \"budget_limit\": 100.0,\n            \"usage_percent\": 75.5\n        }\n    )\n)\n</code></pre>"},{"location":"guides/alert_configuration/#configuring-notification-channels","title":"Configuring Notification Channels","text":""},{"location":"guides/alert_configuration/#email-notifications","title":"Email Notifications","text":"<p>Configure email notifications to receive alerts via email:</p> <pre><code># Configure email notifications\nnotification_manager.configure_email(\n    smtp_host=\"smtp.example.com\",\n    smtp_port=587,  # Use 587 for TLS, 465 for SSL\n    username=\"alerts@example.com\",\n    password=\"your-secure-password\",\n    from_addr=\"alerts@example.com\",\n    to_addrs=[\"admin@example.com\", \"team@example.com\"]\n)\n\n# Enable email channel\nnotification_manager.enabled_channels.add(NotificationChannel.EMAIL)\n</code></pre> <p>The email template is customizable and can be found at <code>src/safeguards/templates/email_alert.html</code>. You can provide your own template directory:</p> <pre><code># Use custom templates\nnotification_manager = NotificationManager(\n    template_dir=\"/path/to/your/templates\"\n)\n</code></pre>"},{"location":"guides/alert_configuration/#slack-notifications","title":"Slack Notifications","text":"<p>Configure Slack notifications to receive alerts in your Slack workspace:</p> <pre><code># Configure Slack notifications\nnotification_manager.configure_slack(\n    webhook_url=\"https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK\",\n    channel=\"#alerts\"  # Channel name where alerts will be posted\n)\n\n# Enable Slack channel\nnotification_manager.enabled_channels.add(NotificationChannel.SLACK)\n</code></pre>"},{"location":"guides/alert_configuration/#webhook-notifications","title":"Webhook Notifications","text":"<p>Configure webhook notifications to send alerts to your own API or service:</p> <pre><code># Configure webhook notifications\nnotification_manager.configure_webhook(\n    url=\"https://your-service.example.com/api/alerts\",\n    headers={\n        \"Authorization\": \"Bearer your-api-key\",\n        \"Content-Type\": \"application/json\"\n    }\n)\n\n# Enable webhook channel\nnotification_manager.enabled_channels.add(NotificationChannel.WEBHOOK)\n</code></pre>"},{"location":"guides/alert_configuration/#alert-throttling","title":"Alert Throttling","text":"<p>Alerts with the same title and severity are throttled to prevent notification fatigue. The default cooldown period is 5 minutes (300 seconds), but this can be configured:</p> <pre><code># Configure a shorter cooldown period (60 seconds)\nnotification_manager = NotificationManager(cooldown_period=60)\n\n# Or update it after creation\nnotification_manager.cooldown_period = 120  # 2 minutes\n</code></pre>"},{"location":"guides/alert_configuration/#integration-with-budget-monitoring","title":"Integration with Budget Monitoring","text":"<p>A common use case is to send alerts when an agent's budget usage reaches certain thresholds:</p> <pre><code>from safeguards.monitoring.budget_monitor import BudgetMonitor\n\n# Create a budget monitor with the notification manager\nbudget_monitor = BudgetMonitor(\n    notification_manager=notification_manager,\n    warning_threshold=0.75,  # 75% of budget\n    critical_threshold=0.90  # 90% of budget\n)\n\n# Check budget usage (typically called by the budget coordinator)\nbudget_monitor.check_budget_usage(\n    agent_id=\"agent-123\",\n    used_budget=Decimal(\"75.50\"),\n    total_budget=Decimal(\"100.00\")\n)\n</code></pre> <p>When the budget usage exceeds the warning threshold, a <code>WARNING</code> alert is sent. When it exceeds the critical threshold, a <code>CRITICAL</code> alert is sent.</p>"},{"location":"guides/alert_configuration/#integration-with-resource-monitoring","title":"Integration with Resource Monitoring","text":"<p>Similarly, alerts can be triggered when resource usage exceeds thresholds:</p> <pre><code>from safeguards.monitoring.resource_monitor import ResourceMonitor\n\n# Create a resource monitor with the notification manager\nresource_monitor = ResourceMonitor(\n    notification_manager=notification_manager,\n    cpu_threshold=80.0,  # 80% CPU usage\n    memory_threshold=75.0  # 75% memory usage\n)\n\n# Start monitoring (typically called by the safeguards system)\nresource_monitor.start()\n</code></pre>"},{"location":"guides/alert_configuration/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing how to set up a comprehensive alerting system:</p> <pre><code>from decimal import Decimal\nfrom safeguards.notifications.manager import NotificationManager\nfrom safeguards.types import NotificationChannel\nfrom safeguards.monitoring.budget_monitor import BudgetMonitor\nfrom safeguards.monitoring.resource_monitor import ResourceMonitor\nfrom safeguards.core.alert_types import Alert, AlertSeverity\n\n# 1. Create notification manager with all channels enabled\nnotification_manager = NotificationManager(\n    enabled_channels={\n        NotificationChannel.CONSOLE,\n        NotificationChannel.EMAIL,\n        NotificationChannel.SLACK\n    },\n    cooldown_period=300\n)\n\n# 2. Configure email notifications\nnotification_manager.configure_email(\n    smtp_host=\"smtp.example.com\",\n    smtp_port=587,\n    username=\"alerts@example.com\",\n    password=\"your-secure-password\",\n    from_addr=\"alerts@example.com\",\n    to_addrs=[\"admin@example.com\"]\n)\n\n# 3. Configure Slack notifications\nnotification_manager.configure_slack(\n    webhook_url=\"https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK\",\n    channel=\"#safeguards-alerts\"\n)\n\n# 4. Set up budget monitoring\nbudget_monitor = BudgetMonitor(\n    notification_manager=notification_manager,\n    warning_threshold=0.75,\n    critical_threshold=0.90\n)\n\n# 5. Set up resource monitoring\nresource_monitor = ResourceMonitor(\n    notification_manager=notification_manager,\n    cpu_threshold=80.0,\n    memory_threshold=75.0\n)\n\n# 6. Start resource monitoring\nresource_monitor.start()\n\n# 7. Custom alert for a system event\nnotification_manager.send_alert(\n    Alert(\n        title=\"System Initialization Complete\",\n        description=\"Safeguards system has been successfully initialized\",\n        severity=AlertSeverity.INFO,\n        metadata={\"version\": \"1.0.0\"}\n    )\n)\n</code></pre>"},{"location":"guides/alert_configuration/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Set Appropriate Thresholds: Choose threshold values that balance between too many alerts and too few alerts.</p> </li> <li> <p>Use Descriptive Titles: Make alert titles clear and descriptive to quickly identify issues.</p> </li> <li> <p>Include Relevant Metadata: Add useful context in the metadata to help diagnose and resolve issues.</p> </li> <li> <p>Configure Alert Throttling: Adjust the cooldown period to prevent alert fatigue while ensuring important notifications are received.</p> </li> <li> <p>Monitor Your Alert System: Periodically review alert frequency and adjust thresholds as needed.</p> </li> <li> <p>Secure Credentials: Use environment variables or a secret manager for sensitive information like SMTP passwords and API keys.</p> </li> <li> <p>Test Your Alert Setup: Verify that alerts are being sent correctly for each enabled channel.</p> </li> </ol>"},{"location":"guides/alert_configuration/#troubleshooting","title":"Troubleshooting","text":"<p>If alerts are not being sent:</p> <ol> <li>Check logs for any error messages related to the notification manager.</li> <li>Verify that the appropriate notification channels are enabled.</li> <li>Ensure that credentials for email, Slack, or webhooks are correct.</li> <li>Check if throttling is preventing alerts from being sent too frequently.</li> <li>Verify network connectivity to SMTP servers, Slack API, or webhook endpoints.</li> </ol>"},{"location":"guides/budget_management/","title":"Budget Management Guide","text":"<p>This guide provides a comprehensive overview of budget management features in the Safeguards.</p>"},{"location":"guides/budget_management/#core-concepts","title":"Core Concepts","text":""},{"location":"guides/budget_management/#budget-pools","title":"Budget Pools","text":"<p>Budget pools are containers for resources that can be allocated to agents. Each pool has:</p> <ul> <li>A unique identifier</li> <li>A name for easy reference</li> <li>An initial budget amount</li> <li>A priority level (1-10) that determines resource allocation priority</li> <li>Optional metadata for custom tracking</li> </ul> <pre><code>from decimal import Decimal\nfrom safeguards.core.budget_coordination import BudgetCoordinator\nfrom safeguards.api import APIFactory, APIVersion\n\n# Setup\nnotification_manager = NotificationManager()\nbudget_coordinator = BudgetCoordinator(notification_manager)\napi_factory = APIFactory()\nbudget_api = api_factory.create_budget_api(APIVersion.V1, budget_coordinator)\n\n# Create pools with different priorities\nhigh_priority_pool = budget_api.create_budget_pool(\n    name=\"critical_services\",\n    initial_budget=Decimal(\"1000.0\"),\n    priority=9\n)\n\nmedium_priority_pool = budget_api.create_budget_pool(\n    name=\"standard_services\",\n    initial_budget=Decimal(\"2000.0\"),\n    priority=5\n)\n\nlow_priority_pool = budget_api.create_budget_pool(\n    name=\"background_tasks\",\n    initial_budget=Decimal(\"500.0\"),\n    priority=2\n)\n</code></pre>"},{"location":"guides/budget_management/#agent-budgets","title":"Agent Budgets","text":"<p>Agents consume resources from budget pools. The framework tracks:</p> <ul> <li>Initial budget allocation</li> <li>Current budget level</li> <li>Usage patterns over time</li> <li>Rate of consumption</li> </ul> <pre><code># Create agents with different priorities\ncritical_agent = agent_api.create_agent(\n    name=\"critical_agent\",\n    initial_budget=Decimal(\"200.0\"),\n    priority=8\n)\n\nstandard_agent = agent_api.create_agent(\n    name=\"standard_agent\",\n    initial_budget=Decimal(\"300.0\"),\n    priority=5\n)\n\n# Check budgets\ncritical_budget = budget_api.get_budget(critical_agent.id)\nstandard_budget = budget_api.get_budget(standard_agent.id)\n\nprint(f\"Critical agent budget: {critical_budget}\")\nprint(f\"Standard agent budget: {standard_budget}\")\n</code></pre>"},{"location":"guides/budget_management/#budget-allocation-strategies","title":"Budget Allocation Strategies","text":""},{"location":"guides/budget_management/#fixed-allocation","title":"Fixed Allocation","text":"<p>The simplest approach is to assign fixed budgets to agents:</p> <pre><code>agent = agent_api.create_agent(\n    name=\"fixed_budget_agent\",\n    initial_budget=Decimal(\"100.0\"),\n    priority=5\n)\n</code></pre>"},{"location":"guides/budget_management/#dynamic-allocation","title":"Dynamic Allocation","text":"<p>For more flexibility, implement dynamic allocation based on usage patterns:</p> <pre><code>def allocate_dynamic_budget(agent_id, base_budget, usage_multiplier=1.2):\n    \"\"\"Allocate budget based on recent usage patterns.\"\"\"\n    # Get recent usage metrics\n    usage_history = metrics_api.get_agent_usage_history(\n        agent_id,\n        start_time=\"2023-01-01T00:00:00Z\",\n        end_time=\"2023-01-02T00:00:00Z\"\n    )\n\n    # Calculate average usage\n    if usage_history:\n        total_usage = sum(entry[\"amount\"] for entry in usage_history)\n        avg_usage = total_usage / len(usage_history)\n\n        # Allocate budget based on usage pattern with a buffer\n        new_budget = Decimal(avg_usage) * Decimal(usage_multiplier)\n\n        # Ensure minimum base budget\n        return max(new_budget, Decimal(base_budget))\n\n    # Default to base budget if no history\n    return Decimal(base_budget)\n\n# Apply dynamic allocation\nagent_id = standard_agent.id\nnew_budget = allocate_dynamic_budget(agent_id, \"50.0\")\nbudget_api.update_budget(agent_id, new_budget)\n</code></pre>"},{"location":"guides/budget_management/#priority-based-allocation","title":"Priority-Based Allocation","text":"<p>Prioritize critical agents during resource constraints:</p> <pre><code>def allocate_by_priority(agents, total_available_budget):\n    \"\"\"Allocate budget based on agent priorities.\"\"\"\n    # Sort agents by priority (highest first)\n    sorted_agents = sorted(agents, key=lambda a:\n        budget_coordinator.get_agent_priority(a.id), reverse=True)\n\n    remaining_budget = Decimal(total_available_budget)\n    allocations = {}\n\n    # First pass: ensure minimum allocations for critical agents\n    for agent in sorted_agents:\n        priority = budget_coordinator.get_agent_priority(agent.id)\n        if priority &gt;= 8:  # Critical priority\n            min_allocation = Decimal(\"50.0\")  # Minimum for critical agents\n            allocations[agent.id] = min_allocation\n            remaining_budget -= min_allocation\n\n    # Second pass: allocate remaining budget proportionally by priority\n    if remaining_budget &gt; Decimal(\"0\"):\n        total_weights = sum(budget_coordinator.get_agent_priority(a.id)\n                            for a in sorted_agents)\n\n        for agent in sorted_agents:\n            if agent.id not in allocations:\n                # Non-critical agents get proportional allocation\n                priority = budget_coordinator.get_agent_priority(agent.id)\n                proportion = Decimal(priority) / Decimal(total_weights)\n                allocation = remaining_budget * proportion\n                allocations[agent.id] = allocation\n\n    # Apply allocations\n    for agent_id, allocation in allocations.items():\n        budget_api.update_budget(agent_id, allocation)\n\n    return allocations\n</code></pre>"},{"location":"guides/budget_management/#budget-monitoring-and-control","title":"Budget Monitoring and Control","text":""},{"location":"guides/budget_management/#tracking-usage","title":"Tracking Usage","text":"<p>Monitor budget consumption in real-time:</p> <pre><code>def monitor_budget_usage(agent_id):\n    \"\"\"Monitor agent budget usage.\"\"\"\n    # Get current metrics\n    metrics = metrics_api.get_agent_metrics(agent_id)\n\n    # Calculate usage rate\n    initial = metrics[\"initial_budget\"]\n    remaining = metrics[\"remaining_budget\"]\n    used = metrics[\"used_budget\"]\n\n    usage_percentage = (used / initial) * 100 if initial &gt; 0 else 0\n\n    print(f\"Agent {agent_id} budget usage:\")\n    print(f\"  Initial: {initial}\")\n    print(f\"  Used: {used} ({usage_percentage:.2f}%)\")\n    print(f\"  Remaining: {remaining}\")\n\n    # Check if budget is running low\n    if usage_percentage &gt; 80:\n        print(\"  WARNING: Budget usage high (&gt;80%)\")\n\n    return metrics\n</code></pre>"},{"location":"guides/budget_management/#setting-spending-limits","title":"Setting Spending Limits","text":"<p>Implement spending limits to prevent overconsumption:</p> <pre><code>from safeguards.types import ViolationType, AlertSeverity\n\ndef set_spending_limit(agent_id, limit_amount):\n    \"\"\"Set a spending limit for an agent.\"\"\"\n    # Get current budget\n    current_budget = budget_api.get_budget(agent_id)\n\n    # Create a custom monitor function\n    def monitor_spending(agent_id, amount):\n        if amount &gt; limit_amount:\n            # Report violation\n            violation_reporter.report_violation(\n                agent_id=agent_id,\n                violation_type=ViolationType.BUDGET_LIMIT_EXCEEDED,\n                severity=AlertSeverity.MEDIUM,\n                message=f\"Agent exceeded spending limit of {limit_amount}\",\n                details={\n                    \"limit\": limit_amount,\n                    \"spent\": amount,\n                    \"overage\": amount - limit_amount\n                }\n            )\n            return False\n        return True\n\n    # Register monitor with the budget coordinator\n    budget_coordinator.register_budget_monitor(agent_id, monitor_spending)\n\n    return limit_amount\n</code></pre>"},{"location":"guides/budget_management/#budget-alerts","title":"Budget Alerts","text":"<p>Set up notifications for budget-related events:</p> <pre><code>def setup_budget_alerts(threshold_percentage=15):\n    \"\"\"Set up budget alerts when agents approach depletion.\"\"\"\n    def low_budget_alert(agent_id, current_budget, initial_budget):\n        # Calculate percentage remaining\n        percentage = (current_budget / initial_budget) * 100 if initial_budget &gt; 0 else 0\n\n        if percentage &lt;= threshold_percentage:\n            # Generate alert\n            violation_reporter.report_violation(\n                agent_id=agent_id,\n                violation_type=ViolationType.LOW_BUDGET,\n                severity=AlertSeverity.MEDIUM,\n                message=f\"Agent budget below {threshold_percentage}% threshold\",\n                details={\n                    \"current_budget\": current_budget,\n                    \"initial_budget\": initial_budget,\n                    \"percentage_remaining\": percentage\n                }\n            )\n            return True\n        return False\n\n    # Register with each agent\n    agent_ids = budget_coordinator.get_all_agent_ids()\n    for agent_id in agent_ids:\n        budget_coordinator.register_budget_monitor(\n            agent_id,\n            lambda a_id, amount: low_budget_alert(\n                a_id,\n                amount,\n                budget_coordinator.get_agent_metrics(a_id)[\"initial_budget\"]\n            )\n        )\n</code></pre>"},{"location":"guides/budget_management/#advanced-budget-management","title":"Advanced Budget Management","text":""},{"location":"guides/budget_management/#emergency-budget-allocation","title":"Emergency Budget Allocation","text":"<p>Handle emergency budget needs:</p> <pre><code>def handle_emergency_allocation(agent_id, requested_amount, reason):\n    \"\"\"Request emergency budget allocation for an agent.\"\"\"\n    current_metrics = metrics_api.get_agent_metrics(agent_id)\n    agent_priority = budget_coordinator.get_agent_priority(agent_id)\n\n    # Determine if emergency allocation is justified\n    if agent_priority &gt;= 7:  # High priority agent\n        print(f\"Approving emergency allocation for high-priority agent {agent_id}\")\n        # Approve full amount\n        approved_amount = requested_amount\n    elif \"critical\" in reason.lower():\n        print(f\"Approving partial emergency allocation due to critical reason\")\n        # Approve partial amount\n        approved_amount = requested_amount * Decimal(\"0.5\")\n    else:\n        print(f\"Denying emergency allocation for low-priority non-critical request\")\n        # Deny request\n        approved_amount = Decimal(\"0\")\n\n    if approved_amount &gt; Decimal(\"0\"):\n        # Update budget\n        new_budget = current_metrics[\"remaining_budget\"] + approved_amount\n        budget_api.update_budget(agent_id, new_budget)\n        print(f\"Emergency allocation complete: {approved_amount} added to agent {agent_id}\")\n\n    return approved_amount\n</code></pre>"},{"location":"guides/budget_management/#budget-rebalancing","title":"Budget Rebalancing","text":"<p>Implement automated budget rebalancing across agents:</p> <pre><code>def rebalance_agent_budgets(pool_id):\n    \"\"\"Rebalance budgets among agents in a pool based on priorities and usage.\"\"\"\n    # Get all agents in the pool\n    pool_agents = budget_coordinator.get_pool_agents(pool_id)\n\n    # Get total remaining budget in the pool\n    pool_metrics = metrics_api.get_pool_metrics(pool_id)\n    total_remaining = pool_metrics[\"remaining_budget\"]\n\n    # Calculate priority-weighted allocation\n    agent_priorities = {\n        agent_id: budget_coordinator.get_agent_priority(agent_id)\n        for agent_id in pool_agents\n    }\n\n    # Adjust based on recent usage patterns\n    usage_weights = {}\n    for agent_id in pool_agents:\n        usage = metrics_api.get_agent_usage_history(\n            agent_id,\n            start_time=\"2023-01-01T00:00:00Z\",\n            end_time=\"2023-01-02T00:00:00Z\"\n        )\n\n        if usage:\n            # Calculate average hourly usage\n            total_usage = sum(entry[\"amount\"] for entry in usage)\n            usage_weights[agent_id] = total_usage / len(usage)\n        else:\n            # Default weight if no usage history\n            usage_weights[agent_id] = Decimal(\"1.0\")\n\n    # Combine priority and usage factors for final allocation\n    allocation_weights = {}\n    total_weight = Decimal(\"0\")\n\n    for agent_id in pool_agents:\n        # Combine priority (70% weight) and usage (30% weight)\n        weight = (Decimal(agent_priorities[agent_id]) * Decimal(\"0.7\") +\n                  usage_weights[agent_id] * Decimal(\"0.3\"))\n        allocation_weights[agent_id] = weight\n        total_weight += weight\n\n    # Calculate and apply new budgets\n    new_allocations = {}\n    for agent_id, weight in allocation_weights.items():\n        proportion = weight / total_weight if total_weight &gt; 0 else 0\n        new_budget = total_remaining * proportion\n        budget_api.update_budget(agent_id, new_budget)\n        new_allocations[agent_id] = new_budget\n\n    return new_allocations\n</code></pre>"},{"location":"guides/budget_management/#best-practices","title":"Best Practices","text":""},{"location":"guides/budget_management/#tracking-and-logging","title":"Tracking and Logging","text":"<p>Implement comprehensive logging of budget changes:</p> <pre><code>import logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(\"budget_management.log\"),\n        logging.StreamHandler()\n    ]\n)\n\ndef log_budget_change(agent_id, old_budget, new_budget, reason):\n    \"\"\"Log budget changes with detailed information.\"\"\"\n    change_amount = new_budget - old_budget\n    agent_priority = budget_coordinator.get_agent_priority(agent_id)\n\n    logging.info(\n        f\"Budget change for agent {agent_id} (priority {agent_priority}): \"\n        f\"{old_budget} \u2192 {new_budget} ({change_amount:+}). \"\n        f\"Reason: {reason}\"\n    )\n\n    # Also store in database or metrics system\n    metrics_api.record_budget_change(\n        agent_id=agent_id,\n        old_budget=old_budget,\n        new_budget=new_budget,\n        change_amount=change_amount,\n        timestamp=datetime.now().isoformat(),\n        reason=reason\n    )\n</code></pre>"},{"location":"guides/budget_management/#regular-budget-reviews","title":"Regular Budget Reviews","text":"<p>Implement systematic budget review processes:</p> <pre><code>def scheduled_budget_review(frequency_hours=24):\n    \"\"\"Schedule regular budget reviews.\"\"\"\n    def review_budgets():\n        # Get all agents\n        all_agent_metrics = metrics_api.get_all_agent_metrics()\n\n        # Identify potential issues\n        for agent_id, metrics in all_agent_metrics.items():\n            initial = metrics[\"initial_budget\"]\n            remaining = metrics[\"remaining_budget\"]\n\n            # Check for severely underused budgets\n            if remaining &gt; initial * Decimal(\"0.9\"):\n                logging.info(f\"Agent {agent_id} using less than 10% of budget - consider reducing\")\n\n            # Check for nearly depleted budgets\n            if remaining &lt; initial * Decimal(\"0.1\"):\n                logging.warning(f\"Agent {agent_id} budget nearly depleted - consider increasing\")\n\n        # Review budget pools\n        all_pool_metrics = metrics_api.get_all_pool_metrics()\n        for pool_id, metrics in all_pool_metrics.items():\n            # Check pool health\n            if metrics[\"remaining_budget\"] &lt; metrics[\"initial_budget\"] * Decimal(\"0.2\"):\n                logging.warning(f\"Pool {pool_id} below 20% remaining - consider rebalancing\")\n\n    # Schedule the review (implementation depends on scheduling system)\n    # schedule.every(frequency_hours).hours.do(review_budgets)\n\n    return \"Budget review scheduled every {frequency_hours} hours\"\n</code></pre>"},{"location":"guides/budget_management/#graceful-degradation","title":"Graceful Degradation","text":"<p>Implement strategies for handling budget depletion:</p> <pre><code>def setup_graceful_degradation(agent_id, service_levels):\n    \"\"\"Configure agent for graceful degradation as budget depletes.\"\"\"\n    # Service levels example:\n    # {\n    #   \"full\": {\"min_percentage\": 50, \"features\": [\"high_quality\", \"all_capabilities\"]},\n    #   \"standard\": {\"min_percentage\": 20, \"features\": [\"medium_quality\", \"core_capabilities\"]},\n    #   \"minimal\": {\"min_percentage\": 5, \"features\": [\"low_quality\", \"basic_capabilities\"]},\n    #   \"emergency\": {\"min_percentage\": 0, \"features\": [\"text_only\", \"critical_only\"]}\n    # }\n\n    def determine_service_level(current_budget, initial_budget):\n        if initial_budget &lt;= 0:\n            return \"emergency\"\n\n        percentage = (current_budget / initial_budget) * 100\n\n        for level, config in sorted(\n            service_levels.items(),\n            key=lambda x: x[1][\"min_percentage\"],\n            reverse=True\n        ):\n            if percentage &gt;= config[\"min_percentage\"]:\n                return level\n\n        return \"emergency\"\n\n    # Store the configuration with the agent\n    budget_coordinator.store_agent_metadata(\n        agent_id,\n        {\n            \"service_levels\": service_levels,\n            \"service_level_func\": determine_service_level\n        }\n    )\n\n    # Example usage in agent implementation:\n    # def run(self, **kwargs):\n    #     # Get current metrics\n    #     metrics = metrics_api.get_agent_metrics(self.id)\n    #\n    #     # Get service level function\n    #     metadata = budget_coordinator.get_agent_metadata(self.id)\n    #     service_level_func = metadata.get(\"service_level_func\")\n    #\n    #     if service_level_func:\n    #         level = service_level_func(\n    #             metrics[\"remaining_budget\"],\n    #             metrics[\"initial_budget\"]\n    #         )\n    #         features = metadata[\"service_levels\"][level][\"features\"]\n    #\n    #         # Adjust behavior based on available features\n    #         # ...\n\n    return f\"Graceful degradation configured for agent {agent_id}\"\n</code></pre>"},{"location":"guides/budget_management/#conclusion","title":"Conclusion","text":"<p>Effective budget management is critical for building safe, reliable agent systems. By implementing the strategies outlined in this guide, you can ensure that your agents operate within resource constraints while prioritizing high-value activities.</p> <p>For more information, see the API Reference and Example Implementations.</p>"},{"location":"guides/guardrails/","title":"Safety Guardrails Guide","text":"<p>This guide explains how to implement and use safety guardrails in the Safeguards, providing protection mechanisms for your agent systems.</p>"},{"location":"guides/guardrails/#introduction-to-safety-guardrails","title":"Introduction to Safety Guardrails","text":"<p>Safety guardrails are preventative mechanisms that constrain agent behavior within safe operational boundaries. They:</p> <ul> <li>Proactively monitor agent actions before execution</li> <li>Enforce predefined safety constraints</li> <li>Prevent potentially harmful operations</li> <li>Provide fallback mechanisms when violations occur</li> <li>Create audit trails of safety-critical decisions</li> </ul> <p>The Safeguards offers several types of guardrails for different safety concerns.</p>"},{"location":"guides/guardrails/#core-guardrail-types","title":"Core Guardrail Types","text":""},{"location":"guides/guardrails/#budget-guardrails","title":"Budget Guardrails","text":"<p>Budget guardrails prevent agents from exceeding their allocated resources:</p> <pre><code>from decimal import Decimal\nfrom safeguards.guardrails.budget import BudgetGuardrail\nfrom safeguards.types.agent import Agent\nfrom safeguards.budget.manager import BudgetManager\n\n# Create a budget manager\nbudget_manager = BudgetManager(\n    agent_id=\"agent123\",\n    initial_budget=Decimal(\"100.0\")\n)\n\n# Create a budget guardrail\nbudget_guardrail = BudgetGuardrail(budget_manager)\n\n# Example of using the guardrail\ndef process_request(agent, input_data, expected_cost):\n    \"\"\"Process a request with budget safety checks.\"\"\"\n    # Check if sufficient budget\n    if not budget_guardrail.validate(expected_cost):\n        return {\n            \"status\": \"error\",\n            \"message\": \"Insufficient budget to perform operation\",\n            \"remaining_budget\": budget_manager.get_remaining_budget()\n        }\n\n    try:\n        # Process the request\n        result = agent.run(input=input_data)\n\n        # Update budget usage\n        actual_cost = result.get(\"cost\", Decimal(\"0\"))\n        budget_manager.record_cost(actual_cost)\n\n        return {\n            \"status\": \"success\",\n            \"result\": result,\n            \"remaining_budget\": budget_manager.get_remaining_budget()\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Error during processing: {str(e)}\",\n            \"remaining_budget\": budget_manager.get_remaining_budget()\n        }\n</code></pre>"},{"location":"guides/guardrails/#resource-guardrails","title":"Resource Guardrails","text":"<p>Resource guardrails prevent excessive CPU, memory, or disk usage:</p> <pre><code>from safeguards.guardrails.resource import ResourceGuardrail\nfrom safeguards.monitoring.resource_monitor import ResourceMonitor\n\n# Create a resource monitor\nresource_monitor = ResourceMonitor(\n    agent_id=\"agent123\",\n    thresholds={\n        \"cpu_percent\": 80,\n        \"memory_percent\": 70,\n        \"disk_usage_gb\": 10\n    }\n)\n\n# Create a resource guardrail\nresource_guardrail = ResourceGuardrail(resource_monitor)\n\n# Example of using the guardrail\ndef perform_resource_intensive_task(agent, task_params):\n    \"\"\"Perform a resource-intensive task with safety checks.\"\"\"\n    # Validate resource availability before executing\n    validation_result = resource_guardrail.validate()\n\n    if not validation_result.is_valid:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Resource check failed: {validation_result.message}\",\n            \"details\": validation_result.details\n        }\n\n    # Execute the task with guardrail protection\n    try:\n        result = resource_guardrail.run(\n            agent.run,\n            input=task_params,\n            metadata={\"task_type\": \"resource_intensive\"}\n        )\n        return {\n            \"status\": \"success\",\n            \"result\": result\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Task execution failed: {str(e)}\"\n        }\n</code></pre>"},{"location":"guides/guardrails/#security-guardrails","title":"Security Guardrails","text":"<p>Security guardrails prevent unauthorized access and operations:</p> <pre><code>from safeguards.security.auth import SecurityManager, Permission, Role\nfrom safeguards.types.guardrail import SecurityGuardrail\n\n# Create a security manager\nsecurity_manager = SecurityManager()\n\n# Set up roles and permissions\nsecurity_manager.add_role(\"data_processor\", [\n    Permission.READ_DATA,\n    Permission.PROCESS_DATA\n])\n\nsecurity_manager.add_role(\"admin\", [\n    Permission.READ_DATA,\n    Permission.PROCESS_DATA,\n    Permission.MODIFY_SYSTEM,\n    Permission.MANAGE_USERS\n])\n\n# Register an identity\nsecurity_manager.register_identity(\n    identity_id=\"agent123\",\n    roles=[\"data_processor\"]\n)\n\n# Create a security guardrail\nsecurity_guardrail = SecurityGuardrail(\n    security_manager=security_manager,\n    required_permissions=[Permission.PROCESS_DATA]\n)\n\n# Example of using the guardrail\ndef protected_operation(agent_id, operation, data):\n    \"\"\"Perform an operation with security guardrail protection.\"\"\"\n    try:\n        # Run the operation through the security guardrail\n        result = security_guardrail.run(\n            lambda: process_data(operation, data),\n            identity_id=agent_id,\n            metadata={\"operation\": operation}\n        )\n        return {\n            \"status\": \"success\",\n            \"result\": result\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Security constraint violation: {str(e)}\"\n        }\n\ndef process_data(operation, data):\n    \"\"\"Process data based on the operation type.\"\"\"\n    # Implementation would go here\n    return {\"processed\": True, \"operation\": operation}\n</code></pre>"},{"location":"guides/guardrails/#creating-custom-guardrails","title":"Creating Custom Guardrails","text":"<p>You can create custom guardrails for specific needs:</p> <pre><code>from typing import Any, Dict, Optional, Callable\nfrom safeguards.types.guardrail import Guardrail, ValidationResult\n\nclass CustomGuardrail(Guardrail):\n    \"\"\"A custom guardrail implementation.\"\"\"\n\n    def __init__(self, validation_fn: Callable):\n        self.validation_fn = validation_fn\n\n    def validate(self, *args, **kwargs) -&gt; ValidationResult:\n        \"\"\"Validate using the custom validation function.\"\"\"\n        is_valid, message = self.validation_fn(*args, **kwargs)\n\n        return ValidationResult(\n            is_valid=is_valid,\n            message=message,\n            details={\"guardrail_type\": \"custom\"}\n        )\n\n    def run(self, fn: Callable, *args, **kwargs) -&gt; Any:\n        \"\"\"Run a function with the guardrail applied.\"\"\"\n        # Validate before execution\n        validation_result = self.validate(*args, **kwargs)\n\n        if not validation_result.is_valid:\n            raise ValueError(f\"Guardrail validation failed: {validation_result.message}\")\n\n        # Execute the function\n        return fn(*args, **kwargs)\n\n# Example custom validation function\ndef validate_input_complexity(input_text: str) -&gt; tuple[bool, str]:\n    \"\"\"Validate that input text isn't too complex.\"\"\"\n    word_count = len(input_text.split())\n\n    if word_count &gt; 1000:\n        return False, f\"Input too complex: {word_count} words exceeds 1000 word limit\"\n\n    return True, \"Input complexity acceptable\"\n\n# Create a custom guardrail\ncomplexity_guardrail = CustomGuardrail(validate_input_complexity)\n\n# Use the guardrail\ndef process_text_safely(agent, text):\n    \"\"\"Process text with complexity guardrail.\"\"\"\n    try:\n        result = complexity_guardrail.run(\n            agent.run,\n            input=text\n        )\n        return result\n    except ValueError as e:\n        return {\n            \"error\": str(e),\n            \"suggestion\": \"Please simplify your input\"\n        }\n</code></pre>"},{"location":"guides/guardrails/#combining-multiple-guardrails","title":"Combining Multiple Guardrails","text":"<p>For comprehensive safety, combine multiple guardrails:</p> <pre><code>from safeguards.types.guardrail import CompositeGuardrail\n\n# Create a composite guardrail\ncomposite_guardrail = CompositeGuardrail([\n    budget_guardrail,\n    resource_guardrail,\n    security_guardrail,\n    complexity_guardrail\n])\n\n# Use the composite guardrail\ndef safe_agent_execution(agent, input_data, agent_id, expected_cost):\n    \"\"\"Execute agent with multiple safety guardrails.\"\"\"\n    try:\n        # All guardrails will be checked in sequence\n        result = composite_guardrail.run(\n            agent.run,\n            input=input_data,\n            identity_id=agent_id,\n            expected_cost=expected_cost\n        )\n        return {\n            \"status\": \"success\",\n            \"result\": result\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Guardrail violation: {str(e)}\"\n        }\n</code></pre>"},{"location":"guides/guardrails/#guardrail-policies","title":"Guardrail Policies","text":"<p>Define guardrail policies to apply consistent safety measures:</p> <pre><code>from safeguards.rules.base import RuleSet, Rule\nfrom safeguards.types.guardrail import PolicyGuardrail\n\n# Define rules\nbudget_rule = Rule(\n    name=\"budget_limit\",\n    description=\"Limit budget usage per request\",\n    validator=lambda ctx: ctx.get(\"expected_cost\", 0) &lt;= 10.0,\n    error_message=\"Request exceeds maximum budget of 10.0\"\n)\n\nsecurity_rule = Rule(\n    name=\"authorized_operation\",\n    description=\"Ensure operation is authorized\",\n    validator=lambda ctx: ctx.get(\"operation\") in [\"read\", \"analyze\", \"summarize\"],\n    error_message=\"Operation not permitted\"\n)\n\nresource_rule = Rule(\n    name=\"resource_limit\",\n    description=\"Limit resource usage\",\n    validator=lambda ctx: ctx.get(\"resource_intensive\", False) is False,\n    error_message=\"Resource intensive operations not allowed\"\n)\n\n# Create a rule set\nrule_set = RuleSet(\"safeguards_policy\")\nrule_set.add_rule(budget_rule)\nrule_set.add_rule(security_rule)\nrule_set.add_rule(resource_rule)\n\n# Create a policy guardrail\npolicy_guardrail = PolicyGuardrail(rule_set)\n\n# Use the policy guardrail\ndef execute_with_policy(agent, input_data, context):\n    \"\"\"Execute agent with policy guardrail.\"\"\"\n    try:\n        result = policy_guardrail.run(\n            agent.run,\n            input=input_data,\n            context=context\n        )\n        return {\n            \"status\": \"success\",\n            \"result\": result\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": f\"Policy violation: {str(e)}\"\n        }\n</code></pre>"},{"location":"guides/guardrails/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>Implement circuit breakers to prevent repeated failures:</p> <pre><code>from safeguards.types.guardrail import CircuitBreakerGuardrail\n\n# Create a circuit breaker\ncircuit_breaker = CircuitBreakerGuardrail(\n    failure_threshold=3,\n    reset_timeout_seconds=300  # 5 minutes\n)\n\n# Use the circuit breaker\ndef call_service_safely(service_fn, *args, **kwargs):\n    \"\"\"Call a service with circuit breaker protection.\"\"\"\n    try:\n        result = circuit_breaker.run(service_fn, *args, **kwargs)\n        return result\n    except Exception as e:\n        if \"circuit open\" in str(e):\n            return {\n                \"status\": \"error\",\n                \"message\": \"Service temporarily unavailable, please try again later\",\n                \"circuit_status\": \"open\"\n            }\n        else:\n            return {\n                \"status\": \"error\",\n                \"message\": f\"Service error: {str(e)}\",\n                \"circuit_status\": \"closed\"\n            }\n</code></pre>"},{"location":"guides/guardrails/#monitoring-guardrail-activity","title":"Monitoring Guardrail Activity","text":"<p>Track guardrail interventions:</p> <pre><code>from safeguards.monitoring.violation_reporter import ViolationReporter\nfrom safeguards.core.notification_manager import NotificationManager\nfrom safeguards.types import ViolationType, AlertSeverity\n\n# Create required components\nnotification_manager = NotificationManager()\nviolation_reporter = ViolationReporter(notification_manager)\n\n# Create a monitored guardrail\nclass MonitoredGuardrail(Guardrail):\n    \"\"\"A guardrail that reports violations.\"\"\"\n\n    def __init__(self, inner_guardrail, violation_reporter, agent_id):\n        self.inner_guardrail = inner_guardrail\n        self.violation_reporter = violation_reporter\n        self.agent_id = agent_id\n\n    def validate(self, *args, **kwargs) -&gt; ValidationResult:\n        \"\"\"Validate and report if invalid.\"\"\"\n        result = self.inner_guardrail.validate(*args, **kwargs)\n\n        if not result.is_valid:\n            # Report the violation\n            self.violation_reporter.report_violation(\n                agent_id=self.agent_id,\n                violation_type=ViolationType.GUARDRAIL_VIOLATION,\n                severity=AlertSeverity.HIGH,\n                message=result.message,\n                details={\n                    \"guardrail_type\": self.inner_guardrail.__class__.__name__,\n                    \"validation_details\": result.details\n                }\n            )\n\n        return result\n\n    def run(self, fn, *args, **kwargs):\n        \"\"\"Run with validation and violation reporting.\"\"\"\n        try:\n            return self.inner_guardrail.run(fn, *args, **kwargs)\n        except Exception as e:\n            # Report the runtime violation\n            self.violation_reporter.report_violation(\n                agent_id=self.agent_id,\n                violation_type=ViolationType.GUARDRAIL_VIOLATION,\n                severity=AlertSeverity.HIGH,\n                message=str(e),\n                details={\n                    \"guardrail_type\": self.inner_guardrail.__class__.__name__,\n                    \"exception_type\": e.__class__.__name__\n                }\n            )\n            raise\n\n# Wrap an existing guardrail\nmonitored_guardrail = MonitoredGuardrail(\n    budget_guardrail,\n    violation_reporter,\n    \"agent123\"\n)\n</code></pre>"},{"location":"guides/guardrails/#best-practices","title":"Best Practices","text":""},{"location":"guides/guardrails/#design-principles","title":"Design Principles","text":"<ol> <li>Be Specific: Define clear, narrow constraints for each guardrail</li> <li>Defense in Depth: Use multiple complementary guardrails</li> <li>Fail Safely: Ensure guardrails default to conservative behavior</li> <li>Provide Context: Include helpful error messages and recovery suggestions</li> <li>Monitor Interventions: Track when guardrails prevent actions</li> </ol>"},{"location":"guides/guardrails/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Start Simple: Begin with basic guardrails before adding complexity</li> <li>Test Thoroughly: Verify guardrails block problematic scenarios</li> <li>Minimize Performance Impact: Optimize validation for fast execution</li> <li>Include Emergencies: Create methods to override guardrails in emergencies</li> <li>Document Expectations: Make guardrail behaviors clear to users</li> </ol>"},{"location":"guides/guardrails/#conclusion","title":"Conclusion","text":"<p>Safety guardrails are a powerful way to ensure agent systems operate within defined boundaries. By combining different types of guardrails, you can create comprehensive safety systems that prevent misuse, protect resources, and ensure security.</p> <p>For more information, see: - Budget Management for budget constraint details - Security Guide for security policy information - Monitoring Guide for tracking guardrail effectiveness</p>"},{"location":"guides/human_in_loop/","title":"Human-in-the-Loop Workflows","text":"<p>The Safeguards library provides robust support for human-in-the-loop (HITL) workflows, allowing agents to request human approval, feedback, or modifications before proceeding with sensitive or high-risk actions.</p>"},{"location":"guides/human_in_loop/#overview","title":"Overview","text":"<p>Human-in-the-loop functionality in Safeguards consists of these key components:</p> <ol> <li>Notification Channels: Different ways to communicate with humans (email, Slack, custom webhooks)</li> <li>Human Action Handling: Workflow for requesting and processing human approvals</li> <li>Action Responses: Processing approvals, rejections, or modifications from humans</li> </ol>"},{"location":"guides/human_in_loop/#setting-up-notification-channels","title":"Setting Up Notification Channels","text":"<p>Before using HITL workflows, you need to set up appropriate notification channels:</p> <pre><code>from safeguards.core.notification_manager import NotificationManager\nfrom safeguards.notifications.channels import HumanInTheLoopChannel, SlackChannel, EmailChannel\n\n# Create notification manager\nnotification_manager = NotificationManager()\n\n# Set up a human-in-the-loop channel\nhitl_channel = HumanInTheLoopChannel()\nhitl_channel.initialize({\n    \"webhook_url\": \"https://your-approval-endpoint.com/api\",\n    \"api_key\": \"your_api_key\",\n    \"timeout_seconds\": 300,  # 5 minutes timeout\n    \"poll_interval\": 5  # Check for responses every 5 seconds\n})\n\n# Register the channel\nnotification_manager.register_channel(\"human_approvals\", hitl_channel)\n\n# You can also set up other channels\nslack_channel = SlackChannel()\nslack_channel.initialize({\n    \"webhook_url\": \"https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK\",\n    \"channel\": \"#agent-alerts\",\n    \"username\": \"SafeguardsBot\"\n})\nnotification_manager.register_channel(\"slack_alerts\", slack_channel)\n</code></pre>"},{"location":"guides/human_in_loop/#creating-a-human-action-handler","title":"Creating a Human Action Handler","text":"<p>Once you have the notification channels set up, you can create a Human Action Handler:</p> <pre><code>from safeguards.human_action import HumanActionHandler\n\n# Create the action handler with the HITL channel\naction_handler = HumanActionHandler(hitl_channel)\n\n# Set a default timeout (optional)\naction_handler.set_timeout(120)  # 2 minute timeout\n</code></pre>"},{"location":"guides/human_in_loop/#requesting-human-approval","title":"Requesting Human Approval","text":"<p>Now you can request human approvals for agent actions:</p> <pre><code># Define action details\naction = action_handler.request_action(\n    title=\"Approve High-Value Transaction\",\n    description=(\n        f\"Agent financial_advisor is requesting approval for a \"\n        f\"$2500.00 transaction:\\n\"\n        f\"Large investment purchase\\n\\n\"\n        f\"This exceeds the agent's transaction limit of $1000.00.\"\n    ),\n    agent_id=\"financial_advisor\",\n    metadata={\n        \"action_type\": \"transaction\",\n        \"amount\": \"2500.00\",\n        \"description\": \"Large investment purchase\"\n    }\n)\n\n# Wait for human response (blocking)\nstatus = action_handler.wait_for_action(action)\n\nif status == ActionStatus.APPROVED:\n    print(\"Action was approved!\")\n    # Execute the action\nelif status == ActionStatus.MODIFIED:\n    print(f\"Action was modified: {action.response_data}\")\n    # Execute with modifications\nelif status == ActionStatus.REJECTED:\n    print(f\"Action was rejected: {action.comments}\")\n    # Handle rejection\nelif status == ActionStatus.TIMED_OUT:\n    print(\"Action timed out waiting for human response\")\n    # Handle timeout\n</code></pre>"},{"location":"guides/human_in_loop/#handling-human-responses","title":"Handling Human Responses","text":"<p>You can also use a non-blocking approach with callbacks:</p> <pre><code>def handle_response(action):\n    \"\"\"Called when the human responds to the action.\"\"\"\n    if action.status == ActionStatus.APPROVED:\n        print(f\"Action {action.title} was approved!\")\n        # Execute the action\n    elif action.status == ActionStatus.MODIFIED:\n        print(f\"Action {action.title} was modified: {action.response_data}\")\n        # Execute with modifications\n    elif action.status == ActionStatus.REJECTED:\n        print(f\"Action {action.title} was rejected: {action.comments}\")\n        # Handle rejection\n    elif action.status == ActionStatus.TIMED_OUT:\n        print(f\"Action {action.title} timed out\")\n        # Handle timeout\n\n# Request with callback\naction = action_handler.request_action(\n    title=\"Approve Data Access\",\n    description=\"Agent is requesting access to sensitive customer data\",\n    agent_id=\"data_processor\",\n    metadata={\"data_type\": \"customer_records\"},\n    callbacks=[handle_response]  # Will be called when human responds\n)\n\n# Continue execution without waiting\nprint(\"Request sent, continuing with other work...\")\n</code></pre>"},{"location":"guides/human_in_loop/#processing-human-modifications","title":"Processing Human Modifications","text":"<p>When humans modify an action, they can include structured changes that your application can interpret:</p> <pre><code>def apply_modifications(original_context, modifications):\n    \"\"\"Apply human modifications to the original context.\"\"\"\n    modified_context = original_context.copy()\n\n    for key, value in modifications.items():\n        if key in modified_context:\n            # Handle type conversions if needed\n            if key == \"amount\" and isinstance(original_context[key], Decimal):\n                modified_context[key] = Decimal(value)\n            else:\n                modified_context[key] = value\n\n    return modified_context\n\n# Example usage\nif action.status == ActionStatus.MODIFIED:\n    # Original request context\n    original_context = {\n        \"action_type\": \"transaction\",\n        \"amount\": Decimal(\"2500.00\"),\n        \"description\": \"Large investment purchase\"\n    }\n\n    # Apply the modifications from human\n    modified_context = apply_modifications(original_context, action.response_data)\n\n    # Execute with the modified context\n    result = agent.run(**modified_context)\n</code></pre>"},{"location":"guides/human_in_loop/#available-notification-channels","title":"Available Notification Channels","text":"<p>The Safeguards library includes several built-in notification channels:</p>"},{"location":"guides/human_in_loop/#logging-channel","title":"Logging Channel","text":"<p>Simple channel that logs alerts to Python's logging system:</p> <pre><code>from safeguards.notifications.channels import LoggingChannel\n\nlogging_channel = LoggingChannel()\nlogging_channel.initialize({\"log_level\": \"INFO\"})\nnotification_manager.register_channel(\"logging\", logging_channel)\n</code></pre>"},{"location":"guides/human_in_loop/#email-channel","title":"Email Channel","text":"<p>Sends alerts via email:</p> <pre><code>from safeguards.notifications.channels import EmailChannel\n\nemail_channel = EmailChannel()\nemail_channel.initialize({\n    \"smtp_server\": \"smtp.gmail.com\",\n    \"smtp_port\": 587,\n    \"username\": \"your_email@gmail.com\",\n    \"password\": \"your_password\",\n    \"sender\": \"safeguards@yourcompany.com\",\n    \"recipients\": [\"admin@yourcompany.com\", \"security@yourcompany.com\"],\n    \"use_tls\": True\n})\nnotification_manager.register_channel(\"email\", email_channel)\n</code></pre>"},{"location":"guides/human_in_loop/#slack-channel","title":"Slack Channel","text":"<p>Sends alerts to a Slack channel:</p> <pre><code>from safeguards.notifications.channels import SlackChannel\n\nslack_channel = SlackChannel()\nslack_channel.initialize({\n    \"webhook_url\": \"https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK\",\n    \"channel\": \"#agent-alerts\",\n    \"username\": \"SafeguardsBot\",\n    \"icon_emoji\": \":robot_face:\"\n})\nnotification_manager.register_channel(\"slack\", slack_channel)\n</code></pre>"},{"location":"guides/human_in_loop/#human-in-the-loop-channel","title":"Human-in-the-Loop Channel","text":"<p>Sends alerts that require human approval:</p> <pre><code>from safeguards.notifications.channels import HumanInTheLoopChannel\n\nhitl_channel = HumanInTheLoopChannel()\nhitl_channel.initialize({\n    \"webhook_url\": \"https://your-approval-endpoint.com/api\",\n    \"api_key\": \"your_api_key\",\n    \"timeout_seconds\": 300,\n    \"poll_interval\": 5\n})\nnotification_manager.register_channel(\"human_review\", hitl_channel)\n</code></pre>"},{"location":"guides/human_in_loop/#creating-a-custom-notification-channel","title":"Creating a Custom Notification Channel","text":"<p>You can create custom notification channels by implementing the <code>NotificationChannel</code> interface:</p> <pre><code>from safeguards.notifications.channels import NotificationChannel\nfrom safeguards.types import SafetyAlert\n\nclass CustomChannel(NotificationChannel):\n    \"\"\"Custom notification channel example.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the custom channel.\"\"\"\n        self._config = {}\n        self._initialized = False\n\n    def initialize(self, config: Dict[str, Any]) -&gt; None:\n        \"\"\"Initialize the channel with configuration.\"\"\"\n        self._config = config\n        # Set up your channel\n        self._initialized = True\n\n    def send_notification(self, alert: SafetyAlert) -&gt; bool:\n        \"\"\"Send a notification through this channel.\"\"\"\n        if not self._initialized:\n            return False\n\n        try:\n            # Implement your notification logic here\n            print(f\"Custom notification: {alert.title} - {alert.description}\")\n            return True\n        except Exception as e:\n            print(f\"Error sending notification: {e}\")\n            return False\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Clean up resources when shutting down.\"\"\"\n        # Clean up any resources\n        self._initialized = False\n</code></pre>"},{"location":"guides/human_in_loop/#complete-example","title":"Complete Example","text":"<p>Here's a complete example combining industry safeguards with human-in-the-loop workflows:</p> <pre><code>from decimal import Decimal\nfrom safeguards.core.notification_manager import NotificationManager\nfrom safeguards.notifications.channels import HumanInTheLoopChannel, LoggingChannel\nfrom safeguards.plugins.industry import FinancialServicesSafeguard\nfrom safeguards.human_action import HumanActionHandler, ActionStatus\nfrom safeguards.types.agent import Agent\n\n# Create notification components\nnotification_manager = NotificationManager()\n\n# Set up logging channel\nlogging_channel = LoggingChannel()\nlogging_channel.initialize({\"log_level\": \"INFO\"})\nnotification_manager.register_channel(\"logging\", logging_channel)\n\n# Set up human-in-the-loop channel\nhitl_channel = HumanInTheLoopChannel()\nhitl_channel.initialize({\n    \"webhook_url\": \"http://example.com/api/approvals\",\n    \"api_key\": \"demo_key\",\n    \"timeout_seconds\": 60\n})\nnotification_manager.register_channel(\"human_review\", hitl_channel)\n\n# Create human action handler\naction_handler = HumanActionHandler(hitl_channel)\n\n# Create financial agent\nclass FinancialAgent(Agent):\n    def __init__(self, name, transaction_limit):\n        super().__init__(name)\n        self.transaction_limit = transaction_limit\n\n    def run(self, **kwargs):\n        # Agent implementation here\n        return {\"success\": True, **kwargs}\n\n# Create agent and safeguard\nagent = FinancialAgent(\"financial_advisor\", Decimal(\"1000.00\"))\n\nfinancial_safeguard = FinancialServicesSafeguard()\nfinancial_safeguard.initialize({\n    \"restricted_actions\": [\"high_risk_investment\"],\n    \"transaction_limits\": {agent.id: Decimal(\"1000.00\")}\n})\n\n# Start monitoring the agent\nfinancial_safeguard.monitor_agent(agent.id)\n\n# Create a transaction\ntransaction = {\n    \"action_type\": \"transaction\",\n    \"amount\": Decimal(\"2500.00\"),\n    \"description\": \"Large investment purchase\"\n}\n\n# Check if it needs approval\nalerts = financial_safeguard.validate_agent_action(agent, transaction)\nif alerts:\n    # Request human approval\n    action = action_handler.request_action(\n        title=\"Approve High-Value Transaction\",\n        description=f\"Transaction of ${transaction['amount']} requires approval\",\n        agent_id=agent.id,\n        metadata=transaction\n    )\n\n    # Wait for response\n    status = action_handler.wait_for_action(action)\n\n    if status == ActionStatus.APPROVED:\n        # Execute approved transaction\n        result = agent.run(**transaction)\n        print(f\"Approved transaction executed: {result}\")\n    elif status == ActionStatus.MODIFIED:\n        # Apply modifications\n        modified_transaction = transaction.copy()\n        for key, value in action.response_data.items():\n            if key == \"amount\":\n                modified_transaction[key] = Decimal(value)\n            else:\n                modified_transaction[key] = value\n\n        # Execute modified transaction\n        result = agent.run(**modified_transaction)\n        print(f\"Modified transaction executed: {result}\")\n    else:\n        print(f\"Transaction not executed. Status: {status}, Reason: {action.comments}\")\nelse:\n    # No alerts, proceed normally\n    result = agent.run(**transaction)\n    print(f\"Transaction executed without approval: {result}\")\n\n# Clean up\nfinancial_safeguard.stop_monitoring_agent(agent.id)\nhitl_channel.shutdown()\n</code></pre>"},{"location":"guides/human_in_loop/#integration-with-external-systems","title":"Integration with External Systems","text":"<p>For real-world HITL workflows, you'll typically need to integrate with external systems:</p> <ol> <li>Set up an API endpoint to receive and process approval requests</li> <li>Create a user interface for reviewers to approve, reject, or modify requests</li> <li>Implement a callback mechanism to notify the Safeguards system of human decisions</li> </ol> <p>The <code>HumanInTheLoopChannel</code> is designed to communicate with such external systems via webhooks. The implementation of the external system is left to you, but should include:</p> <ol> <li>An endpoint to receive approval requests (<code>/request-approval</code>)</li> <li>A UI to display pending requests to human reviewers</li> <li>A mechanism to send responses back to the callback URL</li> <li>Authentication to secure the communication</li> </ol>"},{"location":"guides/monitoring/","title":"Agent Monitoring Guide","text":"<p>This guide covers the monitoring capabilities of the Safeguards, helping you track agent performance, resource usage, and detect potential safety issues.</p>"},{"location":"guides/monitoring/#monitoring-overview","title":"Monitoring Overview","text":"<p>The Safeguards provides several monitoring components:</p> <ul> <li>Metrics Collection: Tracking numeric measurements of agent activity</li> <li>Runtime Monitoring: Real-time observation of agent behavior</li> <li>Violation Detection: Identifying when agents break defined constraints</li> <li>Logging: Recording agent activities for later analysis</li> <li>Visualization: Displaying monitoring data in dashboards</li> </ul>"},{"location":"guides/monitoring/#setting-up-basic-monitoring","title":"Setting Up Basic Monitoring","text":""},{"location":"guides/monitoring/#metrics-collector","title":"Metrics Collector","text":"<p>Start by setting up a metrics collector:</p> <pre><code>from safeguards.monitoring.metrics_collector import MetricsCollector\nfrom safeguards.types import MetricType\n\n# Create a metrics collector\nmetrics_collector = MetricsCollector()\n\n# Register an agent to monitor\nagent_id = \"agent123\"\nmetrics_collector.register_agent(agent_id)\n\n# Record some metrics\nmetrics_collector.record_metric(\n    agent_id=agent_id,\n    metric_name=\"api_calls\",\n    metric_type=MetricType.COUNTER,\n    value=1\n)\n\nmetrics_collector.record_metric(\n    agent_id=agent_id,\n    metric_name=\"response_time_ms\",\n    metric_type=MetricType.GAUGE,\n    value=245.6\n)\n\n# Retrieve metrics\napi_calls = metrics_collector.get_metric_value(agent_id, \"api_calls\")\nprint(f\"API calls made by agent: {api_calls}\")\n\n# Get all metrics for an agent\nall_metrics = metrics_collector.get_agent_metrics(agent_id)\nprint(f\"All metrics: {all_metrics}\")\n</code></pre>"},{"location":"guides/monitoring/#runtime-monitor","title":"Runtime Monitor","text":"<p>Set up real-time monitoring of agent behavior:</p> <pre><code>from safeguards.monitoring.runtime_monitor import RuntimeMonitor\nfrom safeguards.types.monitors import ResourceMonitor, ActivityMonitor\n\n# Create a runtime monitor\nruntime_monitor = RuntimeMonitor()\n\n# Add a resource monitor for CPU usage\ndef cpu_usage_monitor(agent_id, metrics):\n    \"\"\"Monitor CPU usage of an agent.\"\"\"\n    cpu_usage = get_agent_cpu_usage(agent_id)  # Your implementation\n    if cpu_usage &gt; 80:\n        print(f\"Warning: Agent {agent_id} CPU usage at {cpu_usage}%\")\n        return False  # Returning False signals a violation\n    return True\n\n# Register the CPU monitor\nruntime_monitor.register_monitor(\n    agent_id=\"agent123\",\n    monitor=ResourceMonitor(\n        name=\"cpu_usage\",\n        check_function=cpu_usage_monitor,\n        check_interval_seconds=30\n    )\n)\n\n# Add an activity monitor for API call frequency\ndef api_call_monitor(agent_id, metrics):\n    \"\"\"Monitor API call frequency.\"\"\"\n    recent_calls = metrics.get_metric_value(agent_id, \"api_calls\",\n                                           time_window_seconds=60)\n    if recent_calls &gt; 100:\n        print(f\"Warning: Agent {agent_id} made {recent_calls} API calls in the last minute\")\n        return False\n    return True\n\n# Register the API call monitor\nruntime_monitor.register_monitor(\n    agent_id=\"agent123\",\n    monitor=ActivityMonitor(\n        name=\"api_call_frequency\",\n        check_function=api_call_monitor,\n        check_interval_seconds=60,\n        metrics_collector=metrics_collector\n    )\n)\n\n# Start monitoring\nruntime_monitor.start()\n\n# Later, stop monitoring\n# runtime_monitor.stop()\n</code></pre>"},{"location":"guides/monitoring/#violation-reporter","title":"Violation Reporter","text":"<p>Set up violation detection and reporting:</p> <pre><code>from safeguards.monitoring.violation_reporter import ViolationReporter\nfrom safeguards.types import ViolationType, AlertSeverity\nfrom safeguards.core.notification_manager import NotificationManager\n\n# Create a notification manager (for alerting)\nnotification_manager = NotificationManager()\n\n# Create a violation reporter\nviolation_reporter = ViolationReporter(notification_manager)\n\n# Report a violation\nviolation_reporter.report_violation(\n    agent_id=\"agent123\",\n    violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n    severity=AlertSeverity.HIGH,\n    message=\"Agent exceeded memory usage limit\",\n    details={\n        \"limit\": \"256MB\",\n        \"actual\": \"312MB\",\n        \"overage_percentage\": 21.9\n    }\n)\n\n# You can also integrate the violation reporter with the runtime monitor\nruntime_monitor.set_violation_reporter(violation_reporter)\n</code></pre>"},{"location":"guides/monitoring/#comprehensive-monitoring-setup","title":"Comprehensive Monitoring Setup","text":"<p>Here's a complete example that sets up a comprehensive monitoring system:</p> <pre><code>from safeguards.monitoring import (\n    MetricsCollector,\n    RuntimeMonitor,\n    ViolationReporter,\n    LogManager\n)\nfrom safeguards.core import NotificationManager, BudgetCoordinator\nfrom safeguards.types import MetricType, ViolationType, AlertSeverity\nfrom safeguards.types.monitors import ResourceMonitor, ActivityMonitor, BudgetMonitor\n\ndef setup_monitoring_system():\n    \"\"\"Set up a comprehensive monitoring system.\"\"\"\n\n    # Core components\n    notification_manager = NotificationManager()\n    metrics_collector = MetricsCollector()\n    violation_reporter = ViolationReporter(notification_manager)\n    runtime_monitor = RuntimeMonitor()\n    log_manager = LogManager()\n    budget_coordinator = BudgetCoordinator(notification_manager)\n\n    # Connect components\n    runtime_monitor.set_violation_reporter(violation_reporter)\n    runtime_monitor.set_metrics_collector(metrics_collector)\n\n    # Set up logging\n    log_manager.set_log_level(\"DEBUG\")\n    log_manager.set_log_format(\"[{timestamp}] {level}: {message}\")\n    log_manager.set_log_file(\"agent_monitoring.log\")\n\n    # Return the monitoring system components\n    return {\n        \"notification_manager\": notification_manager,\n        \"metrics_collector\": metrics_collector,\n        \"violation_reporter\": violation_reporter,\n        \"runtime_monitor\": runtime_monitor,\n        \"log_manager\": log_manager,\n        \"budget_coordinator\": budget_coordinator\n    }\n\ndef register_agent_for_monitoring(monitoring_system, agent_id, initial_budget=100.0):\n    \"\"\"Register an agent with the monitoring system.\"\"\"\n\n    # Unpack components\n    metrics_collector = monitoring_system[\"metrics_collector\"]\n    runtime_monitor = monitoring_system[\"runtime_monitor\"]\n    budget_coordinator = monitoring_system[\"budget_coordinator\"]\n\n    # Register with metrics collector\n    metrics_collector.register_agent(agent_id)\n\n    # Create a budget pool and register agent\n    pool_id = budget_coordinator.create_budget_pool(\n        name=f\"pool_{agent_id}\",\n        initial_budget=initial_budget,\n        description=f\"Budget pool for agent {agent_id}\"\n    )\n    budget_coordinator.register_agent(\n        agent_id=agent_id,\n        pool_id=pool_id,\n        priority=5\n    )\n\n    # Set up budget monitoring\n    def budget_monitor(agent_id, metrics):\n        \"\"\"Monitor agent budget usage.\"\"\"\n        budget_info = budget_coordinator.get_agent_metrics(agent_id)\n        remaining_percentage = (budget_info[\"remaining_budget\"] /\n                               budget_info[\"initial_budget\"]) * 100\n\n        metrics_collector.record_metric(\n            agent_id=agent_id,\n            metric_name=\"budget_remaining_percentage\",\n            metric_type=MetricType.GAUGE,\n            value=remaining_percentage\n        )\n\n        if remaining_percentage &lt; 10:\n            monitoring_system[\"violation_reporter\"].report_violation(\n                agent_id=agent_id,\n                violation_type=ViolationType.BUDGET_DEPLETED,\n                severity=AlertSeverity.HIGH,\n                message=f\"Agent budget nearly depleted ({remaining_percentage:.1f}%)\",\n                details=budget_info\n            )\n            return False\n\n        return True\n\n    # Register budget monitor\n    runtime_monitor.register_monitor(\n        agent_id=agent_id,\n        monitor=BudgetMonitor(\n            name=\"budget_usage\",\n            check_function=budget_monitor,\n            check_interval_seconds=60,\n            metrics_collector=metrics_collector\n        )\n    )\n\n    # Set up CPU monitoring\n    def cpu_monitor(agent_id, metrics):\n        \"\"\"Monitor CPU usage.\"\"\"\n        # Example implementation - replace with actual CPU monitoring\n        cpu_usage = get_agent_cpu_usage(agent_id)  # Your implementation\n\n        metrics_collector.record_metric(\n            agent_id=agent_id,\n            metric_name=\"cpu_usage_percent\",\n            metric_type=MetricType.GAUGE,\n            value=cpu_usage\n        )\n\n        if cpu_usage &gt; 80:\n            monitoring_system[\"violation_reporter\"].report_violation(\n                agent_id=agent_id,\n                violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n                severity=AlertSeverity.MEDIUM,\n                message=f\"Agent CPU usage high ({cpu_usage}%)\",\n                details={\"resource\": \"cpu\", \"usage\": cpu_usage, \"limit\": 80}\n            )\n            return False\n\n        return True\n\n    # Register CPU monitor\n    runtime_monitor.register_monitor(\n        agent_id=agent_id,\n        monitor=ResourceMonitor(\n            name=\"cpu_usage\",\n            check_function=cpu_monitor,\n            check_interval_seconds=30,\n            metrics_collector=metrics_collector\n        )\n    )\n\n    # Set up memory monitoring\n    def memory_monitor(agent_id, metrics):\n        \"\"\"Monitor memory usage.\"\"\"\n        # Example implementation - replace with actual memory monitoring\n        memory_usage = get_agent_memory_usage(agent_id)  # Your implementation\n\n        metrics_collector.record_metric(\n            agent_id=agent_id,\n            metric_name=\"memory_usage_mb\",\n            metric_type=MetricType.GAUGE,\n            value=memory_usage\n        )\n\n        if memory_usage &gt; 512:  # 512 MB limit\n            monitoring_system[\"violation_reporter\"].report_violation(\n                agent_id=agent_id,\n                violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n                severity=AlertSeverity.MEDIUM,\n                message=f\"Agent memory usage high ({memory_usage} MB)\",\n                details={\"resource\": \"memory\", \"usage\": memory_usage, \"limit\": 512}\n            )\n            return False\n\n        return True\n\n    # Register memory monitor\n    runtime_monitor.register_monitor(\n        agent_id=agent_id,\n        monitor=ResourceMonitor(\n            name=\"memory_usage\",\n            check_function=memory_monitor,\n            check_interval_seconds=30,\n            metrics_collector=metrics_collector\n        )\n    )\n\n    # Start monitoring if not already started\n    if not runtime_monitor.is_running:\n        runtime_monitor.start()\n\n    return True\n\n# Example usage of the above functions\ndef example_usage():\n    # Set up monitoring system\n    monitoring_system = setup_monitoring_system()\n\n    # Register an agent for monitoring\n    agent_id = \"agent123\"\n    register_agent_for_monitoring(monitoring_system, agent_id, initial_budget=200.0)\n\n    # Simulate agent activity\n    for i in range(10):\n        # Record some metrics\n        monitoring_system[\"metrics_collector\"].record_metric(\n            agent_id=agent_id,\n            metric_name=\"api_calls\",\n            metric_type=MetricType.COUNTER,\n            value=1\n        )\n\n        # Update budget usage\n        monitoring_system[\"budget_coordinator\"].update_budget(\n            agent_id=agent_id,\n            amount=10.0\n        )\n\n        # Wait a bit before next activity\n        time.sleep(5)\n\n    # Check agent metrics\n    metrics = monitoring_system[\"metrics_collector\"].get_agent_metrics(agent_id)\n    print(f\"Final metrics for {agent_id}: {metrics}\")\n\n    # Check budget status\n    budget_info = monitoring_system[\"budget_coordinator\"].get_agent_metrics(agent_id)\n    print(f\"Final budget for {agent_id}: {budget_info}\")\n\n    # Stop monitoring\n    monitoring_system[\"runtime_monitor\"].stop()\n\n# Helper functions (implement these based on your environment)\ndef get_agent_cpu_usage(agent_id):\n    \"\"\"Get agent CPU usage percentage.\"\"\"\n    # Implementation depends on your environment and agent implementation\n    # This is just a placeholder\n    import random\n    return random.uniform(10, 90)\n\ndef get_agent_memory_usage(agent_id):\n    \"\"\"Get agent memory usage in MB.\"\"\"\n    # Implementation depends on your environment and agent implementation\n    # This is just a placeholder\n    import random\n    return random.uniform(100, 600)\n</code></pre>"},{"location":"guides/monitoring/#custom-metrics-and-monitors","title":"Custom Metrics and Monitors","text":""},{"location":"guides/monitoring/#custom-metrics","title":"Custom Metrics","text":"<p>You can record custom metrics specific to your agents:</p> <pre><code># Record a custom metric for tracking task completion\nmetrics_collector.record_metric(\n    agent_id=\"agent123\",\n    metric_name=\"tasks_completed\",\n    metric_type=MetricType.COUNTER,\n    value=1,\n    labels={\"task_type\": \"data_processing\", \"priority\": \"high\"}\n)\n\n# Record a timing metric\nmetrics_collector.record_metric(\n    agent_id=\"agent123\",\n    metric_name=\"task_duration_seconds\",\n    metric_type=MetricType.HISTOGRAM,\n    value=3.45,\n    labels={\"task_type\": \"data_processing\"}\n)\n\n# Get aggregated metrics with filters\ntask_metrics = metrics_collector.get_filtered_metrics(\n    agent_id=\"agent123\",\n    metric_name=\"task_duration_seconds\",\n    filter_labels={\"task_type\": \"data_processing\"},\n    aggregation=\"avg\",\n    time_window_seconds=3600  # Last hour\n)\nprint(f\"Average data processing task duration: {task_metrics} seconds\")\n</code></pre>"},{"location":"guides/monitoring/#custom-monitors","title":"Custom Monitors","text":"<p>You can create custom monitors for domain-specific behaviors:</p> <pre><code>from safeguards.types.monitors import CustomMonitor\n\ndef data_quality_monitor(agent_id, metrics):\n    \"\"\"Monitor data quality produced by the agent.\"\"\"\n    # Example implementation\n    data_quality_score = calculate_data_quality(agent_id)  # Your implementation\n\n    metrics.record_metric(\n        agent_id=agent_id,\n        metric_name=\"data_quality_score\",\n        metric_type=MetricType.GAUGE,\n        value=data_quality_score\n    )\n\n    if data_quality_score &lt; 0.7:  # Threshold for acceptable quality\n        print(f\"Warning: Agent {agent_id} produced low quality data: {data_quality_score}\")\n        return False\n\n    return True\n\n# Register the custom monitor\nruntime_monitor.register_monitor(\n    agent_id=\"agent123\",\n    monitor=CustomMonitor(\n        name=\"data_quality\",\n        check_function=data_quality_monitor,\n        check_interval_seconds=300,  # Check every 5 minutes\n        metrics_collector=metrics_collector\n    )\n)\n\n# Example helper function (implement based on your needs)\ndef calculate_data_quality(agent_id):\n    \"\"\"Calculate data quality score for agent outputs.\"\"\"\n    # Implementation depends on your specific use case\n    # This is just a placeholder\n    import random\n    return random.uniform(0.5, 1.0)\n</code></pre>"},{"location":"guides/monitoring/#working-with-monitoring-data","title":"Working with Monitoring Data","text":""},{"location":"guides/monitoring/#querying-metrics","title":"Querying Metrics","text":"<p>Retrieve and analyze recorded metrics:</p> <pre><code>from datetime import datetime, timedelta\n\n# Get all metrics for an agent\nall_metrics = metrics_collector.get_agent_metrics(\"agent123\")\n\n# Get a specific metric over time\napi_calls_over_time = metrics_collector.get_metric_history(\n    agent_id=\"agent123\",\n    metric_name=\"api_calls\",\n    start_time=datetime.now() - timedelta(hours=24),\n    end_time=datetime.now(),\n    resolution=\"1h\"  # Group by hour\n)\n\n# Calculate rate of change\napi_call_rate = metrics_collector.get_metric_rate(\n    agent_id=\"agent123\",\n    metric_name=\"api_calls\",\n    time_window_seconds=3600  # Last hour\n)\nprint(f\"API calls per second: {api_call_rate}\")\n\n# Get aggregated metrics across agents\nsystem_metrics = metrics_collector.get_aggregated_metrics(\n    metric_name=\"memory_usage_mb\",\n    aggregation=\"sum\",\n    filter_labels={\"agent_type\": \"assistant\"}\n)\nprint(f\"Total memory usage across all assistant agents: {system_metrics} MB\")\n</code></pre>"},{"location":"guides/monitoring/#visualizing-monitoring-data","title":"Visualizing Monitoring Data","text":"<p>Create visualizations of your monitoring data:</p> <pre><code>from safeguards.visualization import MetricsDashboard\n\n# Create a metrics dashboard\ndashboard = MetricsDashboard(metrics_collector)\n\n# Add visualization panels\ndashboard.add_panel(\n    title=\"API Calls Over Time\",\n    metric_name=\"api_calls\",\n    panel_type=\"line_chart\",\n    time_window_hours=24,\n    agent_ids=[\"agent123\", \"agent456\"]\n)\n\ndashboard.add_panel(\n    title=\"Memory Usage\",\n    metric_name=\"memory_usage_mb\",\n    panel_type=\"gauge\",\n    agent_id=\"agent123\"\n)\n\ndashboard.add_panel(\n    title=\"Budget Remaining\",\n    metric_name=\"budget_remaining_percentage\",\n    panel_type=\"pie_chart\",\n    agent_ids=[\"agent123\", \"agent456\", \"agent789\"]\n)\n\n# Start the dashboard web server\ndashboard_url = dashboard.start(host=\"0.0.0.0\", port=8080)\nprint(f\"Dashboard available at: {dashboard_url}\")\n</code></pre>"},{"location":"guides/monitoring/#agent-health-checks","title":"Agent Health Checks","text":""},{"location":"guides/monitoring/#implementing-health-checks","title":"Implementing Health Checks","text":"<p>Implement comprehensive health checks for your agents:</p> <pre><code>from safeguards.monitoring.health import HealthChecker\nfrom safeguards.types.health import HealthStatus, HealthCheck\n\n# Create a health checker\nhealth_checker = HealthChecker()\n\n# Add connectivity check\ndef check_connectivity(agent_id):\n    \"\"\"Check if agent is reachable.\"\"\"\n    try:\n        # Your implementation to ping the agent\n        response = ping_agent(agent_id, timeout=2)  # Your implementation\n        if response:\n            return HealthStatus.HEALTHY, \"Agent is reachable\"\n        else:\n            return HealthStatus.UNHEALTHY, \"Agent is not responding\"\n    except Exception as e:\n        return HealthStatus.UNHEALTHY, f\"Error connecting to agent: {str(e)}\"\n\nhealth_checker.add_check(\n    agent_id=\"agent123\",\n    check=HealthCheck(\n        name=\"connectivity\",\n        check_function=check_connectivity,\n        check_interval_seconds=60\n    )\n)\n\n# Add budget health check\ndef check_budget_health(agent_id):\n    \"\"\"Check if agent has sufficient budget.\"\"\"\n    try:\n        budget_info = budget_coordinator.get_agent_metrics(agent_id)\n        remaining_percentage = (budget_info[\"remaining_budget\"] /\n                               budget_info[\"initial_budget\"]) * 100\n\n        if remaining_percentage &gt; 50:\n            return HealthStatus.HEALTHY, f\"Budget at {remaining_percentage:.1f}%\"\n        elif remaining_percentage &gt; 20:\n            return HealthStatus.DEGRADED, f\"Budget at {remaining_percentage:.1f}%\"\n        else:\n            return HealthStatus.UNHEALTHY, f\"Budget depleted: {remaining_percentage:.1f}%\"\n    except Exception as e:\n        return HealthStatus.UNKNOWN, f\"Error checking budget: {str(e)}\"\n\nhealth_checker.add_check(\n    agent_id=\"agent123\",\n    check=HealthCheck(\n        name=\"budget_health\",\n        check_function=check_budget_health,\n        check_interval_seconds=300\n    )\n)\n\n# Start health checks\nhealth_checker.start()\n\n# Get current health status\nhealth = health_checker.get_health(\"agent123\")\nprint(f\"Overall health: {health.status.name}\")\nprint(f\"Health details: {health.details}\")\n\n# Example helper function (implement based on your needs)\ndef ping_agent(agent_id, timeout=2):\n    \"\"\"Check if an agent is responsive.\"\"\"\n    # Implementation depends on your agent architecture\n    # This is just a placeholder\n    import random\n    return random.choice([True, True, True, False])  # 75% chance of success\n</code></pre>"},{"location":"guides/monitoring/#auditing-and-compliance","title":"Auditing and Compliance","text":""},{"location":"guides/monitoring/#audit-trail","title":"Audit Trail","text":"<p>Implement an audit trail for agent activities:</p> <pre><code>from safeguards.monitoring.audit import AuditLogger\nfrom safeguards.types.audit import AuditEvent, AuditEventType\n\n# Create an audit logger\naudit_logger = AuditLogger(\n    log_file=\"audit_trail.log\",\n    retention_days=90\n)\n\n# Record an audit event\naudit_logger.log_event(\n    agent_id=\"agent123\",\n    event_type=AuditEventType.API_CALL,\n    event_details={\n        \"endpoint\": \"/api/data\",\n        \"method\": \"GET\",\n        \"parameters\": {\"id\": \"12345\"},\n        \"response_code\": 200\n    }\n)\n\n# Record a state change event\naudit_logger.log_event(\n    agent_id=\"agent123\",\n    event_type=AuditEventType.STATE_CHANGE,\n    event_details={\n        \"previous_state\": \"IDLE\",\n        \"new_state\": \"PROCESSING\",\n        \"triggered_by\": \"user_request\"\n    }\n)\n\n# Query audit events\nevents = audit_logger.query_events(\n    agent_id=\"agent123\",\n    event_types=[AuditEventType.API_CALL, AuditEventType.STATE_CHANGE],\n    start_time=datetime.now() - timedelta(days=7),\n    end_time=datetime.now()\n)\n\nprint(f\"Found {len(events)} audit events\")\nfor event in events[:5]:\n    print(f\"{event.timestamp} - {event.event_type}: {event.event_details}\")\n</code></pre>"},{"location":"guides/monitoring/#compliance-reports","title":"Compliance Reports","text":"<p>Generate compliance reports for agents:</p> <pre><code>from safeguards.monitoring.compliance import ComplianceReporter\nfrom safeguards.types.compliance import ComplianceCheck, ComplianceStatus\n\n# Create a compliance reporter\ncompliance_reporter = ComplianceReporter()\n\n# Add compliance checks\ncompliance_reporter.add_check(\n    name=\"budget_compliance\",\n    description=\"Check if agents stay within budget limits\",\n    check_function=lambda: check_budget_compliance()  # Your implementation\n)\n\ncompliance_reporter.add_check(\n    name=\"data_privacy\",\n    description=\"Check if agents handle sensitive data properly\",\n    check_function=lambda: check_data_privacy()  # Your implementation\n)\n\ncompliance_reporter.add_check(\n    name=\"rate_limiting\",\n    description=\"Check if agents respect API rate limits\",\n    check_function=lambda: check_rate_limiting()  # Your implementation\n)\n\n# Generate a compliance report\nreport = compliance_reporter.generate_report()\nprint(f\"Compliance status: {report.overall_status.name}\")\nprint(f\"Passed checks: {len([c for c in report.checks if c.status == ComplianceStatus.PASSED])}\")\nprint(f\"Failed checks: {len([c for c in report.checks if c.status == ComplianceStatus.FAILED])}\")\n\n# Export the report\ncompliance_reporter.export_report(report, format=\"pdf\", output_file=\"compliance_report.pdf\")\n\n# Example helper functions (implement based on your needs)\ndef check_budget_compliance():\n    \"\"\"Check if all agents are within budget limits.\"\"\"\n    # Implementation depends on your system\n    # This is just a placeholder\n    return ComplianceStatus.PASSED, \"All agents within budget limits\"\n\ndef check_data_privacy():\n    \"\"\"Check if agents handle sensitive data properly.\"\"\"\n    # Implementation depends on your system\n    # This is just a placeholder\n    return ComplianceStatus.PASSED, \"No data privacy violations detected\"\n\ndef check_rate_limiting():\n    \"\"\"Check if agents respect API rate limits.\"\"\"\n    # Implementation depends on your system\n    # This is just a placeholder\n    return ComplianceStatus.WARNING, \"Some agents approaching rate limits\"\n</code></pre>"},{"location":"guides/monitoring/#best-practices","title":"Best Practices","text":""},{"location":"guides/monitoring/#recommended-metrics","title":"Recommended Metrics","text":"<p>Consider tracking these key metrics for agents:</p> <ul> <li>Resource Usage: CPU, memory, network, and disk usage</li> <li>Performance: Response time, task completion time</li> <li>Activity: API calls, tasks processed, actions taken</li> <li>Errors: Count of errors, exceptions, and failures</li> <li>Budget: Usage rate, remaining budget, budget efficiency</li> <li>Domain-Specific: Metrics relevant to your specific use case</li> </ul>"},{"location":"guides/monitoring/#monitoring-recommendations","title":"Monitoring Recommendations","text":"<ol> <li>Monitor at Multiple Levels:</li> <li>Individual agents</li> <li>Agent pools or groups</li> <li> <p>System-wide metrics</p> </li> <li> <p>Set Appropriate Thresholds:</p> </li> <li>Baseline normal behavior before setting alert thresholds</li> <li> <p>Consider dynamic thresholds that adapt to patterns</p> </li> <li> <p>Balance Detail and Overhead:</p> </li> <li>Too much monitoring can impact performance</li> <li> <p>Focus on actionable metrics</p> </li> <li> <p>Implement Graduated Monitoring:</p> </li> <li>More intensive monitoring for critical agents</li> <li> <p>Less frequent checks for less critical agents</p> </li> <li> <p>Correlate Metrics and Events:</p> </li> <li>Look for patterns across different metrics</li> <li>Correlate monitoring data with specific agent actions</li> </ol>"},{"location":"guides/monitoring/#conclusion","title":"Conclusion","text":"<p>Effective monitoring is critical for maintaining the safety and reliability of agent systems. The Safeguards provides a comprehensive set of tools for metrics collection, runtime monitoring, violation detection, and visualization that allow you to keep track of your agents' behavior and resource usage.</p> <p>By implementing the patterns shown in this guide, you can gain visibility into your agents' operations, detect potential issues before they become critical, and maintain an audit trail for compliance purposes.</p> <p>For more information, see: - Notifications Guide - Budget Management Guide - API Reference</p>"},{"location":"guides/notifications/","title":"Notifications &amp; Alerts Guide","text":"<p>This guide explains how to set up and customize the notification system in the Safeguards, enabling you to monitor agent activity, detect problems, and respond to events.</p>"},{"location":"guides/notifications/#core-notification-concepts","title":"Core Notification Concepts","text":"<p>The notification system in the Safeguards is built around:</p> <ul> <li>Alerts: Structured messages about significant events</li> <li>Notification Channels: Methods for delivering alerts (email, Slack, etc.)</li> <li>Handlers: Functions that process alerts and take action</li> <li>Severity Levels: Categorization of alerts by importance</li> <li>Throttling: Control over alert frequency</li> </ul>"},{"location":"guides/notifications/#setting-up-the-notification-system","title":"Setting Up the Notification System","text":""},{"location":"guides/notifications/#basic-notification-manager","title":"Basic Notification Manager","text":"<p>Start by creating a notification manager:</p> <pre><code>from safeguards.core.notification_manager import NotificationManager\nfrom safeguards.types import AlertSeverity\n\n# Create a notification manager\nnotification_manager = NotificationManager()\n</code></pre>"},{"location":"guides/notifications/#creating-and-sending-alerts","title":"Creating and Sending Alerts","text":"<p>Send alerts for important events:</p> <pre><code># Send a basic alert\nnotification_manager.send_alert(\n    message=\"Agent has completed its task\",\n    severity=AlertSeverity.INFORMATIONAL\n)\n\n# Send an alert with additional context\nnotification_manager.send_alert(\n    agent_id=\"agent123\",\n    message=\"Agent budget below 20% threshold\",\n    severity=AlertSeverity.WARNING,\n    metadata={\n        \"current_budget\": 18.5,\n        \"initial_budget\": 100.0,\n        \"percentage\": 18.5\n    }\n)\n\n# Send a critical alert\nnotification_manager.send_alert(\n    agent_id=\"agent456\",\n    message=\"Agent exceeded resource limit\",\n    severity=AlertSeverity.CRITICAL,\n    metadata={\n        \"resource_type\": \"memory\",\n        \"limit\": \"512MB\",\n        \"actual_usage\": \"650MB\",\n        \"overage_percentage\": 27\n    }\n)\n</code></pre>"},{"location":"guides/notifications/#alert-handlers","title":"Alert Handlers","text":""},{"location":"guides/notifications/#basic-alert-handler","title":"Basic Alert Handler","text":"<p>Implement a handler to process alerts:</p> <pre><code>def basic_alert_handler(alert):\n    \"\"\"Process all alerts.\"\"\"\n    print(f\"[{alert.severity.name}] {alert.timestamp}: {alert.message}\")\n    if alert.agent_id:\n        print(f\"Agent: {alert.agent_id}\")\n    if alert.metadata:\n        print(f\"Details: {alert.metadata}\")\n    return True  # Returning True indicates the alert was handled\n\n# Register the handler\nnotification_manager.add_handler(basic_alert_handler)\n</code></pre>"},{"location":"guides/notifications/#filtering-alerts-by-severity","title":"Filtering Alerts by Severity","text":"<p>Create handlers that only process certain severity levels:</p> <pre><code>def critical_alert_handler(alert):\n    \"\"\"Handle only critical alerts.\"\"\"\n    if alert.severity == AlertSeverity.CRITICAL:\n        print(f\"CRITICAL ALERT: {alert.message}\")\n        # Take immediate action\n        # ...\n        return True\n    return False  # Not handled, pass to other handlers\n\ndef warning_alert_handler(alert):\n    \"\"\"Handle only warning alerts.\"\"\"\n    if alert.severity == AlertSeverity.WARNING:\n        print(f\"Warning: {alert.message}\")\n        # Log warning\n        # ...\n        return True\n    return False\n\n# Register handlers in order of precedence\nnotification_manager.add_handler(critical_alert_handler)\nnotification_manager.add_handler(warning_alert_handler)\n</code></pre>"},{"location":"guides/notifications/#filtering-alerts-by-agent","title":"Filtering Alerts by Agent","text":"<p>Create handlers that only process alerts for specific agents:</p> <pre><code>def agent_specific_handler(alert):\n    \"\"\"Handle alerts only for a specific agent.\"\"\"\n    target_agent_id = \"agent123\"\n    if alert.agent_id == target_agent_id:\n        print(f\"Alert for {target_agent_id}: {alert.message}\")\n        # Take agent-specific action\n        # ...\n        return True\n    return False\n\n# Register the handler\nnotification_manager.add_handler(agent_specific_handler)\n</code></pre>"},{"location":"guides/notifications/#notification-channels","title":"Notification Channels","text":""},{"location":"guides/notifications/#email-notifications","title":"Email Notifications","text":"<p>Send alerts via email:</p> <pre><code>from safeguards.notification.channels import EmailChannel\n\n# Create an email channel\nemail_channel = EmailChannel(\n    smtp_server=\"smtp.example.com\",\n    smtp_port=587,\n    username=\"alerts@example.com\",\n    password=\"your-password\",\n    sender=\"alerts@example.com\",\n    recipients=[\"admin@example.com\", \"team@example.com\"]\n)\n\n# Register the channel with minimum severity threshold\nnotification_manager.register_channel(\n    channel=email_channel,\n    min_severity=AlertSeverity.WARNING  # Only WARNING and above\n)\n</code></pre>"},{"location":"guides/notifications/#slack-notifications","title":"Slack Notifications","text":"<p>Send alerts to Slack:</p> <pre><code>from safeguards.notification.channels import SlackChannel\n\n# Create a Slack channel\nslack_channel = SlackChannel(\n    webhook_url=\"https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK\",\n    channel=\"#agent-alerts\",\n    username=\"Safeguards Monitor\"\n)\n\n# Register the channel with custom formatting\nnotification_manager.register_channel(\n    channel=slack_channel,\n    min_severity=AlertSeverity.INFORMATIONAL,  # All alerts\n    formatter=lambda alert: {\n        \"text\": f\"*{alert.severity.name}*: {alert.message}\",\n        \"attachments\": [{\n            \"fields\": [\n                {\"title\": \"Agent\", \"value\": alert.agent_id or \"N/A\", \"short\": True},\n                {\"title\": \"Time\", \"value\": alert.timestamp, \"short\": True}\n            ]\n        }]\n    }\n)\n</code></pre>"},{"location":"guides/notifications/#webhook-notifications","title":"Webhook Notifications","text":"<p>Send alerts to custom webhooks:</p> <pre><code>from safeguards.notification.channels import WebhookChannel\n\n# Create a webhook channel\nwebhook_channel = WebhookChannel(\n    url=\"https://your-service.example.com/api/alerts\",\n    headers={\n        \"Authorization\": \"Bearer your-api-key\",\n        \"Content-Type\": \"application/json\"\n    }\n)\n\n# Register the channel\nnotification_manager.register_channel(\n    channel=webhook_channel,\n    min_severity=AlertSeverity.ERROR\n)\n</code></pre>"},{"location":"guides/notifications/#custom-notification-channels","title":"Custom Notification Channels","text":"<p>Implement a custom notification channel:</p> <pre><code>from safeguards.notification.base import NotificationChannel\nfrom safeguards.types.alerts import Alert\n\nclass CustomChannel(NotificationChannel):\n    def __init__(self, config):\n        self.config = config\n\n    def send(self, alert: Alert) -&gt; bool:\n        \"\"\"Send alert through custom channel.\"\"\"\n        # Custom implementation\n        print(f\"Sending through custom channel: {alert.message}\")\n\n        # You could implement any notification method here\n        # - Database logging\n        # - Message queue\n        # - Mobile push notification\n        # - Custom API integration\n\n        return True  # Return True if successfully sent\n\n# Create and register custom channel\ncustom_channel = CustomChannel(config={\"param\": \"value\"})\nnotification_manager.register_channel(custom_channel)\n</code></pre>"},{"location":"guides/notifications/#advanced-alert-handling","title":"Advanced Alert Handling","text":""},{"location":"guides/notifications/#alert-throttling","title":"Alert Throttling","text":"<p>Prevent alert floods with throttling:</p> <pre><code>from safeguards.notification.throttling import ThrottlingManager\n\n# Create a throttling manager\nthrottling_manager = ThrottlingManager()\n\n# Create a throttled handler\ndef throttled_alert_handler(alert):\n    \"\"\"Handle alerts with throttling.\"\"\"\n    # Generate a key for this type of alert\n    key = f\"{alert.agent_id}:{alert.severity.name}:{alert.metadata.get('type', 'general')}\"\n\n    # Check if this alert type is throttled\n    if throttling_manager.is_throttled(key):\n        # Skip this alert\n        return True\n\n    # Process the alert\n    print(f\"Processing alert: {alert.message}\")\n\n    # Apply throttling for this alert type (no more alerts for 5 minutes)\n    throttling_manager.throttle(key, duration_seconds=300)\n\n    return True\n\n# Register the handler\nnotification_manager.add_handler(throttled_alert_handler)\n</code></pre>"},{"location":"guides/notifications/#alert-aggregation","title":"Alert Aggregation","text":"<p>Aggregate similar alerts:</p> <pre><code>from safeguards.notification.aggregation import AlertAggregator\nfrom datetime import timedelta\n\n# Create an alert aggregator\naggregator = AlertAggregator(\n    window_size=timedelta(minutes=5),\n    max_count=10\n)\n\n# Create an aggregating handler\ndef aggregating_handler(alert):\n    \"\"\"Handle alerts with aggregation.\"\"\"\n    # Determine aggregation key\n    if alert.agent_id and alert.metadata.get(\"type\") == \"budget_warning\":\n        key = f\"budget_warning:{alert.agent_id}\"\n\n        # Add alert to aggregator\n        aggregated = aggregator.add(key, alert)\n\n        if aggregated is not None:\n            # We have enough alerts to trigger aggregated notification\n            count = len(aggregated)\n            first_alert = aggregated[0]\n            last_alert = aggregated[-1]\n\n            # Send aggregated alert\n            notification_manager.send_alert(\n                agent_id=first_alert.agent_id,\n                message=f\"Multiple budget warnings ({count}) for this agent\",\n                severity=AlertSeverity.WARNING,\n                metadata={\n                    \"aggregated\": True,\n                    \"count\": count,\n                    \"time_span\": (last_alert.timestamp - first_alert.timestamp).total_seconds(),\n                    \"first_message\": first_alert.message,\n                    \"last_message\": last_alert.message\n                }\n            )\n\n            return True  # Handled by aggregation\n\n    # Not handled by aggregation, pass to other handlers\n    return False\n\n# Register the handler\nnotification_manager.add_handler(aggregating_handler)\n</code></pre>"},{"location":"guides/notifications/#alert-escalation","title":"Alert Escalation","text":"<p>Automatically escalate unhandled alerts:</p> <pre><code>from safeguards.notification.escalation import EscalationManager\nfrom datetime import timedelta\n\n# Create an escalation manager\nescalation_manager = EscalationManager()\n\n# Configure escalation rules\nescalation_manager.add_rule(\n    name=\"critical_alerts\",\n    condition=lambda alert: alert.severity == AlertSeverity.CRITICAL,\n    escalation_levels=[\n        {\n            \"delay\": timedelta(minutes=0),  # Immediate\n            \"action\": lambda alert: notification_manager.send_via_channel(\n                alert, channel_id=\"slack\"\n            )\n        },\n        {\n            \"delay\": timedelta(minutes=5),  # After 5 minutes if not acknowledged\n            \"action\": lambda alert: notification_manager.send_via_channel(\n                alert, channel_id=\"email\"\n            )\n        },\n        {\n            \"delay\": timedelta(minutes=15),  # After 15 minutes if still not acknowledged\n            \"action\": lambda alert: notification_manager.send_via_channel(\n                alert, channel_id=\"sms\"\n            )\n        }\n    ]\n)\n\n# Start the escalation manager\nescalation_manager.start()\n\n# Report an alert that will be escalated if not acknowledged\nalert_id = notification_manager.send_alert(\n    message=\"Critical system failure\",\n    severity=AlertSeverity.CRITICAL,\n    metadata={\"requires_acknowledgement\": True}\n)\n\n# Later, to acknowledge the alert and stop escalation\nescalation_manager.acknowledge_alert(alert_id)\n</code></pre>"},{"location":"guides/notifications/#integrating-with-monitoring","title":"Integrating with Monitoring","text":""},{"location":"guides/notifications/#budget-monitoring-alerts","title":"Budget Monitoring Alerts","text":"<p>Set up alerts for budget-related issues:</p> <pre><code>from safeguards.types import ViolationType\n\ndef setup_budget_alerts(budget_coordinator, notification_manager):\n    \"\"\"Set up budget monitoring alerts.\"\"\"\n\n    def budget_monitor(agent_id, current_budget, initial_budget):\n        \"\"\"Monitor agent budget and trigger alerts.\"\"\"\n        # Calculate percentage\n        if initial_budget &gt; 0:\n            percentage = (current_budget / initial_budget) * 100\n\n            # Check thresholds\n            if percentage &lt;= 5:\n                notification_manager.send_alert(\n                    agent_id=agent_id,\n                    message=f\"Critical: Agent budget nearly depleted ({percentage:.1f}%)\",\n                    severity=AlertSeverity.CRITICAL,\n                    metadata={\n                        \"type\": \"budget_warning\",\n                        \"current_budget\": float(current_budget),\n                        \"initial_budget\": float(initial_budget),\n                        \"percentage\": float(percentage)\n                    }\n                )\n            elif percentage &lt;= 20:\n                notification_manager.send_alert(\n                    agent_id=agent_id,\n                    message=f\"Warning: Agent budget below 20% ({percentage:.1f}%)\",\n                    severity=AlertSeverity.WARNING,\n                    metadata={\n                        \"type\": \"budget_warning\",\n                        \"current_budget\": float(current_budget),\n                        \"initial_budget\": float(initial_budget),\n                        \"percentage\": float(percentage)\n                    }\n                )\n            elif percentage &lt;= 50:\n                notification_manager.send_alert(\n                    agent_id=agent_id,\n                    message=f\"Info: Agent budget below 50% ({percentage:.1f}%)\",\n                    severity=AlertSeverity.INFORMATIONAL,\n                    metadata={\n                        \"type\": \"budget_warning\",\n                        \"current_budget\": float(current_budget),\n                        \"initial_budget\": float(initial_budget),\n                        \"percentage\": float(percentage)\n                    }\n                )\n\n        return True  # Continue monitoring\n\n    # Register budget monitor for all agents\n    agent_ids = budget_coordinator.get_all_agent_ids()\n    for agent_id in agent_ids:\n        budget_coordinator.register_budget_monitor(agent_id, budget_monitor)\n</code></pre>"},{"location":"guides/notifications/#violation-alerts","title":"Violation Alerts","text":"<p>Set up alerts for safety violations:</p> <pre><code>from safeguards.monitoring.violation_reporter import ViolationReporter\n\ndef setup_violation_alerts(notification_manager):\n    \"\"\"Set up violation-to-alert conversion.\"\"\"\n\n    # Create a violation reporter\n    violation_reporter = ViolationReporter(notification_manager)\n\n    # Example of reporting a violation\n    violation_reporter.report_violation(\n        agent_id=\"agent123\",\n        violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n        severity=AlertSeverity.HIGH,\n        message=\"Agent exceeded CPU usage limit\",\n        details={\n            \"limit\": \"2.0 cores\",\n            \"actual\": \"3.2 cores\",\n            \"duration\": \"45 seconds\"\n        }\n    )\n\n    return violation_reporter\n</code></pre>"},{"location":"guides/notifications/#periodic-status-alerts","title":"Periodic Status Alerts","text":"<p>Set up regular status notifications:</p> <pre><code>import threading\nimport time\nfrom datetime import datetime\n\ndef setup_periodic_status_alerts(notification_manager, interval_seconds=3600):\n    \"\"\"Set up periodic status notifications.\"\"\"\n\n    def send_status_update():\n        \"\"\"Send a status update notification.\"\"\"\n        # Gather system metrics\n        system_metrics = {\n            \"active_agents\": 5,\n            \"total_budget_used\": 450.75,\n            \"total_remaining_budget\": 1250.25,\n            \"violations_last_hour\": 2\n        }\n\n        # Send status notification\n        notification_manager.send_alert(\n            message=f\"Hourly system status update\",\n            severity=AlertSeverity.INFORMATIONAL,\n            metadata={\n                \"type\": \"status_update\",\n                \"timestamp\": datetime.now().isoformat(),\n                \"metrics\": system_metrics\n            }\n        )\n\n    def status_thread():\n        \"\"\"Thread that sends periodic status updates.\"\"\"\n        while True:\n            try:\n                send_status_update()\n            except Exception as e:\n                print(f\"Error sending status update: {str(e)}\")\n\n            # Sleep until next interval\n            time.sleep(interval_seconds)\n\n    # Start status thread\n    thread = threading.Thread(target=status_thread, daemon=True)\n    thread.start()\n\n    return thread\n</code></pre>"},{"location":"guides/notifications/#creating-a-notification-dashboard","title":"Creating a Notification Dashboard","text":"<p>Visualize alerts in a dashboard:</p> <pre><code>from safeguards.notification.dashboard import AlertDashboard\n\n# Create an alert dashboard\ndashboard = AlertDashboard()\n\n# Configure dashboard panels\ndashboard.add_panel(\n    title=\"Recent Alerts\",\n    type=\"alert_list\",\n    config={\n        \"columns\": [\"timestamp\", \"severity\", \"agent_id\", \"message\"],\n        \"max_items\": 10,\n        \"auto_refresh_seconds\": 30\n    }\n)\n\ndashboard.add_panel(\n    title=\"Alert Distribution by Severity\",\n    type=\"pie_chart\",\n    config={\n        \"data_source\": \"alerts_by_severity\",\n        \"time_range\": \"last_24h\"\n    }\n)\n\ndashboard.add_panel(\n    title=\"Alert Timeline\",\n    type=\"time_series\",\n    config={\n        \"data_source\": \"alerts_by_time\",\n        \"time_range\": \"last_24h\",\n        \"group_by\": \"severity\"\n    }\n)\n\n# Start the dashboard (this could launch a web server)\ndashboard_url = dashboard.start(host=\"0.0.0.0\", port=8080)\nprint(f\"Dashboard available at: {dashboard_url}\")\n</code></pre>"},{"location":"guides/notifications/#best-practices","title":"Best Practices","text":""},{"location":"guides/notifications/#alert-prioritization","title":"Alert Prioritization","text":"<ul> <li>Use severity levels appropriately:</li> <li><code>CRITICAL</code> - Reserved for immediate action items that might impact system stability</li> <li><code>HIGH</code> - Serious issues requiring prompt attention</li> <li><code>MEDIUM</code> - Important issues that should be addressed soon</li> <li><code>LOW</code> - Minor issues that should be reviewed when convenient</li> <li> <p><code>INFORMATIONAL</code> - Status updates, non-issues</p> </li> <li> <p>Filter alerts by environment:</p> </li> <li>Production environments should have more strict filtering</li> <li>Development environments can be more verbose</li> </ul>"},{"location":"guides/notifications/#alert-content","title":"Alert Content","text":"<ul> <li>Make messages actionable: Include enough information to take action</li> <li>Include context: Add relevant metadata (agent ID, resource types, values)</li> <li>Use consistent format: Standardize alert messages for easier parsing</li> <li>Include links: Where appropriate, include links to dashboards or documentation</li> </ul>"},{"location":"guides/notifications/#alert-management","title":"Alert Management","text":"<ul> <li>Implement acknowledgement: Track which alerts have been seen and addressed</li> <li>Group related alerts: Avoid flooding with repetitive notifications</li> <li>Rotate on-call responsibilities: Ensure 24/7 coverage for critical alerts</li> <li>Review alert effectiveness: Periodically audit which alerts are useful</li> </ul>"},{"location":"guides/notifications/#advanced-topics","title":"Advanced Topics","text":""},{"location":"guides/notifications/#building-an-alert-response-runbook","title":"Building an Alert Response Runbook","text":"<pre><code>from safeguards.notification.runbook import Runbook, RemediationStep\n\n# Create a runbook for handling specific alerts\ncpu_limit_runbook = Runbook(\n    name=\"cpu_limit_exceeded\",\n    description=\"Steps to handle CPU limit exceeded alerts\",\n    applies_to=lambda alert: (\n        alert.metadata.get(\"type\") == \"resource_limit\" and\n        alert.metadata.get(\"resource\") == \"cpu\"\n    )\n)\n\n# Add remediation steps\ncpu_limit_runbook.add_step(\n    RemediationStep(\n        name=\"verify_usage\",\n        description=\"Verify current CPU usage\",\n        action=lambda alert: execute_command(\n            f\"check_agent_resource {alert.agent_id} cpu\"\n        )\n    )\n)\n\ncpu_limit_runbook.add_step(\n    RemediationStep(\n        name=\"reduce_priority\",\n        description=\"Reduce agent task priority\",\n        action=lambda alert: execute_command(\n            f\"set_agent_priority {alert.agent_id} low\"\n        )\n    )\n)\n\ncpu_limit_runbook.add_step(\n    RemediationStep(\n        name=\"suspend_if_persistent\",\n        description=\"Suspend agent if issue persists for over 5 minutes\",\n        action=lambda alert: execute_command(\n            f\"suspend_agent {alert.agent_id} --reason 'CPU limit exceeded'\"\n        ) if alert.metadata.get(\"duration_seconds\", 0) &gt; 300 else None\n    )\n)\n\n# Register the runbook\nnotification_manager.register_runbook(cpu_limit_runbook)\n</code></pre>"},{"location":"guides/notifications/#alert-analytics","title":"Alert Analytics","text":"<p>Implement alert analytics:</p> <pre><code>from safeguards.notification.analytics import AlertAnalytics\nfrom datetime import datetime, timedelta\n\n# Create alert analytics\nanalytics = AlertAnalytics(notification_manager)\n\n# Get alert frequency by type\nalert_frequencies = analytics.get_frequency_by_type(\n    start_time=datetime.now() - timedelta(days=7),\n    end_time=datetime.now()\n)\n\n# Get noisiest agents\nnoisy_agents = analytics.get_top_alert_sources(\n    limit=5,\n    start_time=datetime.now() - timedelta(days=7),\n    end_time=datetime.now()\n)\n\n# Get alert patterns by time of day\ntime_patterns = analytics.get_time_patterns(\n    interval_minutes=60,\n    start_time=datetime.now() - timedelta(days=7),\n    end_time=datetime.now()\n)\n\n# Generate alert effectiveness report\neffectiveness = analytics.get_effectiveness_report(\n    start_time=datetime.now() - timedelta(days=30),\n    end_time=datetime.now()\n)\n\nprint(\"Alert Frequencies by Type:\", alert_frequencies)\nprint(\"Noisiest Agents:\", noisy_agents)\nprint(\"Time Patterns:\", time_patterns)\nprint(\"Alert Effectiveness:\", effectiveness)\n</code></pre>"},{"location":"guides/notifications/#conclusion","title":"Conclusion","text":"<p>A well-configured notification system is essential for maintaining visibility into agent operations and responding quickly to issues. By properly setting up alert handlers, notification channels, and implementing best practices, you can ensure that the right people receive the right information at the right time.</p> <p>For more information, see: - Monitoring Guide - Safeguards Guide - API Reference</p>"},{"location":"guides/plugins/","title":"Plugin Framework","text":"<p>The Safeguards library includes a flexible plugin framework that allows you to create custom safeguards for your specific use cases, including industry-specific checks and rules.</p>"},{"location":"guides/plugins/#plugin-architecture","title":"Plugin Architecture","text":"<p>The plugin system is based on the <code>SafeguardPlugin</code> abstract base class, which all plugins must extend. Plugins are managed through the <code>PluginManager</code>, which handles registration, configuration, and lifecycle management.</p>"},{"location":"guides/plugins/#plugin-manager","title":"Plugin Manager","text":"<p>The <code>PluginManager</code> provides a central registry for all plugins:</p> <pre><code>from safeguards.plugins import PluginManager\n\n# Create a plugin manager\nplugin_manager = PluginManager()\n\n# Register plugins\nplugin_manager.register_plugin(my_plugin, config={\"key\": \"value\"})\n\n# Get a plugin by name\nmy_plugin = plugin_manager.get_plugin(\"my_plugin_name\")\n\n# List all registered plugins\nplugin_names = plugin_manager.list_plugins()\n\n# Unregister a plugin\nplugin_manager.unregister_plugin(\"my_plugin_name\")\n\n# Shutdown all plugins\nplugin_manager.shutdown_all()\n</code></pre>"},{"location":"guides/plugins/#creating-custom-plugins","title":"Creating Custom Plugins","text":"<p>To create a custom plugin, extend the <code>SafeguardPlugin</code> abstract base class:</p> <pre><code>from safeguards.plugins import SafeguardPlugin\nfrom typing import Dict, Any\n\nclass MyCustomPlugin(SafeguardPlugin):\n    \"\"\"Example custom plugin.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the plugin.\"\"\"\n        self._config = {}\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Return the name of the plugin.\"\"\"\n        return \"my_custom_plugin\"\n\n    @property\n    def version(self) -&gt; str:\n        \"\"\"Return the version of the plugin.\"\"\"\n        return \"1.0.0\"\n\n    def initialize(self, config: Dict[str, Any]) -&gt; None:\n        \"\"\"Initialize the plugin with configuration.\n\n        Args:\n            config: Plugin-specific configuration\n        \"\"\"\n        self._config = config\n        # Perform any initialization based on config\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Clean up resources when shutting down.\"\"\"\n        # Clean up any resources used by the plugin\n</code></pre>"},{"location":"guides/plugins/#industry-specific-safeguards","title":"Industry-Specific Safeguards","text":"<p>The Safeguards library includes pre-built industry-specific safeguards for common use cases. These extend the <code>IndustrySafeguard</code> base class, which itself extends <code>SafeguardPlugin</code>.</p>"},{"location":"guides/plugins/#available-industry-safeguards","title":"Available Industry Safeguards","text":"<p>Currently, the library provides:</p> <ul> <li><code>FinancialServicesSafeguard</code>: For financial services operations</li> <li><code>HealthcareSafeguard</code>: For healthcare operations</li> </ul>"},{"location":"guides/plugins/#using-industry-safeguards","title":"Using Industry Safeguards","text":"<p>Here's how to use a financial services safeguard:</p> <pre><code>from decimal import Decimal\nfrom safeguards.plugins.industry import FinancialServicesSafeguard\nfrom safeguards.types.agent import Agent\n\n# Create and configure the safeguard\nfinancial_safeguard = FinancialServicesSafeguard()\nfinancial_safeguard.initialize({\n    \"restricted_actions\": [\"high_risk_investment\", \"unauthorized_withdrawal\"],\n    \"compliance_rules\": {\n        \"kyc_required\": True,\n        \"aml_check\": True\n    },\n    \"transaction_limits\": {\n        \"agent_1\": Decimal(\"1000.00\")\n    }\n})\n\n# Start monitoring an agent\nfinancial_safeguard.monitor_agent(\"agent_1\")\n\n# Validate an action\nagent = get_agent(\"agent_1\")  # Get your agent instance\naction_context = {\n    \"action_type\": \"transaction\",\n    \"amount\": Decimal(\"1500.00\"),\n    \"description\": \"Investment purchase\"\n}\n\n# Check for violations\nalerts = financial_safeguard.validate_agent_action(agent, action_context)\nif alerts:\n    print(f\"Action violates safeguards: {alerts}\")\nelse:\n    # Proceed with action\n    agent.run(**action_context)\n\n# Stop monitoring when done\nfinancial_safeguard.stop_monitoring_agent(\"agent_1\")\n</code></pre>"},{"location":"guides/plugins/#healthcare-safeguard-example","title":"Healthcare Safeguard Example","text":"<p>Similarly, for healthcare operations:</p> <pre><code>from safeguards.plugins.industry import HealthcareSafeguard\n\n# Create and configure the safeguard\nhealthcare_safeguard = HealthcareSafeguard()\nhealthcare_safeguard.initialize({\n    \"phi_patterns\": [\"SSN\", \"DOB\", \"MRN\"],\n    \"restricted_operations\": [\"mass_record_access\", \"export_all_records\"],\n    \"required_approvals\": {\n        \"prescription\": [\"doctor\", \"pharmacist\"]\n    }\n})\n\n# Monitor and validate as with the financial safeguard\n</code></pre>"},{"location":"guides/plugins/#creating-industry-specific-safeguards","title":"Creating Industry-Specific Safeguards","text":"<p>To create a custom industry safeguard, extend the <code>IndustrySafeguard</code> class:</p> <pre><code>from typing import Dict, Any, List\nfrom safeguards.plugins.industry import IndustrySafeguard\nfrom safeguards.types.agent import Agent\nfrom safeguards.types import SafetyAlert, AlertSeverity\n\nclass RetailSafeguard(IndustrySafeguard):\n    \"\"\"Safeguards specific to the retail industry.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the retail safeguard.\"\"\"\n        super().__init__(\"retail\")\n        self._pricing_limits = {}\n        self._discount_limits = {}\n\n    @property\n    def version(self) -&gt; str:\n        \"\"\"Return the version of the plugin.\"\"\"\n        return \"1.0.0\"\n\n    def initialize(self, config: Dict[str, Any]) -&gt; None:\n        \"\"\"Initialize the plugin with configuration.\"\"\"\n        self._config = config\n        self._pricing_limits = config.get(\"pricing_limits\", {})\n        self._discount_limits = config.get(\"discount_limits\", {})\n        self._initialized = True\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Clean up resources when shutting down.\"\"\"\n        self._initialized = False\n        self._monitored_agents.clear()\n\n    def validate_agent_action(self, agent: Agent, action_context: Dict[str, Any]) -&gt; List[SafetyAlert]:\n        \"\"\"Validate a retail agent action.\"\"\"\n        alerts = []\n\n        # Check pricing within limits\n        if action_context.get(\"action_type\") == \"price_change\":\n            product = action_context.get(\"product\", \"\")\n            price = action_context.get(\"price\", 0)\n            min_price = self._pricing_limits.get(product, {}).get(\"min\", 0)\n            max_price = self._pricing_limits.get(product, {}).get(\"max\", float(\"inf\"))\n\n            if price &lt; min_price:\n                alerts.append(SafetyAlert(\n                    title=\"Price Below Minimum\",\n                    description=f\"Price {price} is below minimum {min_price} for {product}\",\n                    severity=AlertSeverity.WARNING\n                ))\n\n            if price &gt; max_price:\n                alerts.append(SafetyAlert(\n                    title=\"Price Above Maximum\",\n                    description=f\"Price {price} is above maximum {max_price} for {product}\",\n                    severity=AlertSeverity.WARNING\n                ))\n\n        return alerts\n</code></pre>"},{"location":"guides/plugins/#integrating-with-the-safety-controller","title":"Integrating with the Safety Controller","text":"<p>You can integrate your custom safeguards with the <code>SafetyController</code> for centralized management:</p> <pre><code>from safeguards.core.safety_controller import SafetyController\nfrom safeguards.types import SafetyConfig\nfrom safeguards.plugins.industry import FinancialServicesSafeguard\n\n# Create controller\nconfig = SafetyConfig(...)\ncontroller = SafetyController(config)\n\n# Create industry safeguard\nfinancial_safeguard = FinancialServicesSafeguard()\nfinancial_safeguard.initialize({...})\n\n# Register agent with controller and safeguard\nagent = MyAgent(\"agent_1\")\ncontroller.register_agent(agent, budget=Decimal(\"1000.00\"))\nfinancial_safeguard.monitor_agent(agent.id)\n\n# When validating actions, combine checks\ndef execute_safe_action(agent, action_context):\n    # First check controller rules\n    validation = controller.validate_action(agent.id, action_context)\n    if not validation.valid:\n        return {\"success\": False, \"violations\": validation.violations}\n\n    # Then check industry safeguards\n    alerts = financial_safeguard.validate_agent_action(agent, action_context)\n    if alerts:\n        return {\"success\": False, \"alerts\": alerts}\n\n    # If all checks pass, execute the action\n    return agent.run(**action_context)\n</code></pre>"},{"location":"guides/resilience/","title":"Resilience Patterns Guide","text":"<p>This guide explains how to use the built-in resilience patterns in Safeguards to create robust, fault-tolerant applications that can gracefully handle transient failures.</p>"},{"location":"guides/resilience/#overview","title":"Overview","text":"<p>The Safeguards framework provides several resilience patterns to help your application handle failures:</p> <ol> <li>Retry Mechanisms - Automatically retry operations that fail due to transient issues</li> <li>Circuit Breakers - Prevent cascading failures by temporarily disabling failing services</li> <li>Timeouts - Set maximum time limits for operations to prevent resource exhaustion</li> <li>Fallbacks - Provide alternative pathways when primary operations fail</li> </ol> <p>This guide focuses on the retry mechanism with exponential backoff, which is a critical strategy for handling transient failures.</p>"},{"location":"guides/resilience/#retry-handler-with-exponential-backoff","title":"Retry Handler with Exponential Backoff","text":"<p>The <code>RetryHandler</code> class provides a simple way to add retry behavior to any operation that might fail due to transient issues.</p>"},{"location":"guides/resilience/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to use the <code>RetryHandler</code> is as a decorator:</p> <pre><code>from safeguards.core.resilience import RetryHandler\n\n@RetryHandler(max_attempts=3)\ndef fetch_data_from_api(url):\n    # This function will be retried up to 3 times if it raises\n    # a RetryableException, ConnectionError, or TimeoutError\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"guides/resilience/#configuring-retry-behavior","title":"Configuring Retry Behavior","text":"<p>The <code>RetryHandler</code> is highly configurable:</p> <pre><code>from safeguards.core.resilience import RetryHandler, RetryStrategy\n\n@RetryHandler(\n    max_attempts=5,               # Maximum number of attempts\n    strategy=RetryStrategy.EXPONENTIAL,  # Use exponential backoff\n    base_delay=1.0,               # Start with 1 second delay\n    max_delay=30.0,               # Cap delay at 30 seconds\n    jitter=0.1,                  # Add 10% random jitter to delay\n    retryable_exceptions=[ConnectionError, TimeoutError, ValueError]\n)\ndef fetch_data_from_api(url):\n    # This will be retried with exponential backoff\n    # if it raises any of the specified exceptions\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"guides/resilience/#retry-strategies","title":"Retry Strategies","text":"<p>The <code>RetryHandler</code> supports three retry strategies:</p> <ol> <li>Fixed - Uses the same delay between each retry attempt</li> <li>Linear - Increases delay linearly between retry attempts</li> <li>Exponential - Increases delay exponentially between retry attempts (recommended for most cases)</li> </ol> <pre><code>from safeguards.core.resilience import RetryHandler, RetryStrategy\n\n# Fixed delay of 2 seconds between each retry\n@RetryHandler(\n    max_attempts=3,\n    strategy=RetryStrategy.FIXED,\n    base_delay=2.0\n)\ndef example_fixed():\n    # Function implementation...\n\n# Linear delay: 1s, 2s, 3s, 4s, ...\n@RetryHandler(\n    max_attempts=5,\n    strategy=RetryStrategy.LINEAR,\n    base_delay=1.0\n)\ndef example_linear():\n    # Function implementation...\n\n# Exponential delay: 1s, 2s, 4s, 8s, 16s, ...\n@RetryHandler(\n    max_attempts=5,\n    strategy=RetryStrategy.EXPONENTIAL,\n    base_delay=1.0\n)\ndef example_exponential():\n    # Function implementation...\n</code></pre>"},{"location":"guides/resilience/#using-as-a-context-manager","title":"Using as a Context Manager","text":"<p>For more control over retries, you can use <code>RetryHandler</code> as a context manager:</p> <pre><code>from safeguards.core.resilience import RetryHandler\n\ndef process_data(data_url):\n    retry_handler = RetryHandler(\n        max_attempts=3,\n        base_delay=1.0\n    )\n\n    try:\n        with retry_handler:\n            # Operations in this block will be retried\n            response = requests.get(data_url)\n            response.raise_for_status()\n            data = response.json()\n            return process_json_data(data)\n    except Exception as e:\n        # Handle non-retryable exceptions or max retries exceeded\n        logger.error(f\"Failed to process data after {retry_handler.attempt} attempts: {str(e)}\")\n        return None\n</code></pre>"},{"location":"guides/resilience/#custom-retryable-exceptions","title":"Custom Retryable Exceptions","text":"<p>You can define custom exception types that should trigger retries:</p> <pre><code>from safeguards.core.resilience import RetryHandler, RetryableException\n\n# Define a custom exception that should be retried\nclass APIRateLimitError(RetryableException):\n    pass\n\n# All RetryableException subclasses will be retried by default\n@RetryHandler(max_attempts=5)\ndef call_rate_limited_api():\n    if is_rate_limited():\n        raise APIRateLimitError(\"Rate limit exceeded, try again later\")\n    return get_api_data()\n</code></pre> <p>Alternatively, you can specify exactly which exceptions should be retried:</p> <pre><code>@RetryHandler(\n    max_attempts=3,\n    retryable_exceptions=[ConnectionError, APIRateLimitError]\n)\ndef call_api():\n    # Only ConnectionError and APIRateLimitError will trigger retries\n    # Other exceptions will propagate immediately\n    return get_api_data()\n</code></pre>"},{"location":"guides/resilience/#handling-retry-failures","title":"Handling Retry Failures","text":"<p>When all retry attempts fail, the <code>RetryHandler</code> will raise a <code>MaxRetriesExceeded</code> exception:</p> <pre><code>from safeguards.core.resilience import RetryHandler, MaxRetriesExceeded\n\n@RetryHandler(max_attempts=3)\ndef fetch_data():\n    # Implementation that might fail\n\ntry:\n    data = fetch_data()\n    process_data(data)\nexcept MaxRetriesExceeded as e:\n    # All retry attempts failed\n    logger.error(f\"Failed after {e.max_attempts} attempts: {str(e.last_exception)}\")\n    # Implement fallback behavior here\n</code></pre>"},{"location":"guides/resilience/#combining-with-circuit-breakers","title":"Combining with Circuit Breakers","text":"<p>For maximum resilience, you can combine retry mechanisms with circuit breakers:</p> <pre><code>from safeguards.core.resilience import RetryHandler\nfrom safeguards.types.guardrail import CircuitBreakerGuardrail\n\n# Create a circuit breaker\ncircuit_breaker = CircuitBreakerGuardrail(\n    failure_threshold=3,\n    reset_timeout_seconds=300  # 5 minutes\n)\n\n# Create a retry handler\n@RetryHandler(max_attempts=3)\ndef call_service_with_retry():\n    return circuit_breaker.run(actual_service_call)\n\ndef actual_service_call():\n    # Actual implementation that might fail\n    return requests.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"guides/resilience/#best-practices","title":"Best Practices","text":"<ol> <li>Use exponential backoff with jitter - This prevents \"thundering herd\" problems where all retries happen simultaneously</li> <li>Set reasonable maximum delays - Balance retry attempts with overall operation latency</li> <li>Identify truly retryable operations - Only retry idempotent operations or operations that can be safely repeated</li> <li>Add logging for retry attempts - This helps diagnose issues during development and production</li> <li>Combine with circuit breakers - For operations calling external services that might be down</li> <li>Set meaningful timeout values - Ensure operations do not hang indefinitely</li> <li>Use fallbacks for critical functionality - Have backup options when all retries fail</li> </ol>"},{"location":"guides/resilience/#common-retry-scenarios","title":"Common Retry Scenarios","text":""},{"location":"guides/resilience/#httpapi-requests","title":"HTTP/API Requests","text":"<pre><code>@RetryHandler(\n    max_attempts=3,\n    retryable_exceptions=[\n        requests.exceptions.ConnectionError,\n        requests.exceptions.Timeout,\n        requests.exceptions.HTTPError  # For 5xx status codes\n    ]\n)\ndef call_api(url, params=None):\n    response = requests.get(url, params=params, timeout=10)\n\n    # Only retry 5xx server errors, not 4xx client errors\n    if response.status_code &gt;= 500:\n        response.raise_for_status()  # Will raise HTTPError\n    elif response.status_code &gt;= 400:\n        # Client errors should not be retried\n        raise ValueError(f\"Client error: {response.status_code}\")\n\n    return response.json()\n</code></pre>"},{"location":"guides/resilience/#database-operations","title":"Database Operations","text":"<pre><code>@RetryHandler(\n    max_attempts=5,\n    strategy=RetryStrategy.EXPONENTIAL,\n    base_delay=0.5,\n    max_delay=10.0,\n    retryable_exceptions=[\n        sqlalchemy.exc.OperationalError,  # Connection/timeout issues\n        sqlalchemy.exc.IntegrityError     # Deadlocks, etc.\n    ]\n)\ndef execute_database_query(session, query):\n    try:\n        result = session.execute(query)\n        session.commit()\n        return result\n    except Exception as e:\n        session.rollback()\n        raise  # Re-raise for retry handler\n</code></pre>"},{"location":"guides/resilience/#file-operations","title":"File Operations","text":"<pre><code>@RetryHandler(\n    max_attempts=3,\n    strategy=RetryStrategy.LINEAR,\n    base_delay=1.0,\n    retryable_exceptions=[\n        IOError,\n        OSError\n    ]\n)\ndef read_file_with_retry(file_path):\n    with open(file_path, 'r') as f:\n        return f.read()\n</code></pre>"},{"location":"guides/resilience/#conclusion","title":"Conclusion","text":"<p>The <code>RetryHandler</code> provides a powerful yet simple way to add resilience to your application. By automatically retrying operations that fail due to transient issues, you can create more robust applications that can handle real-world failure scenarios gracefully.</p> <p>For more advanced resilience patterns, see the other guides in this series:</p> <ul> <li>Circuit Breaker Pattern Guide</li> <li>Fallback Patterns Guide</li> <li>Timeout and Bulkhead Patterns Guide</li> </ul>"},{"location":"guides/safeguards/","title":"Safeguards Guide","text":"<p>This guide covers the essential safety features and best practices for the Safeguards.</p>"},{"location":"guides/safeguards/#core-safety-concepts","title":"Core Safety Concepts","text":"<p>The Safeguards provides several layers of protection to prevent agents from causing harm:</p> <ol> <li>Budget Constraints - Limit resource usage</li> <li>Violation Detection - Identify and report problematic behavior</li> <li>Guardrails - Enforce safety boundaries</li> <li>Monitoring - Track agent activities in real-time</li> <li>Notifications - Alert operators to potential issues</li> </ol>"},{"location":"guides/safeguards/#setting-up-safety-components","title":"Setting Up Safety Components","text":""},{"location":"guides/safeguards/#notification-manager","title":"Notification Manager","text":"<p>The <code>NotificationManager</code> is the central component for safety alerts:</p> <pre><code>from safeguards.core.notification_manager import NotificationManager\nfrom safeguards.types import AlertSeverity\n\n# Create a notification manager\nnotification_manager = NotificationManager()\n\n# Register a handler for alerts\ndef alert_handler(alert):\n    print(f\"Alert received: {alert.message}\")\n    print(f\"Severity: {alert.severity.name}\")\n    print(f\"Agent ID: {alert.agent_id}\")\n    print(f\"Timestamp: {alert.timestamp}\")\n\n    # Custom handling logic based on severity\n    if alert.severity == AlertSeverity.CRITICAL:\n        # Take immediate action (e.g., shutdown agent)\n        pass\n    elif alert.severity == AlertSeverity.HIGH:\n        # Log and notify on-call personnel\n        pass\n\n    # Return True to acknowledge handling\n    return True\n\n# Add the handler\nnotification_manager.add_handler(alert_handler)\n</code></pre>"},{"location":"guides/safeguards/#violation-reporter","title":"Violation Reporter","text":"<p>The <code>ViolationReporter</code> detects and reports safety violations:</p> <pre><code>from safeguards.monitoring.violation_reporter import ViolationReporter\nfrom safeguards.types import ViolationType, AlertSeverity\n\n# Create a violation reporter\nviolation_reporter = ViolationReporter(notification_manager)\n\n# Report a violation\nviolation_reporter.report_violation(\n    agent_id=\"agent123\",\n    violation_type=ViolationType.UNAUTHORIZED_ACTION,\n    severity=AlertSeverity.HIGH,\n    message=\"Agent attempted unauthorized system access\",\n    details={\n        \"action\": \"file_access\",\n        \"target\": \"/etc/passwd\",\n        \"timestamp\": \"2023-05-15T14:30:00Z\"\n    }\n)\n</code></pre>"},{"location":"guides/safeguards/#safety-api","title":"Safety API","text":"<p>The Safety API provides a unified interface for safety operations:</p> <pre><code>from safeguards.api import APIFactory, APIVersion\n\n# Create API factory\napi_factory = APIFactory()\n\n# Create safety API\nsafety_api = api_factory.create_safety_api(\n    version=APIVersion.V1,\n    notification_manager=notification_manager,\n    violation_reporter=violation_reporter\n)\n\n# Configure safety policy\nsafety_api.configure_safety_policy(\n    policy_name=\"strict_policy\",\n    config={\n        \"allowed_actions\": [\"read_file\", \"write_file\", \"network_request\"],\n        \"blocked_domains\": [\"malicious-site.com\"],\n        \"max_token_usage\": 10000,\n        \"require_approval_for\": [\"system_command\", \"payment_processing\"]\n    }\n)\n</code></pre>"},{"location":"guides/safeguards/#safety-guardrails","title":"Safety Guardrails","text":""},{"location":"guides/safeguards/#implementing-action-filters","title":"Implementing Action Filters","text":"<p>Action filters prevent agents from performing unsafe actions:</p> <pre><code>from safeguards.guardrails.action_filter import ActionFilter\nfrom safeguards.types.agent import AgentAction, AgentActionResult\n\n# Create a custom action filter\nclass NetworkAccessFilter(ActionFilter):\n    def __init__(self, allowed_domains=None):\n        self.allowed_domains = allowed_domains or []\n\n    def filter(self, agent_id, action):\n        if action.action_type == \"network_request\":\n            target_domain = self._extract_domain(action.parameters.get(\"url\", \"\"))\n\n            if target_domain not in self.allowed_domains:\n                return AgentActionResult(\n                    success=False,\n                    result=None,\n                    error=\"Domain not in allowed list\",\n                    metadata={\n                        \"blocked_domain\": target_domain,\n                        \"allowed_domains\": self.allowed_domains\n                    }\n                )\n\n        # Allow action to proceed\n        return None\n\n    def _extract_domain(self, url):\n        # Simple domain extraction logic\n        if url.startswith(\"http\"):\n            parts = url.split(\"/\")\n            if len(parts) &gt; 2:\n                return parts[2]\n        return url\n\n# Register the filter with the safety API\nnetwork_filter = NetworkAccessFilter(\n    allowed_domains=[\"api.example.com\", \"data.example.org\"]\n)\nsafety_api.register_action_filter(network_filter)\n</code></pre>"},{"location":"guides/safeguards/#content-monitoring","title":"Content Monitoring","text":"<p>Monitor agent-generated content for safety issues:</p> <pre><code>from safeguards.guardrails.content_monitor import ContentMonitor\nfrom safeguards.types import AlertSeverity\n\n# Create a custom content monitor\nclass SensitiveDataMonitor(ContentMonitor):\n    def __init__(self, patterns=None):\n        self.patterns = patterns or [\n            r'\\b\\d{3}-\\d{2}-\\d{4}\\b',  # SSN pattern\n            r'\\b\\d{16}\\b',  # Credit card pattern\n            r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'  # Email\n        ]\n\n    def analyze(self, agent_id, content):\n        import re\n\n        findings = []\n        for pattern in self.patterns:\n            matches = re.findall(pattern, content)\n            if matches:\n                findings.append({\n                    \"pattern\": pattern,\n                    \"match_count\": len(matches),\n                    \"risk\": AlertSeverity.HIGH\n                })\n\n        if findings:\n            # Report violation\n            violation_reporter.report_violation(\n                agent_id=agent_id,\n                violation_type=ViolationType.SENSITIVE_DATA_EXPOSURE,\n                severity=AlertSeverity.HIGH,\n                message=\"Agent attempted to output sensitive data\",\n                details={\"findings\": findings}\n            )\n\n            # Return redacted content\n            redacted = content\n            for pattern in self.patterns:\n                redacted = re.sub(pattern, \"[REDACTED]\", redacted)\n            return redacted\n\n        # Return original content if no issues found\n        return content\n\n# Register the monitor\nsensitive_data_monitor = SensitiveDataMonitor()\nsafety_api.register_content_monitor(sensitive_data_monitor)\n</code></pre>"},{"location":"guides/safeguards/#resource-constraints","title":"Resource Constraints","text":"<p>Implement resource constraints to prevent overuse:</p> <pre><code>from safeguards.guardrails.resource_monitor import ResourceMonitor\nfrom decimal import Decimal\n\n# Create a custom resource monitor\nclass TokenUsageMonitor(ResourceMonitor):\n    def __init__(self, token_limit):\n        self.token_limit = token_limit\n        self.token_counts = {}\n\n    def check(self, agent_id, usage):\n        # Initialize if not present\n        if agent_id not in self.token_counts:\n            self.token_counts[agent_id] = 0\n\n        # Update count\n        self.token_counts[agent_id] += usage\n        current_usage = self.token_counts[agent_id]\n\n        # Check if limit exceeded\n        if current_usage &gt; self.token_limit:\n            # Report violation\n            violation_reporter.report_violation(\n                agent_id=agent_id,\n                violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n                severity=AlertSeverity.MEDIUM,\n                message=f\"Token usage limit exceeded: {current_usage}/{self.token_limit}\",\n                details={\n                    \"limit\": self.token_limit,\n                    \"usage\": current_usage,\n                    \"overage\": current_usage - self.token_limit\n                }\n            )\n            return False\n\n        # Return True if within limits\n        return True\n\n    def reset(self, agent_id):\n        if agent_id in self.token_counts:\n            self.token_counts[agent_id] = 0\n\n# Register the monitor\ntoken_monitor = TokenUsageMonitor(token_limit=10000)\nsafety_api.register_resource_monitor(token_monitor)\n</code></pre>"},{"location":"guides/safeguards/#behavioral-safety","title":"Behavioral Safety","text":""},{"location":"guides/safeguards/#implementing-safe-agents","title":"Implementing Safe Agents","text":"<p>Create agents with built-in safety features:</p> <pre><code>from safeguards.types.agent import Agent\nfrom safeguards.core.budget_coordination import BudgetCoordinator\n\nclass SafeAgent(Agent):\n    def __init__(self, name, safety_api, **kwargs):\n        super().__init__(name, **kwargs)\n        self.safety_api = safety_api\n\n    def run(self, task, **kwargs):\n        # Safety check before running\n        is_safe = self.safety_api.check_task_safety(\n            agent_id=self.id,\n            task_description=task,\n            context=kwargs\n        )\n\n        if not is_safe:\n            return {\n                \"status\": \"blocked\",\n                \"reason\": \"Task failed safety check\",\n                \"details\": \"The requested task violates safety policies\"\n            }\n\n        # Proceed with the task\n        try:\n            # Task implementation logic\n            result = self._process_task(task, **kwargs)\n\n            # Check output for safety issues\n            safe_result = self.safety_api.check_content_safety(\n                agent_id=self.id,\n                content=result\n            )\n\n            return safe_result\n\n        except Exception as e:\n            # Handle exceptions safely\n            self.safety_api.report_exception(\n                agent_id=self.id,\n                exception=e,\n                context={\n                    \"task\": task,\n                    \"parameters\": kwargs\n                }\n            )\n\n            return {\n                \"status\": \"error\",\n                \"reason\": \"Exception during task execution\",\n                \"details\": str(e)\n            }\n\n    def _process_task(self, task, **kwargs):\n        # Actual task implementation\n        # This would be implemented by specific agent subclasses\n        pass\n</code></pre>"},{"location":"guides/safeguards/#safe-action-execution","title":"Safe Action Execution","text":"<p>Implement safe action execution logic:</p> <pre><code>def execute_action_safely(agent_id, action, safety_api):\n    \"\"\"Execute an action with safety checks.\"\"\"\n    # Check if action is allowed\n    action_result = safety_api.check_action_safety(\n        agent_id=agent_id,\n        action=action\n    )\n\n    if action_result and not action_result.success:\n        # Action was blocked\n        return action_result\n\n    # Action is allowed, proceed with execution\n    try:\n        # Actual action execution logic\n        result = _execute_action(action)\n\n        # Monitor resource usage\n        if hasattr(result, 'resource_usage'):\n            safety_api.track_resource_usage(\n                agent_id=agent_id,\n                resource_type=action.action_type,\n                amount=result.resource_usage\n            )\n\n        return result\n\n    except Exception as e:\n        # Handle and report exception\n        safety_api.report_exception(\n            agent_id=agent_id,\n            exception=e,\n            context={\"action\": action}\n        )\n\n        return AgentActionResult(\n            success=False,\n            result=None,\n            error=str(e)\n        )\n\ndef _execute_action(action):\n    # Implement the logic to execute different action types\n    # This is a placeholder for the actual implementation\n    pass\n</code></pre>"},{"location":"guides/safeguards/#safety-monitoring-and-alerts","title":"Safety Monitoring and Alerts","text":""},{"location":"guides/safeguards/#setting-up-real-time-monitoring","title":"Setting Up Real-time Monitoring","text":"<pre><code>from safeguards.monitoring.metrics_collector import MetricsCollector\nfrom datetime import datetime, timedelta\n\n# Create a metrics collector\nmetrics_collector = MetricsCollector()\n\n# Register with safety API\nsafety_api.register_metrics_collector(metrics_collector)\n\n# Collect and analyze metrics\ndef analyze_safeguards(agent_id, time_window=24):\n    # Get metrics for the last 'time_window' hours\n    start_time = datetime.now() - timedelta(hours=time_window)\n    metrics = metrics_collector.get_agent_metrics(\n        agent_id=agent_id,\n        start_time=start_time.isoformat(),\n        end_time=datetime.now().isoformat()\n    )\n\n    # Analyze violations\n    violations = metrics.get(\"violations\", [])\n    violation_count = len(violations)\n\n    # Analyze resource usage\n    resource_usage = metrics.get(\"resource_usage\", {})\n    token_usage = resource_usage.get(\"token_usage\", 0)\n\n    # Check action patterns\n    actions = metrics.get(\"actions\", [])\n    action_types = {}\n    for action in actions:\n        action_type = action.get(\"action_type\", \"unknown\")\n        action_types[action_type] = action_types.get(action_type, 0) + 1\n\n    # Generate safety report\n    safety_score = calculate_safety_score(\n        violation_count=violation_count,\n        token_usage=token_usage,\n        action_types=action_types\n    )\n\n    return {\n        \"agent_id\": agent_id,\n        \"safety_score\": safety_score,\n        \"time_window_hours\": time_window,\n        \"violation_count\": violation_count,\n        \"token_usage\": token_usage,\n        \"action_patterns\": action_types,\n        \"recommendations\": generate_safety_recommendations(safety_score)\n    }\n\ndef calculate_safety_score(violation_count, token_usage, action_types):\n    # Example scoring algorithm\n    # This would be more sophisticated in production\n    base_score = 100\n\n    # Deduct for violations\n    violation_penalty = min(violation_count * 10, 50)\n\n    # Deduct for excessive token usage\n    token_penalty = 0\n    if token_usage &gt; 10000:\n        token_penalty = min((token_usage - 10000) / 1000, 30)\n\n    # Check for suspicious action patterns\n    action_penalty = 0\n    suspicious_actions = action_types.get(\"system_command\", 0) + action_types.get(\"network_request\", 0)\n    if suspicious_actions &gt; 10:\n        action_penalty = min(suspicious_actions, 20)\n\n    final_score = max(base_score - violation_penalty - token_penalty - action_penalty, 0)\n    return final_score\n\ndef generate_safety_recommendations(safety_score):\n    if safety_score &lt; 50:\n        return [\n            \"Consider suspending agent activity for review\",\n            \"Implement stricter action filters\",\n            \"Reduce resource allocations\"\n        ]\n    elif safety_score &lt; 70:\n        return [\n            \"Review recent violations\",\n            \"Monitor agent actions more closely\",\n            \"Consider additional guardrails\"\n        ]\n    elif safety_score &lt; 90:\n        return [\n            \"Regular monitoring recommended\",\n            \"Continue with current safety settings\"\n        ]\n    else:\n        return [\"Agent operating within safe parameters\"]\n</code></pre>"},{"location":"guides/safeguards/#alert-escalation","title":"Alert Escalation","text":"<p>Configure alert escalation based on severity:</p> <pre><code>from safeguards.types import AlertSeverity\n\ndef configure_alert_escalation(notification_manager):\n    \"\"\"Configure different handlers for different alert severities.\"\"\"\n\n    # Handler for low severity alerts\n    def handle_low_alerts(alert):\n        if alert.severity in [AlertSeverity.LOW, AlertSeverity.INFORMATIONAL]:\n            # Log only\n            print(f\"INFO: {alert.message}\")\n            return True\n        return False\n\n    # Handler for medium severity alerts\n    def handle_medium_alerts(alert):\n        if alert.severity == AlertSeverity.MEDIUM:\n            # Log and send notification\n            print(f\"WARNING: {alert.message}\")\n            send_notification(\"security@example.com\", f\"Medium Alert: {alert.message}\")\n            return True\n        return False\n\n    # Handler for high severity alerts\n    def handle_high_alerts(alert):\n        if alert.severity == AlertSeverity.HIGH:\n            # Log, send notification, and take action\n            print(f\"ALERT: {alert.message}\")\n            send_notification(\"oncall@example.com\", f\"High Alert: {alert.message}\")\n\n            # Take immediate action\n            if alert.agent_id:\n                # Example: Reduce agent permissions\n                safety_api.restrict_agent_permissions(\n                    agent_id=alert.agent_id,\n                    restrictions={\"block_external_actions\": True}\n                )\n            return True\n        return False\n\n    # Handler for critical alerts\n    def handle_critical_alerts(alert):\n        if alert.severity == AlertSeverity.CRITICAL:\n            # Log, send emergency notification, and take immediate action\n            print(f\"CRITICAL: {alert.message}\")\n            send_emergency_notification(f\"Critical Alert: {alert.message}\")\n\n            # Example: Suspend agent\n            if alert.agent_id:\n                safety_api.suspend_agent(\n                    agent_id=alert.agent_id,\n                    reason=f\"Critical safety alert: {alert.message}\"\n                )\n            return True\n        return False\n\n    # Add handlers in order (critical first for fastest response)\n    notification_manager.add_handler(handle_critical_alerts)\n    notification_manager.add_handler(handle_high_alerts)\n    notification_manager.add_handler(handle_medium_alerts)\n    notification_manager.add_handler(handle_low_alerts)\n\ndef send_notification(recipient, message):\n    # Implementation would depend on your notification system\n    # Example: email, Slack, etc.\n    pass\n\ndef send_emergency_notification(message):\n    # Implementation for emergency notifications\n    # Example: pager duty, SMS alerts, etc.\n    pass\n</code></pre>"},{"location":"guides/safeguards/#safety-testing","title":"Safety Testing","text":""},{"location":"guides/safeguards/#implementing-safety-tests","title":"Implementing Safety Tests","text":"<p>Create comprehensive tests for safety features:</p> <pre><code>import pytest\nfrom safeguards.core.notification_manager import NotificationManager\nfrom safeguards.monitoring.violation_reporter import ViolationReporter\nfrom safeguards.types import ViolationType, AlertSeverity\n\n# Fixtures for testing\n@pytest.fixture\ndef notification_manager():\n    return NotificationManager()\n\n@pytest.fixture\ndef violation_reporter(notification_manager):\n    return ViolationReporter(notification_manager)\n\n@pytest.fixture\ndef safety_api(notification_manager, violation_reporter):\n    api_factory = APIFactory()\n    return api_factory.create_safety_api(\n        version=APIVersion.V1,\n        notification_manager=notification_manager,\n        violation_reporter=violation_reporter\n    )\n\n@pytest.fixture\ndef test_agent(safety_api):\n    class TestAgent(SafeAgent):\n        def _process_task(self, task, **kwargs):\n            return f\"Processed task: {task}\"\n\n    return TestAgent(\n        name=\"test_agent\",\n        safety_api=safety_api\n    )\n\n# Test basic safety checks\ndef test_basic_safety_check(test_agent, safety_api):\n    # Configure a simple safety policy\n    safety_api.configure_safety_policy(\n        policy_name=\"test_policy\",\n        config={\n            \"blocked_terms\": [\"malicious\", \"harmful\"]\n        }\n    )\n\n    # Test with safe task\n    result = test_agent.run(\"normal task\")\n    assert \"Processed task\" in result\n\n    # Test with unsafe task\n    result = test_agent.run(\"malicious operation\")\n    assert \"blocked\" in result.get(\"status\", \"\")\n\n# Test action filtering\ndef test_action_filtering(test_agent, safety_api):\n    # Register action filter\n    class TestFilter(ActionFilter):\n        def filter(self, agent_id, action):\n            if action.action_type == \"test_action\" and \"block_me\" in action.parameters:\n                return AgentActionResult(\n                    success=False,\n                    error=\"Blocked action\"\n                )\n            return None\n\n    safety_api.register_action_filter(TestFilter())\n\n    # Test allowed action\n    action = AgentAction(\n        action_type=\"test_action\",\n        parameters={\"normal\": \"value\"}\n    )\n    result = execute_action_safely(test_agent.id, action, safety_api)\n    assert result.success\n\n    # Test blocked action\n    action = AgentAction(\n        action_type=\"test_action\",\n        parameters={\"block_me\": \"value\"}\n    )\n    result = execute_action_safely(test_agent.id, action, safety_api)\n    assert not result.success\n\n# Test violation reporting\ndef test_violation_reporting(test_agent, violation_reporter, notification_manager):\n    # Set up alert capture\n    alerts = []\n\n    def capture_alert(alert):\n        alerts.append(alert)\n        return True\n\n    notification_manager.add_handler(capture_alert)\n\n    # Report a violation\n    violation_reporter.report_violation(\n        agent_id=test_agent.id,\n        violation_type=ViolationType.UNAUTHORIZED_ACTION,\n        severity=AlertSeverity.HIGH,\n        message=\"Test violation\"\n    )\n\n    # Check alert was captured\n    assert len(alerts) == 1\n    assert alerts[0].agent_id == test_agent.id\n    assert alerts[0].severity == AlertSeverity.HIGH\n</code></pre>"},{"location":"guides/safeguards/#emergency-response","title":"Emergency Response","text":""},{"location":"guides/safeguards/#implementing-kill-switches","title":"Implementing Kill Switches","text":"<p>Create emergency response mechanisms:</p> <pre><code>class EmergencyControls:\n    def __init__(self, budget_coordinator, notification_manager):\n        self.budget_coordinator = budget_coordinator\n        self.notification_manager = notification_manager\n        self.suspended_agents = set()\n\n    def suspend_agent(self, agent_id, reason=None):\n        \"\"\"Immediately suspend an agent's operations.\"\"\"\n        # Set agent budget to zero\n        try:\n            self.budget_coordinator.update_budget(\n                agent_id=agent_id,\n                amount=Decimal(\"0\")\n            )\n\n            # Track suspended agent\n            self.suspended_agents.add(agent_id)\n\n            # Send notification\n            self.notification_manager.send_alert(\n                agent_id=agent_id,\n                severity=AlertSeverity.HIGH,\n                message=f\"Agent {agent_id} suspended: {reason or 'Emergency suspension'}\"\n            )\n\n            return True\n\n        except Exception as e:\n            # Log failure\n            self.notification_manager.send_alert(\n                agent_id=agent_id,\n                severity=AlertSeverity.CRITICAL,\n                message=f\"Failed to suspend agent {agent_id}: {str(e)}\"\n            )\n            return False\n\n    def suspend_all_agents(self, reason=None):\n        \"\"\"Emergency kill switch for all agents.\"\"\"\n        agent_ids = self.budget_coordinator.get_all_agent_ids()\n        success_count = 0\n\n        for agent_id in agent_ids:\n            if self.suspend_agent(agent_id, reason):\n                success_count += 1\n\n        # Send overall notification\n        self.notification_manager.send_alert(\n            severity=AlertSeverity.CRITICAL,\n            message=f\"Emergency shutdown triggered: {success_count}/{len(agent_ids)} agents suspended. Reason: {reason or 'Emergency procedure'}\"\n        )\n\n        return success_count\n\n    def restore_agent(self, agent_id, budget=None):\n        \"\"\"Restore a suspended agent.\"\"\"\n        if agent_id not in self.suspended_agents:\n            return False\n\n        try:\n            # Set budget to specified amount or default\n            if budget is None:\n                # Get original budget from metadata or use default\n                budget = Decimal(\"10.0\")\n\n            self.budget_coordinator.update_budget(\n                agent_id=agent_id,\n                amount=budget\n            )\n\n            # Remove from suspended list\n            self.suspended_agents.remove(agent_id)\n\n            # Send notification\n            self.notification_manager.send_alert(\n                agent_id=agent_id,\n                severity=AlertSeverity.MEDIUM,\n                message=f\"Agent {agent_id} restored with budget {budget}\"\n            )\n\n            return True\n\n        except Exception as e:\n            # Log failure\n            self.notification_manager.send_alert(\n                agent_id=agent_id,\n                severity=AlertSeverity.HIGH,\n                message=f\"Failed to restore agent {agent_id}: {str(e)}\"\n            )\n            return False\n</code></pre>"},{"location":"guides/safeguards/#safety-best-practices","title":"Safety Best Practices","text":""},{"location":"guides/safeguards/#general-recommendations","title":"General Recommendations","text":"<ol> <li>Defense in Depth - Implement multiple safety layers</li> <li>Principle of Least Privilege - Give agents only the access they need</li> <li>Regular Auditing - Review agent activities and safety logs frequently</li> <li>Graceful Degradation - Plan for safety feature failures</li> <li>Continuous Testing - Test safety systems regularly</li> </ol>"},{"location":"guides/safeguards/#handling-user-interactions","title":"Handling User Interactions","text":"<p>When agents interact with users, follow these practices:</p> <pre><code>def safe_user_interaction(agent_id, user_input, safety_api):\n    \"\"\"Handle user interactions safely.\"\"\"\n    # Sanitize user input\n    sanitized_input = safety_api.sanitize_input(\n        agent_id=agent_id,\n        input_content=user_input\n    )\n\n    # Check input for prompt injection or harmful content\n    input_analysis = safety_api.analyze_user_input(\n        agent_id=agent_id,\n        input_content=sanitized_input\n    )\n\n    if input_analysis.get(\"risk_level\", \"low\") == \"high\":\n        # Handle risky input\n        return {\n            \"status\": \"rejected\",\n            \"reason\": \"Input poses safety risk\",\n            \"details\": input_analysis.get(\"details\", {})\n        }\n\n    # Process the input with safety measures\n    try:\n        # Generate response\n        response = generate_agent_response(agent_id, sanitized_input)\n\n        # Check response for safety issues\n        safe_response = safety_api.check_content_safety(\n            agent_id=agent_id,\n            content=response\n        )\n\n        return {\n            \"status\": \"success\",\n            \"response\": safe_response\n        }\n\n    except Exception as e:\n        # Handle exceptions\n        safety_api.report_exception(\n            agent_id=agent_id,\n            exception=e,\n            context={\"user_input\": sanitized_input}\n        )\n\n        return {\n            \"status\": \"error\",\n            \"reason\": \"Error processing request\",\n            \"details\": str(e)\n        }\n</code></pre>"},{"location":"guides/safeguards/#environment-safety","title":"Environment Safety","text":"<p>Configure safe execution environments:</p> <pre><code>def configure_safe_environment(agent_id, safety_api):\n    \"\"\"Configure a safe execution environment for an agent.\"\"\"\n    # Set resource limits\n    safety_api.set_resource_limits(\n        agent_id=agent_id,\n        limits={\n            \"memory_mb\": 512,\n            \"cpu_time_seconds\": 30,\n            \"storage_mb\": 100,\n            \"network_mb\": 50\n        }\n    )\n\n    # Configure filesystem sandbox\n    safety_api.configure_filesystem_access(\n        agent_id=agent_id,\n        allowed_paths=[\"/data/agent_workspace\"],\n        read_only_paths=[\"/data/shared_resources\"],\n        blocked_paths=[\"/\", \"/etc\", \"/usr\"]\n    )\n\n    # Set network restrictions\n    safety_api.configure_network_access(\n        agent_id=agent_id,\n        allowed_domains=[\"api.example.com\"],\n        allowed_ports=[443],  # HTTPS only\n        block_outbound=True,  # Block all outbound except allowed domains\n        log_all_requests=True\n    )\n\n    # Configure execution timeouts\n    safety_api.set_execution_limits(\n        agent_id=agent_id,\n        limits={\n            \"max_execution_time_seconds\": 60,\n            \"max_consecutive_actions\": 10,\n            \"require_confirmation_after\": 5\n        }\n    )\n\n    return \"Environment configured with safety restrictions\"\n</code></pre>"},{"location":"guides/safeguards/#conclusion","title":"Conclusion","text":"<p>Implementing comprehensive safety measures is critical for developing reliable and trustworthy agent systems. The Safeguards provides the tools and infrastructure needed to monitor, control, and secure agent behavior through multiple layers of protection.</p> <p>For more information, see: - API Reference - Budget Management Guide - Monitoring Guide</p>"},{"location":"guides/safety_policies/","title":"Safeguards Policies Guide","text":"<p>This guide covers how to implement, enforce, and monitor safety policies for AI agents using the Safeguards.</p>"},{"location":"guides/safety_policies/#introduction-to-safety-policies","title":"Introduction to Safety Policies","text":"<p>Safety policies are rules and constraints that govern agent behavior to prevent harmful, unethical, or unexpected actions. The Safeguards provides a structured approach to defining and enforcing these policies.</p>"},{"location":"guides/safety_policies/#core-policy-components","title":"Core Policy Components","text":"<p>The framework's policy system consists of:</p> <ul> <li>Policy Rules: Specific constraints that agents must follow</li> <li>Policy Enforcer: Component that checks agent actions against rules</li> <li>Policy Violations: Records of rule breaches</li> <li>Remediation Actions: Automated responses to violations</li> </ul>"},{"location":"guides/safety_policies/#implementing-basic-safety-policies","title":"Implementing Basic Safety Policies","text":""},{"location":"guides/safety_policies/#creating-a-policy-set","title":"Creating a Policy Set","text":"<p>Start by defining a set of safety policies:</p> <pre><code>from safeguards.policies import PolicySet, PolicyRule\nfrom safeguards.types import (\n    PolicySeverity,\n    ViolationType,\n    AlertSeverity,\n    RemediationActionType\n)\n\n# Create a policy set\npolicy_set = PolicySet(\n    name=\"basic_safety_policies\",\n    description=\"Core safety rules for all agents\"\n)\n\n# Add resource usage policies\npolicy_set.add_rule(\n    PolicyRule(\n        name=\"max_budget_usage\",\n        description=\"Limit agent budget consumption\",\n        check_function=lambda agent_id, context:\n            context.get(\"used_budget\", 0) &lt;= context.get(\"max_budget\", 100),\n        violation_type=ViolationType.BUDGET_LIMIT_EXCEEDED,\n        severity=PolicySeverity.HIGH\n    )\n)\n\n# Add rate limiting policy\npolicy_set.add_rule(\n    PolicyRule(\n        name=\"api_rate_limit\",\n        description=\"Limit API call frequency\",\n        check_function=lambda agent_id, context:\n            context.get(\"api_calls_per_minute\", 0) &lt;= 60,\n        violation_type=ViolationType.RATE_LIMIT_EXCEEDED,\n        severity=PolicySeverity.MEDIUM\n    )\n)\n\n# Add content policy\npolicy_set.add_rule(\n    PolicyRule(\n        name=\"content_safety\",\n        description=\"Prevent generation of harmful content\",\n        check_function=lambda agent_id, context:\n            not contains_harmful_content(context.get(\"generated_content\", \"\")),\n        violation_type=ViolationType.HARMFUL_CONTENT,\n        severity=PolicySeverity.CRITICAL\n    )\n)\n\n# Helper function for content checking\ndef contains_harmful_content(content):\n    \"\"\"Check if content contains harmful material.\"\"\"\n    # Implement your content safety checks here\n    # This is a placeholder implementation\n    harmful_patterns = [\n        \"how to hack\", \"illegal activities\", \"violence against\"\n    ]\n    return any(pattern in content.lower() for pattern in harmful_patterns)\n</code></pre>"},{"location":"guides/safety_policies/#setting-up-policy-enforcement","title":"Setting Up Policy Enforcement","text":"<p>Configure the policy enforcer to apply your policies:</p> <pre><code>from safeguards.policies import PolicyEnforcer\nfrom safeguards.core import NotificationManager, ViolationReporter\n\n# Create dependencies\nnotification_manager = NotificationManager()\nviolation_reporter = ViolationReporter(notification_manager)\n\n# Create policy enforcer\npolicy_enforcer = PolicyEnforcer(\n    policy_sets=[policy_set],\n    violation_reporter=violation_reporter\n)\n\n# Check agent action against policies\naction_context = {\n    \"agent_id\": \"agent123\",\n    \"action_type\": \"generate_content\",\n    \"generated_content\": \"Here's information about machine learning optimization.\",\n    \"used_budget\": 75,\n    \"max_budget\": 100,\n    \"api_calls_per_minute\": 30\n}\n\n# Enforce policies on the action\nresult = policy_enforcer.check_action(\n    agent_id=\"agent123\",\n    action_context=action_context\n)\n\nif result.allowed:\n    print(\"Action complies with all policies\")\nelse:\n    print(f\"Action denied: {result.violation_details['message']}\")\n    print(f\"Violated rule: {result.violation_details['rule_name']}\")\n</code></pre>"},{"location":"guides/safety_policies/#building-comprehensive-policy-systems","title":"Building Comprehensive Policy Systems","text":"<p>Here's a complete example that sets up an advanced policy system:</p> <pre><code>from safeguards.policies import (\n    PolicySet,\n    PolicyRule,\n    PolicyEnforcer,\n    RemediationAction\n)\nfrom safeguards.core import (\n    NotificationManager,\n    ViolationReporter,\n    BudgetCoordinator\n)\nfrom safeguards.types import (\n    PolicySeverity,\n    ViolationType,\n    AlertSeverity,\n    RemediationActionType\n)\nfrom safeguards.monitoring import MetricsCollector\n\ndef setup_policy_system():\n    \"\"\"Set up a comprehensive policy system.\"\"\"\n\n    # Create core components\n    notification_manager = NotificationManager()\n    violation_reporter = ViolationReporter(notification_manager)\n    budget_coordinator = BudgetCoordinator(notification_manager)\n    metrics_collector = MetricsCollector()\n\n    # Create resource usage policy set\n    resource_policies = PolicySet(\n        name=\"resource_policies\",\n        description=\"Policies governing resource usage\"\n    )\n\n    resource_policies.add_rule(\n        PolicyRule(\n            name=\"budget_limit\",\n            description=\"Agents must stay within allocated budget\",\n            check_function=lambda agent_id, context:\n                check_budget_compliance(agent_id, context, budget_coordinator),\n            violation_type=ViolationType.BUDGET_LIMIT_EXCEEDED,\n            severity=PolicySeverity.HIGH\n        )\n    )\n\n    resource_policies.add_rule(\n        PolicyRule(\n            name=\"cpu_usage_limit\",\n            description=\"Agents must not exceed CPU allocation\",\n            check_function=lambda agent_id, context:\n                context.get(\"cpu_usage_percent\", 0) &lt;= 80,\n            violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n            severity=PolicySeverity.MEDIUM\n        )\n    )\n\n    resource_policies.add_rule(\n        PolicyRule(\n            name=\"memory_usage_limit\",\n            description=\"Agents must not exceed memory allocation\",\n            check_function=lambda agent_id, context:\n                context.get(\"memory_usage_mb\", 0) &lt;= 512,\n            violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n            severity=PolicySeverity.MEDIUM\n        )\n    )\n\n    # Create operational policy set\n    operational_policies = PolicySet(\n        name=\"operational_policies\",\n        description=\"Policies governing agent operations\"\n    )\n\n    operational_policies.add_rule(\n        PolicyRule(\n            name=\"api_rate_limiting\",\n            description=\"Limit API call frequency\",\n            check_function=lambda agent_id, context:\n                check_api_rate(agent_id, context, metrics_collector),\n            violation_type=ViolationType.RATE_LIMIT_EXCEEDED,\n            severity=PolicySeverity.MEDIUM\n        )\n    )\n\n    operational_policies.add_rule(\n        PolicyRule(\n            name=\"authorized_actions_only\",\n            description=\"Agents can only perform authorized actions\",\n            check_function=lambda agent_id, context:\n                is_action_authorized(agent_id, context),\n            violation_type=ViolationType.UNAUTHORIZED_ACTION,\n            severity=PolicySeverity.HIGH\n        )\n    )\n\n    # Create content safety policy set\n    content_policies = PolicySet(\n        name=\"content_policies\",\n        description=\"Policies governing content generation\"\n    )\n\n    content_policies.add_rule(\n        PolicyRule(\n            name=\"harmful_content_prevention\",\n            description=\"Prevent generation of harmful content\",\n            check_function=lambda agent_id, context:\n                not contains_harmful_content(context.get(\"content\", \"\")),\n            violation_type=ViolationType.HARMFUL_CONTENT,\n            severity=PolicySeverity.CRITICAL\n        )\n    )\n\n    content_policies.add_rule(\n        PolicyRule(\n            name=\"personal_data_protection\",\n            description=\"Prevent exposure of personal data\",\n            check_function=lambda agent_id, context:\n                not contains_personal_data(context.get(\"content\", \"\")),\n            violation_type=ViolationType.PRIVACY_VIOLATION,\n            severity=PolicySeverity.CRITICAL\n        )\n    )\n\n    # Set up remediation actions\n    remediation_actions = [\n        RemediationAction(\n            violation_type=ViolationType.BUDGET_LIMIT_EXCEEDED,\n            action_type=RemediationActionType.THROTTLE,\n            parameters={\"duration_seconds\": 300}  # Throttle for 5 minutes\n        ),\n        RemediationAction(\n            violation_type=ViolationType.HARMFUL_CONTENT,\n            action_type=RemediationActionType.BLOCK,\n            parameters={}  # Block the action completely\n        ),\n        RemediationAction(\n            violation_type=ViolationType.RATE_LIMIT_EXCEEDED,\n            action_type=RemediationActionType.DELAY,\n            parameters={\"delay_seconds\": 10}  # Add delay to slow down\n        ),\n        RemediationAction(\n            violation_type=ViolationType.UNAUTHORIZED_ACTION,\n            action_type=RemediationActionType.BLOCK,\n            parameters={}  # Block unauthorized actions\n        ),\n        RemediationAction(\n            violation_type=ViolationType.PRIVACY_VIOLATION,\n            action_type=RemediationActionType.BLOCK,\n            parameters={}  # Block privacy violations\n        )\n    ]\n\n    # Create the policy enforcer with all policy sets\n    policy_enforcer = PolicyEnforcer(\n        policy_sets=[resource_policies, operational_policies, content_policies],\n        violation_reporter=violation_reporter,\n        remediation_actions=remediation_actions\n    )\n\n    return {\n        \"policy_enforcer\": policy_enforcer,\n        \"violation_reporter\": violation_reporter,\n        \"notification_manager\": notification_manager,\n        \"budget_coordinator\": budget_coordinator,\n        \"metrics_collector\": metrics_collector\n    }\n\n# Helper functions for policy checks\ndef check_budget_compliance(agent_id, context, budget_coordinator):\n    \"\"\"Check if the agent is within budget limits.\"\"\"\n    try:\n        budget_info = budget_coordinator.get_agent_metrics(agent_id)\n        remaining_percentage = (budget_info[\"remaining_budget\"] /\n                               budget_info[\"initial_budget\"]) * 100\n        return remaining_percentage &gt;= 10  # At least 10% budget must remain\n    except Exception:\n        # If we can't get budget info, fail closed\n        return False\n\ndef check_api_rate(agent_id, context, metrics_collector):\n    \"\"\"Check if the agent is respecting API rate limits.\"\"\"\n    try:\n        # Get API calls in the last minute\n        api_calls = metrics_collector.get_metric_value(\n            agent_id=agent_id,\n            metric_name=\"api_calls\",\n            time_window_seconds=60\n        )\n        return api_calls &lt;= context.get(\"max_api_calls_per_minute\", 60)\n    except Exception:\n        # If we can't get metrics, use context data if available\n        return context.get(\"api_calls_per_minute\", 0) &lt;= context.get(\"max_api_calls_per_minute\", 60)\n\ndef is_action_authorized(agent_id, context):\n    \"\"\"Check if the action is authorized for the agent.\"\"\"\n    action = context.get(\"action\", \"\")\n    authorized_actions = context.get(\"authorized_actions\", [])\n    return action in authorized_actions\n\ndef contains_personal_data(content):\n    \"\"\"Check if content contains personal data.\"\"\"\n    # Implement your personal data detection logic\n    # This is a placeholder implementation\n    import re\n    # Check for patterns like email addresses, phone numbers, etc.\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    phone_pattern = r'\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b'\n    ssn_pattern = r'\\b\\d{3}-\\d{2}-\\d{4}\\b'\n\n    return (re.search(email_pattern, content) is not None or\n            re.search(phone_pattern, content) is not None or\n            re.search(ssn_pattern, content) is not None)\n\n# Example usage\ndef example_policy_enforcement():\n    \"\"\"Demonstrate policy enforcement.\"\"\"\n\n    # Set up the policy system\n    system = setup_policy_system()\n    policy_enforcer = system[\"policy_enforcer\"]\n\n    # Example actions to check\n    actions = [\n        {\n            \"agent_id\": \"agent123\",\n            \"action\": \"generate_text\",\n            \"content\": \"Here's how to optimize your machine learning model.\",\n            \"cpu_usage_percent\": 45,\n            \"memory_usage_mb\": 256,\n            \"authorized_actions\": [\"generate_text\", \"analyze_data\"],\n            \"max_api_calls_per_minute\": 100\n        },\n        {\n            \"agent_id\": \"agent123\",\n            \"action\": \"access_database\",\n            \"content\": \"Retrieving user records\",\n            \"cpu_usage_percent\": 30,\n            \"memory_usage_mb\": 200,\n            \"authorized_actions\": [\"generate_text\", \"analyze_data\"],\n            \"max_api_calls_per_minute\": 100\n        },\n        {\n            \"agent_id\": \"agent123\",\n            \"action\": \"generate_text\",\n            \"content\": \"Here's how to hack into a password-protected system and steal data.\",\n            \"cpu_usage_percent\": 60,\n            \"memory_usage_mb\": 300,\n            \"authorized_actions\": [\"generate_text\", \"analyze_data\"],\n            \"max_api_calls_per_minute\": 100\n        }\n    ]\n\n    # Check each action against policies\n    for i, action_context in enumerate(actions):\n        print(f\"\\nChecking action {i+1}: {action_context['action']}\")\n        result = policy_enforcer.check_action(\n            agent_id=action_context[\"agent_id\"],\n            action_context=action_context\n        )\n\n        if result.allowed:\n            print(\"\u2705 Action allowed: Complies with all policies\")\n        else:\n            print(f\"\u274c Action denied: {result.violation_details['message']}\")\n            print(f\"   Violated rule: {result.violation_details['rule_name']}\")\n            print(f\"   Violation type: {result.violation_details['violation_type']}\")\n            print(f\"   Severity: {result.violation_details['severity']}\")\n            print(f\"   Remediation: {result.remediation.action_type if result.remediation else 'None'}\")\n</code></pre>"},{"location":"guides/safety_policies/#working-with-action-contexts","title":"Working with Action Contexts","text":"<p>The action context is a key concept in policy enforcement, containing all relevant information about an agent's action:</p> <pre><code># Basic action context for text generation\ntext_generation_context = {\n    \"action\": \"generate_text\",\n    \"content\": \"Here's the information you requested about machine learning.\",\n    \"model\": \"gpt-4\",\n    \"prompt_tokens\": 125,\n    \"completion_tokens\": 350,\n    \"total_tokens\": 475,\n    \"authorized_actions\": [\"generate_text\", \"analyze_data\", \"summarize\"]\n}\n\n# Rich action context with additional metadata\nrich_context = {\n    \"action\": \"data_analysis\",\n    \"content\": \"Analysis complete. Found 3 anomalies in the dataset.\",\n    \"data_sources\": [\"customer_database\", \"transaction_logs\"],\n    \"analysis_type\": \"anomaly_detection\",\n    \"cpu_usage_percent\": 65,\n    \"memory_usage_mb\": 420,\n    \"execution_time_seconds\": 12.3,\n    \"api_calls\": 8,\n    \"api_calls_per_minute\": 40,\n    \"max_api_calls_per_minute\": 100,\n    \"used_budget\": 45.6,\n    \"max_budget\": 100,\n    \"authorized_actions\": [\"analyze_data\", \"generate_report\"],\n    \"user_id\": \"user_12345\",\n    \"sensitivity_level\": \"confidential\",\n    \"metadata\": {\n        \"version\": \"1.0.3\",\n        \"environment\": \"production\",\n        \"request_id\": \"req_789012\"\n    }\n}\n</code></pre>"},{"location":"guides/safety_policies/#policy-rule-templates","title":"Policy Rule Templates","text":"<p>Here are templates for common safety policy rules:</p>"},{"location":"guides/safety_policies/#resource-usage-policies","title":"Resource Usage Policies","text":"<pre><code># Maximum budget policy\nbudget_rule = PolicyRule(\n    name=\"max_budget_limit\",\n    description=\"Limit total budget consumption\",\n    check_function=lambda agent_id, context:\n        context.get(\"used_budget\", 0) &lt;= context.get(\"max_budget\", 100),\n    violation_type=ViolationType.BUDGET_LIMIT_EXCEEDED,\n    severity=PolicySeverity.HIGH\n)\n\n# CPU limit policy\ncpu_rule = PolicyRule(\n    name=\"cpu_usage_limit\",\n    description=\"Limit CPU usage\",\n    check_function=lambda agent_id, context:\n        context.get(\"cpu_usage_percent\", 0) &lt;= 80,\n    violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n    severity=PolicySeverity.MEDIUM\n)\n\n# Memory limit policy\nmemory_rule = PolicyRule(\n    name=\"memory_usage_limit\",\n    description=\"Limit memory usage\",\n    check_function=lambda agent_id, context:\n        context.get(\"memory_usage_mb\", 0) &lt;= 512,\n    violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n    severity=PolicySeverity.MEDIUM\n)\n\n# Token consumption policy\ntoken_rule = PolicyRule(\n    name=\"token_usage_limit\",\n    description=\"Limit token usage per request\",\n    check_function=lambda agent_id, context:\n        context.get(\"total_tokens\", 0) &lt;= 4000,\n    violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n    severity=PolicySeverity.LOW\n)\n</code></pre>"},{"location":"guides/safety_policies/#access-control-policies","title":"Access Control Policies","text":"<pre><code># Authorized actions policy\nauthorized_actions_rule = PolicyRule(\n    name=\"authorized_actions_only\",\n    description=\"Only permit explicitly authorized actions\",\n    check_function=lambda agent_id, context:\n        context.get(\"action\", \"\") in context.get(\"authorized_actions\", []),\n    violation_type=ViolationType.UNAUTHORIZED_ACTION,\n    severity=PolicySeverity.HIGH\n)\n\n# Data access policy\ndata_access_rule = PolicyRule(\n    name=\"data_access_control\",\n    description=\"Only access authorized data sources\",\n    check_function=lambda agent_id, context:\n        all(source in context.get(\"authorized_data_sources\", [])\n            for source in context.get(\"data_sources\", [])),\n    violation_type=ViolationType.UNAUTHORIZED_ACCESS,\n    severity=PolicySeverity.HIGH\n)\n\n# Authentication policy\nauthentication_rule = PolicyRule(\n    name=\"valid_authentication\",\n    description=\"Ensure proper authentication for actions\",\n    check_function=lambda agent_id, context:\n        context.get(\"authenticated\", False) is True,\n    violation_type=ViolationType.AUTHENTICATION_FAILURE,\n    severity=PolicySeverity.CRITICAL\n)\n</code></pre>"},{"location":"guides/safety_policies/#content-safety-policies","title":"Content Safety Policies","text":"<pre><code># Harmful content prevention\nharmful_content_rule = PolicyRule(\n    name=\"harmful_content_prevention\",\n    description=\"Prevent generation of harmful content\",\n    check_function=lambda agent_id, context:\n        not contains_harmful_content(context.get(\"content\", \"\")),\n    violation_type=ViolationType.HARMFUL_CONTENT,\n    severity=PolicySeverity.CRITICAL\n)\n\n# Personal data protection\npersonal_data_rule = PolicyRule(\n    name=\"personal_data_protection\",\n    description=\"Prevent exposure of personal data\",\n    check_function=lambda agent_id, context:\n        not contains_personal_data(context.get(\"content\", \"\")),\n    violation_type=ViolationType.PRIVACY_VIOLATION,\n    severity=PolicySeverity.CRITICAL\n)\n\n# Content moderation policy\nmoderation_rule = PolicyRule(\n    name=\"content_moderation\",\n    description=\"Ensure content meets moderation standards\",\n    check_function=lambda agent_id, context:\n        passes_moderation_check(context.get(\"content\", \"\")),\n    violation_type=ViolationType.CONTENT_POLICY_VIOLATION,\n    severity=PolicySeverity.HIGH\n)\n\ndef passes_moderation_check(content):\n    \"\"\"Check if content passes moderation standards.\"\"\"\n    # Implement your moderation logic or call external moderation API\n    # This is a placeholder implementation\n    return True  # Replace with actual implementation\n</code></pre>"},{"location":"guides/safety_policies/#implementing-custom-policy-rules","title":"Implementing Custom Policy Rules","text":"<p>You can implement custom rules for domain-specific requirements:</p> <pre><code>from safeguards.policies import PolicyRule\nfrom safeguards.types import PolicySeverity, ViolationType\n\n# Create a custom rule for domain-specific requirements\ndomain_specific_rule = PolicyRule(\n    name=\"financial_advice_policy\",\n    description=\"Ensure financial advice includes proper disclaimers\",\n    check_function=lambda agent_id, context:\n        check_financial_advice_compliance(context.get(\"content\", \"\")),\n    violation_type=ViolationType.COMPLIANCE_VIOLATION,\n    severity=PolicySeverity.HIGH\n)\n\ndef check_financial_advice_compliance(content):\n    \"\"\"Check if financial advice includes required disclaimers.\"\"\"\n    if contains_financial_advice(content):\n        required_disclaimer = \"This is not financial advice. Consult a professional advisor.\"\n        return required_disclaimer.lower() in content.lower()\n    return True  # No financial advice detected, so policy doesn't apply\n\ndef contains_financial_advice(content):\n    \"\"\"Detect if content contains financial advice.\"\"\"\n    financial_keywords = [\n        \"invest\", \"stock\", \"bond\", \"portfolio\", \"retirement\",\n        \"savings\", \"fund\", \"return\", \"dividend\", \"market\"\n    ]\n    advice_phrases = [\n        \"you should\", \"recommend\", \"consider\", \"best option\",\n        \"good investment\", \"bad investment\", \"opportunity\"\n    ]\n\n    # Check if content contains both financial keywords and advice phrases\n    has_financial_terms = any(keyword in content.lower() for keyword in financial_keywords)\n    has_advice = any(phrase in content.lower() for phrase in advice_phrases)\n\n    return has_financial_terms and has_advice\n</code></pre>"},{"location":"guides/safety_policies/#advanced-policy-features","title":"Advanced Policy Features","text":""},{"location":"guides/safety_policies/#policy-hierarchies-and-inheritance","title":"Policy Hierarchies and Inheritance","text":"<p>You can organize policies into hierarchies:</p> <pre><code>from safeguards.policies import PolicyHierarchy\n\n# Create a policy hierarchy\npolicy_hierarchy = PolicyHierarchy(name=\"agent_policies\")\n\n# Add top-level policy sets\npolicy_hierarchy.add_policy_set(universal_policies, level=0)  # Apply to all agents\n\n# Add second-level policy sets for different agent types\npolicy_hierarchy.add_policy_set(\n    assistant_policies,\n    level=1,\n    filter_function=lambda agent_id, context: context.get(\"agent_type\") == \"assistant\"\n)\n\npolicy_hierarchy.add_policy_set(\n    researcher_policies,\n    level=1,\n    filter_function=lambda agent_id, context: context.get(\"agent_type\") == \"researcher\"\n)\n\n# Add third-level policies for specific domains\npolicy_hierarchy.add_policy_set(\n    healthcare_policies,\n    level=2,\n    filter_function=lambda agent_id, context: context.get(\"domain\") == \"healthcare\"\n)\n\n# Create a policy enforcer with the hierarchy\nhierarchical_enforcer = PolicyEnforcer(\n    policy_hierarchy=policy_hierarchy,\n    violation_reporter=violation_reporter\n)\n</code></pre>"},{"location":"guides/safety_policies/#policy-conflict-resolution","title":"Policy Conflict Resolution","text":"<p>Handle conflicts between policies:</p> <pre><code>from safeguards.policies import ConflictResolutionStrategy\n\n# Create a policy enforcer with conflict resolution\npolicy_enforcer = PolicyEnforcer(\n    policy_sets=[resource_policies, operational_policies, content_policies],\n    violation_reporter=violation_reporter,\n    conflict_resolution=ConflictResolutionStrategy.MOST_RESTRICTIVE\n)\n\n# Available conflict resolution strategies:\n# - MOST_RESTRICTIVE: Apply the most restrictive policy (deny if any policy denies)\n# - LEAST_RESTRICTIVE: Apply the least restrictive policy (allow if any policy allows)\n# - PRIORITY_BASED: Use policy priority to resolve conflicts\n# - SEVERITY_BASED: Use violation severity to resolve conflicts\n</code></pre>"},{"location":"guides/safety_policies/#dynamic-policy-updates","title":"Dynamic Policy Updates","text":"<p>Update policies dynamically:</p> <pre><code># Update an existing policy rule\nresource_policies.update_rule(\n    \"budget_limit\",\n    new_check_function=lambda agent_id, context:\n        context.get(\"used_budget\", 0) &lt;= context.get(\"new_max_budget\", 150)\n)\n\n# Add a new rule to an existing policy set\nresource_policies.add_rule(\n    PolicyRule(\n        name=\"network_bandwidth_limit\",\n        description=\"Limit network bandwidth usage\",\n        check_function=lambda agent_id, context:\n            context.get(\"bandwidth_usage_mbps\", 0) &lt;= 50,\n        violation_type=ViolationType.RESOURCE_LIMIT_EXCEEDED,\n        severity=PolicySeverity.MEDIUM\n    )\n)\n\n# Remove a rule from a policy set\noperational_policies.remove_rule(\"api_rate_limiting\")\n\n# Create completely new policy set and add to enforcer\nnew_policy_set = PolicySet(\n    name=\"experimental_policies\",\n    description=\"Experimental policies under evaluation\"\n)\n\n# Add the new policy set to the enforcer\npolicy_enforcer.add_policy_set(new_policy_set)\n</code></pre>"},{"location":"guides/safety_policies/#monitoring-policy-effectiveness","title":"Monitoring Policy Effectiveness","text":"<p>Track and analyze policy enforcement:</p> <pre><code>from safeguards.monitoring import PolicyMetricsCollector\nfrom safeguards.visualization import PolicyDashboard\n\n# Create a policy metrics collector\npolicy_metrics = PolicyMetricsCollector()\n\n# Register with the policy enforcer\npolicy_enforcer.set_metrics_collector(policy_metrics)\n\n# Get policy enforcement statistics\nstats = policy_metrics.get_enforcement_stats(\n    timeframe=\"last_24h\"\n)\n\nprint(f\"Total actions checked: {stats['total_actions']}\")\nprint(f\"Actions allowed: {stats['allowed_actions']} ({stats['allowed_percentage']}%)\")\nprint(f\"Actions denied: {stats['denied_actions']} ({stats['denied_percentage']}%)\")\n\n# Get violation statistics by policy\nviolation_stats = policy_metrics.get_violation_stats(\n    group_by=\"policy_rule\",\n    timeframe=\"last_7d\"\n)\n\nprint(\"\\nTop violated policies:\")\nfor rule, count in sorted(violation_stats.items(), key=lambda x: x[1], reverse=True)[:5]:\n    print(f\"- {rule}: {count} violations\")\n\n# Create a policy dashboard\ndashboard = PolicyDashboard(policy_metrics)\n\ndashboard.add_panel(\n    title=\"Policy Enforcement Overview\",\n    panel_type=\"pie_chart\",\n    data_function=lambda: {\n        \"Allowed\": stats[\"allowed_actions\"],\n        \"Denied\": stats[\"denied_actions\"]\n    }\n)\n\ndashboard.add_panel(\n    title=\"Violations by Policy\",\n    panel_type=\"bar_chart\",\n    data_function=lambda: violation_stats\n)\n\ndashboard.add_panel(\n    title=\"Violations by Severity\",\n    panel_type=\"bar_chart\",\n    data_function=lambda: policy_metrics.get_violation_stats(\n        group_by=\"severity\",\n        timeframe=\"last_30d\"\n    )\n)\n\n# Start the dashboard\ndashboard_url = dashboard.start(host=\"0.0.0.0\", port=8081)\nprint(f\"Policy dashboard available at: {dashboard_url}\")\n</code></pre>"},{"location":"guides/safety_policies/#best-practices","title":"Best Practices","text":""},{"location":"guides/safety_policies/#policy-design-principles","title":"Policy Design Principles","text":"<ol> <li> <p>Start with Broad Policies: Begin with fundamental safety constraints that apply to all agents.</p> </li> <li> <p>Layered Approach: Implement policies in layers from general to specific:</p> </li> <li>Universal safety policies</li> <li>Domain-specific policies</li> <li> <p>Agent-specific policies</p> </li> <li> <p>Fail Closed: Design policies to deny actions when information is incomplete or checks fail.</p> </li> <li> <p>Regular Updates: Review and update policies based on new risks and observed behavior.</p> </li> <li> <p>Test Against Edge Cases: Validate policies against edge cases and unexpected inputs.</p> </li> </ol>"},{"location":"guides/safety_policies/#policy-implementation-tips","title":"Policy Implementation Tips","text":"<ol> <li> <p>Efficient Check Functions: Keep policy check functions lightweight and fast.</p> </li> <li> <p>Appropriate Severity Levels: Assign severity levels based on potential harm:</p> </li> <li>CRITICAL: Could cause significant harm</li> <li>HIGH: Could cause notable harm or service disruption</li> <li>MEDIUM: Could cause limited harm or service degradation</li> <li> <p>LOW: Minor issues with minimal impact</p> </li> <li> <p>Clear Documentation: Document the purpose and expected behavior of each policy.</p> </li> <li> <p>Logging and Monitoring: Track policy enforcement to identify patterns and improve policies.</p> </li> <li> <p>Graceful Failure: Ensure the policy system fails gracefully if components are unavailable.</p> </li> </ol>"},{"location":"guides/safety_policies/#conclusion","title":"Conclusion","text":"<p>Implementing robust safety policies is essential for responsible AI agent deployment. The Safeguards provides a flexible and comprehensive system for defining, enforcing, and monitoring these policies.</p> <p>By following the patterns shown in this guide, you can create safety policies that protect against harmful behavior while allowing agents to operate effectively within well-defined constraints.</p> <p>For more information, see: - Monitoring Guide - Budget Management Guide - Notifications Guide - API Reference</p>"},{"location":"usage/basic/","title":"Basic Usage Guide","text":"<p>This guide covers the basic usage of the Safeguards.</p>"},{"location":"usage/basic/#core-components","title":"Core Components","text":"<p>The framework consists of four main components:</p> <ol> <li>Budget Management</li> <li>Resource Monitoring</li> <li>Safety Guardrails</li> <li>Notification System</li> </ol>"},{"location":"usage/basic/#basic-setup","title":"Basic Setup","text":"<pre><code>from safeguards import BudgetManager, ResourceMonitor, NotificationManager\nfrom safeguards.guardrails import BudgetGuardrail, ResourceGuardrail\nfrom safeguards.types import Agent\n\n# Initialize managers\nbudget_manager = BudgetManager(\n    total_budget=1000,\n    hourly_limit=100,\n    daily_limit=500,\n    warning_threshold=75.0,\n)\n\nresource_monitor = ResourceMonitor(\n    cpu_threshold=80.0,\n    memory_threshold=85.0,\n    disk_threshold=90.0,\n)\n\nnotification_manager = NotificationManager()\n\n# Create guardrails\nguardrails = [\n    BudgetGuardrail(budget_manager),\n    ResourceGuardrail(resource_monitor),\n]\n\n# Create agent with safety controls\nagent = Agent(\n    name=\"safe_agent\",\n    instructions=\"Your instructions here\",\n    guardrails=guardrails,\n)\n</code></pre>"},{"location":"usage/basic/#running-an-agent","title":"Running an Agent","text":"<pre><code># Simple execution\nresult = agent.run(input_data=\"Your input here\")\n\n# With context\ncontext = {\n    \"max_tokens\": 1000,\n    \"temperature\": 0.7,\n}\nresult = agent.run(input_data=\"Your input here\", **context)\n</code></pre>"},{"location":"usage/basic/#monitoring-usage","title":"Monitoring Usage","text":"<pre><code># Check budget usage\nremaining_budget = budget_manager.get_remaining_budget(agent.id)\nusage_percent = budget_manager.get_budget_usage_percent(agent.id)\n\n# Check resource usage\nmetrics = resource_monitor.get_current_metrics()\nprint(resource_monitor.get_resource_usage_summary(metrics))\n\n# Get notifications\nnotifications = notification_manager.get_notifications(agent_id=agent.id)\n</code></pre>"},{"location":"usage/basic/#error-handling","title":"Error Handling","text":"<pre><code>from safeguards.notifications import NotificationLevel\n\ntry:\n    result = agent.run(input_data=\"Your input here\")\nexcept Exception as e:\n    notification_manager.notify(\n        level=NotificationLevel.ERROR,\n        message=f\"Agent execution failed: {str(e)}\",\n        agent_id=agent.id,\n    )\n</code></pre>"},{"location":"usage/basic/#best-practices","title":"Best Practices","text":"<ol> <li>Always set appropriate thresholds for your environment</li> <li>Monitor notification logs regularly</li> <li>Handle budget overages gracefully</li> <li>Implement proper error handling</li> <li>Regular resource usage checks</li> </ol>"},{"location":"usage/basic/#example-complete-workflow","title":"Example: Complete Workflow","text":"<pre><code>from safeguards import (\n    BudgetManager,\n    ResourceMonitor,\n    NotificationManager,\n    SafetyController,\n)\nfrom safeguards.types import Agent\nfrom safeguards.notifications import NotificationLevel\n\n# Initialize components\nbudget_manager = BudgetManager(total_budget=1000)\nresource_monitor = ResourceMonitor()\nnotification_manager = NotificationManager()\n\n# Create safety controller\ncontroller = SafetyController(\n    budget_manager=budget_manager,\n    resource_monitor=resource_monitor,\n    notification_manager=notification_manager,\n)\n\n# Create agent\nagent = Agent(\n    name=\"safe_agent\",\n    instructions=\"Your instructions here\",\n    controller=controller,\n)\n\ntry:\n    # Check resources before running\n    if resource_monitor.has_exceeded_thresholds():\n        notification_manager.notify(\n            level=NotificationLevel.WARNING,\n            message=\"High resource usage detected\",\n            agent_id=agent.id,\n        )\n\n    # Check budget\n    if not budget_manager.has_sufficient_budget(agent.id):\n        notification_manager.notify(\n            level=NotificationLevel.ERROR,\n            message=\"Insufficient budget\",\n            agent_id=agent.id,\n        )\n        raise ValueError(\"Insufficient budget\")\n\n    # Run agent\n    result = agent.run(input_data=\"Your input here\")\n\n    # Record cost\n    budget_manager.record_cost(agent.id, cost=10.0)\n\nexcept Exception as e:\n    notification_manager.notify(\n        level=NotificationLevel.ERROR,\n        message=f\"Execution failed: {str(e)}\",\n        agent_id=agent.id,\n    )\n    raise\n</code></pre>"},{"location":"usage/basic/#next-steps","title":"Next Steps","text":"<ul> <li>Budget Management Guide</li> <li>Resource Monitoring Guide</li> <li>Safety Guardrails Guide</li> <li>Notification System Guide</li> </ul>"}]}